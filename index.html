<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Linglow</title>
    <style>
        /* 移动端基础样式 */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f7f7f7;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden; /* 防止底部输入框滚动 */
        }
        
        /* App容器 */
        #app-container {
            height: 100%;
            width: 100%;
            display: flex;
            flex-direction: column;
        }
        
        /* 顶部导航栏 (Header) 
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background-color: #EDEDED; // 仿微信深色顶部 
            color: #333;
            font-size: 18px;
            font-weight: 500;
            border-bottom: 1px solid #dcdcdc;
            flex-shrink: 0;
        }*/
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background-color: #EDEDED;
            color: #333;
            font-size: 18px;
            font-weight: 500;
            border-bottom: 1px solid #dcdcdc;
            
            /* --- 关键修改 --- */
            position: sticky;  /* 粘性定位 */
            top: 0;            /* 粘在顶部 */
            z-index: 1000;     /* 保证在最上层 */
            width: 100%;       /* 占满容器宽度 */
            box-sizing: border-box;
            flex-shrink: 0;    /* 防止在 flex 布局中被压缩 */
        }
        .header-title {
            flex-grow: 1;
            text-align: center;
        }

        .header button {
            background: none;
            border: none;
            color: #333;
            font-size: 22px;
            cursor: pointer;
            padding: 0;
            line-height: 1;
            min-width: 40px; /* 增加点击区域 */
            text-align: center;
        }
        
        /* 返回按钮特殊样式 */
        .header button svg {
            vertical-align: middle;
        }

        /* 底部导航栏 (Footer for tab switching)
        .footer-nav {
            display: flex;
            justify-content: space-around;
            padding: 5px 0;
            border-top: 1px solid #ccc;
            background-color: #f7f7f7;
            flex-shrink: 0;
        }

        .nav-item {
            text-align: center;
            cursor: pointer;
            padding: 5px;
            color: #999;
        }

        .nav-item.active {
            color: #1AAD19; ///微信绿色 
            font-weight: 500;
        } /*
        
        /* 主内容区域 (Content Area) */
        .content {
            flex-grow: 1;
            overflow-y: auto;
            position: relative;
            min-height: 0;  /* 重要！让 flex-grow 在 overflow 容器中正常工作 */
            box-sizing: border-box;
        }

        /* 聊天界面 */
        #chat-container {
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding-bottom: 150px; /* 增加底部padding以防被输入区域遮挡(考虑引用预览的高度) */
        }

        .message {
            display: flex;
            flex-direction: row; /* 横向布局:头像和内容左右排列 */
            margin-bottom: 5px;
            gap: 8px;
        }

        .message.user {
            justify-content: flex-end; /* 用户消息右对齐 */
        }

        .message.assistant {
            justify-content: flex-start; /* AI消息左对齐 */
        }
        
        /* 用户消息:头像在右侧 */
        .message.user {
            flex-direction: row-reverse;
        }

        .bubble {
            max-width: 100%; /* 改为100%，由contentWrapper控制最大宽度 */
            width: fit-content; /* 自适应内容宽度 */
            padding: 8px 12px; /* 调整为微信的padding */
            padding-bottom: 20px; /* 为时间戳留出空间 */
            border-radius: 6px; /* 微信的圆角 */
            line-height: 1.4;
            word-wrap: break-word;
            position: relative;
        }
        
        /* 短消息气泡：内容<=3个中文字符时增加右侧padding */
        .bubble.short-message {
            padding-right: 40px; /* 在原有12px基础上额外增加40px，为时间戳和双对号留出空间 */
        }

        .message.user .bubble {
            background-color: #95EC69; /* 微信用户气泡颜色 */
            color: #000;
            border-top-right-radius: 0; /* 右上角尖角 */
        }

        .message.assistant .bubble {
            background-color: #fff; /* AI气泡颜色 */
            color: #000;
            border-top-left-radius: 0; /* 左上角尖角 */
            border: 1px solid #e5e5e5; /* 微信的边框颜色 */
        }
        
        /* 消息内容包装器（包含引用和气泡） */
        .message-content-wrapper {
            display: flex;
            flex-direction: column;
            max-width: 75%;
            width: fit-content; /* 自适应内容宽度 */
        }
        
        /* AI消息：内容左对齐（紧贴左侧头像） */
        .message.assistant .message-content-wrapper {
            align-items: flex-start;
        }
        
        /* 用户消息：内容右对齐（紧贴右侧头像） */
        .message.user .message-content-wrapper {
            align-items: flex-end;
        }
        
        /* WhatsApp风格的时间戳和状态 */
        .message-meta {
            position: absolute;
            bottom: 3px;
            right: 8px;
            font-size: 11px;
            color: #667781;
            display: flex;
            align-items: center;
            gap: 3px;
        }
        
        .message.user .message-meta {
            color: #667781;
        }
        
        /* 对勾样式 */
        .checkmark {
            display: inline-block;
            font-size: 14px;
            color: #667781;
        }
        
        .checkmark.double {
            color: #53bdeb; /* 蓝色表示已读/已送达 */
        }
        
        /* 正在输入指示器 (仿微信，黑色) */
        .typing-indicator {
            color: #333;
            font-size: 18px;
        }
        .page {
            display: none;
            height: 100vh;
            flex-direction: column;
        }

        .page.active {
            display: flex;
            height: 100vh;
        }

        /* 聊天输入区 */
        .chat-input-area {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: #f7f7f7;
            padding: 5px 6px; /* 进一步减小padding */
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 3px; /* 最小间距 */
            border-top: 1px solid #dcdcdc;
            box-shadow: 0 -1px 3px rgba(0,0,0,0.05);
            flex-shrink: 0;
        }
        
        /* 引用预览占满一行 */
        .chat-input-area .quote-reference {
            width: 100%;
            order: 999; /* 确保在最后面（输入框下方） */
            margin: 6px 0 0 0; /* 在输入框下方留间距 */
        }
        
        .input-tool-btn {
            background: none;
            border: none;
            padding: 4px; /* 最小padding */
            cursor: pointer;
            color: #666;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: background-color 0.2s;
            flex-shrink: 0;
            width: 32px;
            height: 32px;
        }
        
        .input-tool-btn svg {
            width: 20px;
            height: 20px;
        }
        
        .input-tool-btn:hover {
            background-color: #e0e0e0;
        }
        
        .input-tool-btn:active {
            background-color: #d0d0d0;
        }

        #user-input {
            flex: 1 1 auto;
            min-width: 80px; /* 进一步减小最小宽度 */
            padding: 6px 8px; /* 减小padding */
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 15px;
            resize: none;
            max-height: 80px;
            overflow-y: auto;
            background-color: white;
            line-height: 1.4;
        }
        
        /* 设置界面 */
        #settings-page {
            padding: 20px;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #555;
        }
        
        .form-group input, .form-group textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            box-sizing: border-box;
            font-size: 14px;
        }

        #save-settings-btn {
            width: 100%;
            background-color: #1AAD19;
            color: white;
            border: none;
            padding: 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 20px;
        }

        /* 桌面与图标样式 */
        .home-page .wallpaper {
            background: linear-gradient(180deg,#cce8d7 0%, #67c77f 100%);
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 40px;
            box-sizing: border-box;
        }

        .desktop {
            width: 100%;
            max-width: 420px;
            display: grid;
            grid-template-columns: repeat(3, 1fr); /* 3 columns per row, 4 rows total */
            grid-auto-rows: 120px; /* fixed row height to ensure 4 visible rows */
            gap: 18px;
            padding: 20px;
            box-sizing: border-box;
            justify-items: center;
            align-content: start;
        }

        .desktop-slot {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .app-icon {
            width: 64px;
            height: 64px;
            background: rgba(255,255,255,0.12);
            border-radius: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 28px;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(0,0,0,0.15);
            user-select: none;
        }

        .app-label {
            margin-top: 6px;
            font-size: 12px;
            color: rgba(255,255,255,0.95);
            text-align: center;
            width: 84px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* 固定 Dock 栏 (底部) */
        .dock {
            position: fixed;
            left: 0;
            right: 0;
            bottom: 50px; /* 在页面底部上方，和现有 footer-nav 留出空间 */
            display: flex;
            justify-content: center;
            pointer-events: none; /* 让内部项目控制点击 */
        }

        .dock-inner {
            background: rgba(255,255,255,0.12);
            padding: 8px 18px;
            border-radius: 16px;
            display: flex;
            gap: 18px;
            box-shadow: 0 6px 18px rgba(0,0,0,0.15);
            pointer-events: auto;
        }

        .dock-item {
            width: 56px;
            height: 56px;
            border-radius: 12px;
            background: rgba(255,255,255,0.14);
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 24px;
            cursor: pointer;
        }

        /* Dock item press / dragging styles - animations removed for clarity */
        .dock-item {
            will-change: auto;
        }

        .dock-item.dragging {
            opacity: 0.5;
        }

        .app-icon.dragging {
            opacity: 0.5;
        }

        /* 隐藏和显示页面 */
        .page {
            display: none;
            height: 100%;
            width: 100%;
        }

        .page.active {
            display: flex;
            flex-direction: column;
        }
        
        /* ========== 头像样式 ========== */
        .message-avatar {
            width: 40px;
            height: 40px;
            border-radius: 6px;
            object-fit: cover;
            flex-shrink: 0;
        }
        
        .message.user {
            flex-direction: row;
        }
        
        .message.assistant {
            flex-direction: row;
        }
        
        .message.user .message-avatar {
            order: 2;
            margin-left: 8px;
        }
        
        .message.assistant .message-avatar {
            order: 0;
            margin-right: 8px;
        }
        
        .message.user .bubble {
            order: 1;
        }
        
        .message.assistant .bubble {
            order: 1;
        }
        
        .default-avatar {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: 600;
            color: white;
            border-radius: 6px;
        }
        
        .default-avatar.ai {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        .default-avatar.user {
            background: linear-gradient(135deg, #07c160 0%, #06ae56 100%);
        }
        
        .avatar-preview-container {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-top: 8px;
        }
        
        .avatar-preview {
            width: 80px;
            height: 80px;
            border-radius: 8px;
            object-fit: cover;
            border: 1px solid #e7e7e7;
            flex-shrink: 0;
        }
        
        .avatar-preview.small {
            width: 60px;
            height: 60px;
        }
        
        .avatar-upload-btn {
            padding: 8px 16px;
            background: #07c160;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .avatar-upload-btn:active {
            opacity: 0.8;
        }
        
        .avatar-remove-btn {
            padding: 8px 16px;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .avatar-remove-btn:active {
            opacity: 0.8;
        }
        
        /* ========== 底部导航栏 ========== */
        .bottom-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 50px;
            background-color: #f7f7f7;
            border-top: 1px solid #d9d9d9;
            display: flex;
            justify-content: space-around;
            align-items: center;
            z-index: 1000;
        }
        
        .nav-item {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: #999;
            font-size: 11px;
            gap: 2px;
            padding: 4px 0;
            transition: color 0.2s;
            user-select: none;
        }
        
        .nav-item svg {
            width: 24px;
            height: 24px;
            stroke: currentColor;
        }
        
        .nav-item.active {
            color: #07c160; /* 微信绿 */
        }
        
        .nav-item.active svg {
            stroke: #07c160;
        }
        
        /* 为底部导航留出空间 */
        .page-with-nav .content {
            padding-bottom: 50px;
        }
        
        /* ========== 全局消息通知横幅 ========== */
        .message-notification {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.85);
            padding: 12px 16px;
            display: none;
            align-items: center;
            gap: 12px;
            z-index: 10000;
            animation: slideDown 0.3s ease-out;
            cursor: pointer;
            user-select: none;
        }
        
        @keyframes slideDown {
            from {
                transform: translateY(-100%);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        @keyframes slideUp {
            from {
                transform: translateY(0);
                opacity: 1;
            }
            to {
                transform: translateY(-100%);
                opacity: 0;
            }
        }
        
        .message-notification.show {
            display: flex;
        }
        
        .message-notification.hiding {
            animation: slideUp 0.3s ease-out;
        }
        
        .message-notification-avatar {
            width: 40px;
            height: 40px;
            border-radius: 6px;
            flex-shrink: 0;
            object-fit: cover;
        }
        
        .message-notification-content {
            flex: 1;
            min-width: 0;
        }
        
        .message-notification-name {
            font-size: 14px;
            font-weight: 500;
            color: white;
            margin-bottom: 2px;
        }
        
        .message-notification-text {
            font-size: 13px;
            color: rgba(255, 255, 255, 0.8);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .message-notification-close {
            width: 20px;
            height: 20px;
            color: rgba(255, 255, 255, 0.6);
            flex-shrink: 0;
            font-size: 20px;
            line-height: 1;
        }
        
        /* ========== 配置提醒对话框 ========== */
        .config-reminder-dialog {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10001;
        }
        
        .config-reminder-dialog.show {
            display: flex;
        }
        
        .config-reminder-content {
            background: white;
            border-radius: 12px;
            width: 85%;
            max-width: 360px;
            padding: 24px;
            text-align: center;
        }
        
        .config-reminder-icon {
            font-size: 48px;
            margin-bottom: 16px;
        }
        
        .config-reminder-title {
            font-size: 18px;
            font-weight: 600;
            color: #333;
            margin-bottom: 12px;
        }
        
        .config-reminder-message {
            font-size: 14px;
            color: #666;
            line-height: 1.6;
            margin-bottom: 20px;
        }
        
        .config-reminder-buttons {
            display: flex;
            gap: 12px;
        }
        
        .config-reminder-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 6px;
            font-size: 15px;
            cursor: pointer;
            transition: opacity 0.2s;
        }
        
        .config-reminder-btn:active {
            opacity: 0.7;
        }
        
        .config-reminder-btn.secondary {
            background: #f0f0f0;
            color: #333;
        }
        
        .config-reminder-btn.primary {
            background: #07c160;
            color: white;
        }
        
        /* ========== 聊天列表样式 ========== */
        .character-list-item {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            border-bottom: 1px solid #e7e7e7;
            cursor: pointer;
            background: #fff;
        }
        .character-list-item:active {
            background-color: #ececec;
        }
        .character-list-avatar {
            width: 48px;
            height: 48px;
            border-radius: 6px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            color: white;
            margin-right: 12px;
            flex-shrink: 0;
        }
        .character-list-info {
            flex: 1;
            min-width: 0;
        }
        .character-list-name {
            font-size: 16px;
            font-weight: 500;
            color: #000;
            margin-bottom: 4px;
        }
        .character-list-preview {
            font-size: 14px;
            color: #999;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .character-add-menu {
            position: fixed;
            top: 50px;
            right: 10px;
            background: white;
            border-radius: 6px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 9999;
            min-width: 140px;
            display: none;
        }
        .character-add-menu.active {
            display: block;
        }
        .character-add-menu-item {
            padding: 14px 20px;
            border-bottom: 1px solid #e7e7e7;
            cursor: pointer;
            font-size: 15px;
            color: #000;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .character-add-menu-item:last-child {
            border-bottom: none;
        }
        .character-add-menu-item:active {
            background-color: #ececec;
        }
        .character-new-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.6);
            z-index: 10000;
            align-items: center;
            justify-content: center;
        }
        .character-new-modal.active {
            display: flex;
        }
        .character-new-modal-content {
            background: white;
            border-radius: 12px;
            width: 85%;
            max-width: 400px;
            max-height: 80vh;
            overflow: hidden;
        }
        .character-new-modal-header {
            padding: 16px 20px;
            border-bottom: 1px solid #e7e7e7;
            font-size: 17px;
            font-weight: 500;
            text-align: center;
        }
        .character-new-modal-body {
            padding: 20px;
            overflow-y: auto;
            max-height: calc(80vh - 150px);
        }
        .character-new-modal-footer {
            padding: 12px 20px;
            border-top: 1px solid #e7e7e7;
            display: flex;
            gap: 12px;
        }
        .character-new-modal-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
        }
        .character-new-modal-btn.cancel {
            background: #f0f0f0;
            color: #333;
        }
        .character-new-modal-btn.confirm {
            background: #07c160;
            color: white;
        }
        .character-empty-list {
            text-align: center;
            padding: 80px 20px;
            color: #999;
        }
        
        /* ========== 长按菜单样式 ========== */
        .bubble-menu {
            position: fixed;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            padding: 10px;
            z-index: 10000;
            display: none;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            min-width: 270px;
            max-width: 90vw; /* 限制最大宽度为屏幕宽度的90% */
        }
        
        .bubble-menu.active {
            display: grid;
        }
        
        .bubble-menu-item {
            padding: 12px 8px;
            cursor: pointer;
            user-select: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
            font-size: 13px;
            color: #333;
            transition: background 0.2s;
            border-radius: 8px;
            background: #f7f7f7;
            text-align: center;
            min-width: 0; /* 允许内容收缩 */
        }
        
        .bubble-menu-item:hover {
            background: #e8e8e8;
        }
        
        .bubble-menu-item:active {
            background: #d8d8d8;
        }
        
        .bubble-menu-item.danger {
            color: #ff3b30;
        }
        
        .bubble-menu-item .icon {
            font-size: 20px;
        }
        
        /* 遮罩层 */
        .menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.3);
            z-index: 9999;
            display: none;
        }
        
        .menu-overlay.active {
            display: block;
        }
        
        /* 气泡选中状态 */
        .bubble.menu-active {
            background: rgba(0,0,0,0.05);
        }
        
        /* ========== 多选模式样式（完全仿微信）========== */
        
        /* 多选模式激活时的聊天容器调整 */
        .multi-select-mode-active #chat-container {
            padding-left: 0; /* 移除padding */
            padding-bottom: 80px; /* 为底部工具栏留出空间 */
        }
        
        /* 多选模式下的消息整体右移 */
        .multi-select-mode-active .message {
            margin-left: 55px; /* 整体右移，为复选框留空间 */
        }
        
        /* 多选模式下隐藏输入框 */
        .multi-select-mode-active .chat-input-area {
            display: none !important;
        }
        
        /* 消息容器需要相对定位 */
        .message {
            position: relative;
        }
        
        /* 多选模式下消息整体右移，避免与复选框重叠 */
        .multi-select-mode-active .message {
            margin-left: 40px; /* 向右移动，为复选框留出空间 */
        }
        
        /* 复选框容器 - 默认隐藏 */
        .multi-select-checkbox {
            position: absolute;
            left: -32px; /* 负值，使复选框显示在消息左侧 */
            top: 50%;
            transform: translateY(-50%);
            width: 22px;
            height: 22px;
            border: 1.5px solid #c8c8c8;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            display: none; /* 默认隐藏 */
            align-items: center;
            justify-content: center;
            z-index: 10;
            transition: all 0.15s;
        }
        
        /* 多选模式激活时显示复选框 */
        .multi-select-mode-active .multi-select-checkbox {
            display: flex !important; /* 强制显示 */
        }
        
        /* 选中状态的复选框 */
        .multi-select-checkbox.checked {
            background: #07c160;
            border-color: #07c160;
        }
        
        /* 选中状态的勾号 - 使用CSS绘制 */
        .multi-select-checkbox.checked::after {
            content: '';
            width: 4px;
            height: 8px;
            border: solid white;
            border-width: 0 1.5px 1.5px 0;
            transform: rotate(45deg);
            margin-bottom: 2px;
        }
        
        /* 多选模式顶部工具栏 */
        .multi-select-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 44px;
            background: #EDEDED;
            border-bottom: 0.5px solid #d9d9d9;
            display: none;
            align-items: center;
            justify-content: space-between;
            padding: 0 16px;
            z-index: 2001;
        }
        
        .multi-select-header.active {
            display: flex;
        }
        
        .multi-select-header-left {
            display: flex;
            align-items: center;
            gap: 20px;
        }
        
        .multi-select-cancel-btn {
            font-size: 17px;
            color: #576b95;
            background: none;
            border: none;
            cursor: pointer;
            padding: 0;
        }
        
        .multi-select-cancel-btn:active {
            opacity: 0.6;
        }
        
        .multi-select-count {
            font-size: 17px;
            color: #000;
        }
        
        .multi-select-select-all-btn {
            font-size: 17px;
            color: #576b95;
            background: none;
            border: none;
            cursor: pointer;
            padding: 0;
        }
        
        .multi-select-select-all-btn:active {
            opacity: 0.6;
        }
        
        /* 搜索框 */
        .multi-select-search {
            position: fixed;
            top: 44px;
            left: 0;
            right: 0;
            background: #EDEDED;
            padding: 8px 12px;
            z-index: 2000;
            display: none;
        }
        
        .multi-select-search.active {
            display: block;
        }
        
        .multi-select-search-input {
            width: 100%;
            padding: 8px 12px;
            border: none;
            border-radius: 8px;
            background: #fff;
            font-size: 15px;
            box-sizing: border-box;
            outline: none;
        }
        
        /* Select按钮 */
        .multi-select-btn-container {
            position: fixed;
            top: 104px;
            left: 16px;
            z-index: 2000;
            display: none;
        }
        
        .multi-select-btn-container.active {
            display: block;
        }
        
        .multi-select-select-btn {
            background: white;
            border: 1px solid #d9d9d9;
            border-radius: 6px;
            padding: 6px 12px;
            font-size: 14px;
            color: #576b95;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .multi-select-select-btn:active {
            background: #f0f0f0;
        }
        
        /* 多选模式下聊天容器需要留出顶部空间 */
        .multi-select-mode-active #chat-page .content {
            padding-top: 104px; /* 为顶部工具栏和搜索框留空间 */
        }
        
        /* 底部操作栏（完全仿微信 - 图标版）*/
        .multi-select-toolbar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: #F7F7F7;
            border-top: 0.5px solid #d9d9d9;
            display: none;
            flex-direction: row;
            justify-content: space-around;
            align-items: center;
            z-index: 2000;
            padding: 0 20px;
        }
        
        .multi-select-toolbar.active {
            display: flex;
        }
        
        .multi-select-toolbar-btn {
            flex: 1;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 26px;
            color: #000;
            transition: opacity 0.2s;
            gap: 2px;
        }
        
        .multi-select-toolbar-btn:active {
            opacity: 0.5;
        }
        
        .multi-select-toolbar-btn.disabled {
            opacity: 0.3;
            pointer-events: none;
        }
        
        .multi-select-toolbar-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 2px;
        }
        
        .multi-select-toolbar-text {
            font-size: 10px;
            color: #000;
            line-height: 1;
        }
        
        /* ========== 收藏页面样式 ========== */
        .favorite-item {
            background: white;
            margin-bottom: 10px;
            padding: 12px 16px;
            border-radius: 6px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .favorite-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        
        .favorite-sender {
            font-size: 14px;
            font-weight: 500;
            color: #333;
        }
        
        .favorite-time {
            font-size: 12px;
            color: #999;
        }
        
        .favorite-content {
            font-size: 15px;
            color: #333;
            line-height: 1.5;
            word-wrap: break-word;
        }
        
        .favorite-actions {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #f0f0f0;
        }
        
        .favorite-action-btn {
            font-size: 13px;
            color: #576b95;
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px 8px;
        }
        
        .favorite-action-btn:hover {
            opacity: 0.7;
        }
        
        .favorite-action-btn.delete {
            color: #ff3b30;
        }
        
        /* ========== 转发选择列表样式 ========== */
        .forward-character-item {
            background: white;
            display: flex;
            align-items: center;
            padding: 12px 16px;
            border-bottom: 1px solid #EDEDED;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .forward-character-item:hover {
            background: #f5f5f5;
        }
        
        .forward-character-item:active {
            background: #e8e8e8;
        }
        
        .forward-character-avatar {
            width: 48px;
            height: 48px;
            border-radius: 6px;
            margin-right: 12px;
            flex-shrink: 0;
        }
        
        .forward-character-info {
            flex: 1;
            min-width: 0;
        }
        
        .forward-character-name {
            font-size: 16px;
            font-weight: 500;
            color: #333;
            margin-bottom: 4px;
        }
        
        .forward-character-desc {
            font-size: 13px;
            color: #999;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        /* 批量生成对话框 */
        .batch-generate-dialog {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10004;
        }
        
        .batch-generate-content {
            background: white;
            border-radius: 12px;
            width: 90%;
            max-width: 600px;
            max-height: 85vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }
        
        .batch-generate-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .batch-generate-header h3 {
            margin: 0;
            font-size: 18px;
            color: #333;
        }
        
        .batch-generate-close {
            background: none;
            border: none;
            font-size: 28px;
            color: #999;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
        }
        
        .batch-generate-close:hover {
            background: #f0f0f0;
            color: #333;
        }
        
        .batch-generate-body {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }
        
        .batch-generate-footer {
            display: flex;
            gap: 12px;
            padding: 16px 20px;
            border-top: 1px solid #e0e0e0;
            justify-content: flex-end;
        }
        
        /* 单选按钮样式增强 */
        input[type="radio"]:checked + div {
            color: #4CAF50;
        }
        
        label:has(input[type="radio"]:checked) {
            border-color: #4CAF50 !important;
            background-color: #f1f8f4;
        }
        
        /* 导入和批量生成模式选择对话框的按钮悬停效果 */
        #import-mode-dialog button:not(.batch-generate-close):hover,
        #batch-mode-dialog button:not(.batch-generate-close):hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        #import-mode-dialog button:not(.batch-generate-close):active,
        #batch-mode-dialog button:not(.batch-generate-close):active {
            transform: translateY(0);
        }
        
        /* 导入记忆对话框 */
        .import-memory-dialog {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10005;
        }
        
        .import-memory-content {
            background: white;
            border-radius: 12px;
            width: 90%;
            max-width: 550px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }
        
        .import-memory-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .import-memory-header h3 {
            margin: 0;
            font-size: 18px;
            color: #333;
        }
        
        .import-memory-close {
            background: none;
            border: none;
            font-size: 28px;
            color: #999;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
        }
        
        .import-memory-close:hover {
            background: #f0f0f0;
            color: #333;
        }
        
        .import-memory-body {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }
        
        .import-memory-footer {
            display: flex;
            gap: 12px;
            padding: 16px 20px;
            border-top: 1px solid #e0e0e0;
            justify-content: flex-end;
        }
        
        /* 记忆编辑模态窗口 */
        .memory-edit-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10003;
        }
        
        .memory-edit-content {
            background: white;
            border-radius: 12px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }
        
        .memory-edit-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .memory-edit-header h3 {
            margin: 0;
            font-size: 18px;
            color: #333;
        }
        
        .memory-edit-close {
            background: none;
            border: none;
            font-size: 28px;
            color: #999;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
        }
        
        .memory-edit-close:hover {
            background: #f0f0f0;
            color: #333;
        }
        
        .memory-edit-body {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }
        
        .memory-section {
            margin-bottom: 24px;
        }
        
        .memory-section h4 {
            margin: 0 0 12px 0;
            font-size: 16px;
            color: #555;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 6px;
        }
        
        .memory-section textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            resize: vertical;
            box-sizing: border-box;
            font-family: inherit;
        }
        
        .basic-info-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            gap: 8px;
        }
        
        .basic-info-item label {
            min-width: 80px;
            font-size: 14px;
            color: #666;
        }
        
        .basic-info-item input {
            flex: 1;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .event-item {
            background: #f9f9f9;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 12px;
        }
        
        .event-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .event-item-date {
            font-size: 12px;
            color: #999;
        }
        
        .event-item-importance {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .event-item-importance label {
            font-size: 12px;
            color: #666;
        }
        
        .event-item-importance input {
            width: 60px;
            padding: 4px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .event-item-delete {
            background: #ff4444;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .event-item textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            resize: vertical;
            box-sizing: border-box;
            font-family: inherit;
        }
        
        .memory-edit-footer {
            display: flex;
            gap: 12px;
            padding: 16px 20px;
            border-top: 1px solid #e0e0e0;
            justify-content: flex-end;
        }
        
        /* 确认对话框 */
        .confirm-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border-radius: 12px;
            padding: 0;
            max-width: 280px;
            width: 85%;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            z-index: 10002;
            display: none;
            overflow: hidden;
        }
        
        .confirm-dialog.active {
            display: block;
        }
        
        .confirm-dialog-title {
            font-size: 17px;
            font-weight: 500;
            padding: 20px 20px 0 20px;
            color: #000;
            text-align: center;
        }
        
        .confirm-dialog-message {
            font-size: 14px;
            color: #666;
            padding: 12px 20px 20px 20px;
            line-height: 1.6;
            text-align: center;
        }
        
        .confirm-dialog-buttons {
            display: flex;
            flex-direction: column;
            border-top: 0.5px solid #e0e0e0;
        }
        
        .confirm-dialog-button {
            width: 100%;
            padding: 14px 16px;
            border: none;
            border-bottom: 0.5px solid #e0e0e0;
            background: white;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.2s;
            text-align: center;
        }
        
        .confirm-dialog-button:last-child {
            border-bottom: none;
        }
        
        .confirm-dialog-button:active {
            background: #f5f5f5;
        }
        
        .confirm-dialog-button.primary {
            color: #576b95;
            font-weight: 500;
        }
        
        .confirm-dialog-button.secondary {
            color: #576b95;
        }
        
        .confirm-dialog-button.cancel {
            color: #000;
        }
        
        /* ========== 编辑模式样式 ========== */
        .bubble.editing {
            background: #fff3cd !important;
            border: 2px solid #ffc107 !important;
            position: relative;
        }
        
        .edit-textarea {
            width: 100%;
            min-height: 60px;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 15px;
            font-family: inherit;
            line-height: 1.4;
            resize: vertical;
            box-sizing: border-box;
            margin-bottom: 8px;
        }
        
        .edit-buttons {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }
        
        .edit-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .edit-btn.save {
            background: #1AAD19;
            color: white;
        }
        
        .edit-btn.save:hover {
            background: #178f15;
        }
        
        .edit-btn.cancel {
            background: #f0f0f0;
            color: #333;
        }
        
        .edit-btn.cancel:hover {
            background: #e0e0e0;
        }
        
        /* ========== 引用样式 ========== */
        /* 输入框下方的引用预览 (微信风格) */
        .quote-reference {
            background: #e0e0e0; /* 更深的灰色背景 */
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px; /* 小字 */
            color: #666; /* 深一点的文字颜色 */
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px; /* 在输入框下方留间距 */
        }
        
        .quote-reference .quote-content {
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap; /* 单行显示 */
            line-height: 1.4;
        }
        
        .quote-reference .quote-close {
            flex-shrink: 0;
            cursor: pointer;
            font-size: 20px;
            color: #666;
            line-height: 1;
            padding: 0 4px;
            font-weight: bold;
        }
        
        .quote-reference .quote-close:hover {
            color: #333;
        }
        
        /* 消息气泡内的引用样式 (微信风格) */
        .quoted-message {
            background: rgba(0, 0, 0, 0.05); /* 略深的半透明背景 */
            padding: 6px 8px;
            margin-top: 8px; /* 在正文下方留间距 */
            margin-bottom: 0;
            border-radius: 4px;
            font-size: 11px;
            color: #999; /* 灰色 */
            line-height: 1.3;
            width: fit-content;
            max-width: 100%;
            box-sizing: border-box;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap; /* 单行显示 */
            order: 10; /* 确保在气泡后面 */
        }
        
        .quoted-message .quote-sender {
            font-weight: normal;
            color: #999;
            margin-right: 0;
        }
        
        /* 用户和AI的引用样式统一 */
        .message.user .quoted-message,
        .message.assistant .quoted-message {
            background: rgba(0, 0, 0, 0.05);
        }
    </style>
</head>
<body>

    <!-- 全局消息通知横幅 -->
    <div class="message-notification" id="message-notification">
        <div class="message-notification-avatar" id="notification-avatar">
            <div class="default-avatar ai" style="width: 40px; height: 40px; border-radius: 6px;">AI</div>
        </div>
        <div class="message-notification-content">
            <div class="message-notification-name" id="notification-name">AI 聊天对象</div>
            <div class="message-notification-text" id="notification-text">新消息</div>
        </div>
        <div class="message-notification-close">×</div>
    </div>
    
    <!-- 配置缺失提醒对话框 -->
    <div class="config-reminder-dialog" id="config-reminder-dialog">
        <div class="config-reminder-content">
            <div class="config-reminder-icon">⚙️</div>
            <div class="config-reminder-title">需要配置 API</div>
            <div class="config-reminder-message">
                检测到 API 配置缺失，无法发送消息。<br>
                请先在设置中配置 API Base URL、API Key 和 Model Name。
            </div>
            <div class="config-reminder-buttons">
                <button class="config-reminder-btn secondary" onclick="closeConfigReminder()">稍后</button>
                <button class="config-reminder-btn primary" onclick="goToSettings()">去设置</button>
            </div>
        </div>
    </div>

    <div id="app-container" style="height: 100%;">
        
        <div id="home-page" class="page active">
            <header class="header">
                <span></span>
            </header>
            <div class="content home-page">
                <div class="wallpaper" style="width:100%">
                    <div class="desktop" id="desktop-grid">
                    </div>
                </div>

                <div class="dock">
                    <div class="dock-inner">
                    </div>
                </div>
            </div>
        </div>

        <!-- ==================== 系统设置页面 ==================== -->
        <div id="system-settings-page" class="page">
            <header class="header">
                <button onclick="showPage('home-page')">‹</button>
                <span class="header-title">系统设置</span>
                <span></span>
            </header>
            
            <div class="content" style="padding: 20px; background-color: #f5f5f5;">
                <div style="background: white; border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                    <h2 style="margin: 0 0 10px 0; font-size: 18px; color: #333;">📦 数据管理</h2>
                    <p style="font-size: 14px; color: #666; margin: 0 0 20px 0;">
                        导出或导入所有数据，包括所有角色的聊天记录、配置和长期记忆。
                    </p>
                    
                    <div style="display: flex; flex-direction: column; gap: 12px;">
                        <button onclick="exportAllData()" style="padding: 14px; background-color: #4CAF50; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: 500;">
                            💾 导出所有数据
                        </button>
                        
                        <button onclick="document.getElementById('import-all-data-input').click()" style="padding: 14px; background-color: #2196F3; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: 500;">
                            📥 导入所有数据
                        </button>
                        <input type="file" id="import-all-data-input" accept=".json" style="display: none;" onchange="importAllData(this)">
                    </div>
                    
                    <div style="margin-top: 16px; padding: 12px; background: #e3f2fd; border-radius: 8px; border-left: 4px solid #2196F3;">
                        <p style="margin: 0; font-size: 13px; color: #1565C0;">
                            💡 <strong>提示：</strong>导出的数据包含所有角色、聊天记录、配置和记忆。导入时会完全替换当前所有数据。
                        </p>
                    </div>
                </div>
                
                <div style="background: #fff3cd; border-radius: 12px; padding: 20px; border-left: 4px solid #ffc107;">
                    <h3 style="margin: 0 0 10px 0; font-size: 16px; color: #856404;">⚠️ 注意事项</h3>
                    <ul style="margin: 0; padding-left: 20px; font-size: 14px; color: #856404; line-height: 1.8;">
                        <li>导入数据会<strong>完全替换</strong>当前所有数据</li>
                        <li>建议在导入前先导出备份当前数据</li>
                        <li>导入后页面会自动刷新</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- ==================== 聊天列表页面 ==================== -->
        <div id="chat-list-page" class="page page-with-nav">
            <header class="header">
                <button onclick="showPage('home-page')">
                    <svg width="10" height="18" viewBox="0 0 10 18" fill="none">
                        <path d="M9 1L1 9L9 17" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </button>
                <span class="header-title">微信</span>
                <button id="add-character-menu-btn" style="font-size: 26px;">+</button>
            </header>
            
            <div class="content" style="background-color: #fff;">
                <div style="background-color: #EDEDED; padding: 8px 12px; border-bottom: 1px solid #d9d9d9;">
                    <div style="background-color: #fff; border-radius: 6px; padding: 6px 12px; display: flex; align-items: center; gap: 8px;">
                        <svg width="18" height="18" viewBox="0 0 18 18" fill="none">
                            <circle cx="8" cy="8" r="6.5" stroke="#999" stroke-width="1.5"/>
                            <path d="M13 13L17 17" stroke="#999" stroke-width="1.5" stroke-linecap="round"/>
                        </svg>
                        <input type="text" placeholder="搜索" id="character-search-input" style="border: none; outline: none; flex: 1; font-size: 14px; background: transparent;">
                    </div>
                </div>
                
                <div id="characters-list-container"></div>
            </div>
            
            <!-- 底部导航栏 -->
            <div class="bottom-nav">
                <div class="nav-item active" data-page="chat-list">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"/>
                    </svg>
                    <span>微信</span>
                </div>
                <div class="nav-item" data-page="contacts">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
                        <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/>
                        <circle cx="9" cy="7" r="4"/>
                        <path d="M23 21v-2a4 4 0 0 0-3-3.87"/>
                        <path d="M16 3.13a4 4 0 0 1 0 7.75"/>
                    </svg>
                    <span>通讯录</span>
                </div>
                <div class="nav-item" data-page="discover">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
                        <circle cx="12" cy="12" r="10"/>
                        <polygon points="16.24 7.76 14.12 14.12 7.76 16.24 9.88 9.88 16.24 7.76" fill="currentColor"/>
                    </svg>
                    <span>发现</span>
                </div>
                <div class="nav-item" data-page="me">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
                        <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
                        <circle cx="12" cy="7" r="4"/>
                    </svg>
                    <span>我</span>
                </div>
            </div>
        </div>
        
        <!-- 通讯录页面 -->
        <div id="contacts-page" class="page page-with-nav">
            <header class="header">
                <button onclick="showPage('home-page')">
                    <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M15 18l-6-6 6-6"/>
                    </svg>
                </button>
                <span class="header-title">通讯录</span>
                <button style="font-size: 26px;">+</button>
            </header>
            
            <div class="content" style="background-color: #fff;">
                <div style="padding: 100px 20px; text-align: center; color: #999;">
                    <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="#ccc" stroke-width="1.5" style="margin: 0 auto 16px;">
                        <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/>
                        <circle cx="9" cy="7" r="4"/>
                        <path d="M23 21v-2a4 4 0 0 0-3-3.87"/>
                        <path d="M16 3.13a4 4 0 0 1 0 7.75"/>
                    </svg>
                    <div style="font-size: 16px; margin-bottom: 8px;">通讯录功能</div>
                    <div style="font-size: 14px;">敬请期待...</div>
                </div>
            </div>
            
            <!-- 底部导航栏 -->
            <div class="bottom-nav">
                <div class="nav-item" data-page="chat-list">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"/>
                    </svg>
                    <span>微信</span>
                </div>
                <div class="nav-item active" data-page="contacts">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
                        <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/>
                        <circle cx="9" cy="7" r="4"/>
                        <path d="M23 21v-2a4 4 0 0 0-3-3.87"/>
                        <path d="M16 3.13a4 4 0 0 1 0 7.75"/>
                    </svg>
                    <span>通讯录</span>
                </div>
                <div class="nav-item" data-page="discover">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
                        <circle cx="12" cy="12" r="10"/>
                        <polygon points="16.24 7.76 14.12 14.12 7.76 16.24 9.88 9.88 16.24 7.76" fill="currentColor"/>
                    </svg>
                    <span>发现</span>
                </div>
                <div class="nav-item" data-page="me">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
                        <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
                        <circle cx="12" cy="7" r="4"/>
                    </svg>
                    <span>我</span>
                </div>
            </div>
        </div>
        
        <!-- 发现页面 -->
        <div id="discover-page" class="page page-with-nav">
            <header class="header">
                <button onclick="showPage('home-page')">
                    <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M15 18l-6-6 6-6"/>
                    </svg>
                </button>
                <span class="header-title">发现</span>
                <span></span>
            </header>
            
            <div class="content" style="background-color: #fff;">
                <div style="padding: 100px 20px; text-align: center; color: #999;">
                    <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="#ccc" stroke-width="1.5" style="margin: 0 auto 16px;">
                        <circle cx="12" cy="12" r="10"/>
                        <polygon points="16.24 7.76 14.12 14.12 7.76 16.24 9.88 9.88 16.24 7.76" fill="#ccc"/>
                    </svg>
                    <div style="font-size: 16px; margin-bottom: 8px;">发现功能</div>
                    <div style="font-size: 14px;">敬请期待...</div>
                </div>
            </div>
            
            <!-- 底部导航栏 -->
            <div class="bottom-nav">
                <div class="nav-item" data-page="chat-list">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"/>
                    </svg>
                    <span>微信</span>
                </div>
                <div class="nav-item" data-page="contacts">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
                        <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/>
                        <circle cx="9" cy="7" r="4"/>
                        <path d="M23 21v-2a4 4 0 0 0-3-3.87"/>
                        <path d="M16 3.13a4 4 0 0 1 0 7.75"/>
                    </svg>
                    <span>通讯录</span>
                </div>
                <div class="nav-item active" data-page="discover">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
                        <circle cx="12" cy="12" r="10"/>
                        <polygon points="16.24 7.76 14.12 14.12 7.76 16.24 9.88 9.88 16.24 7.76" fill="currentColor"/>
                    </svg>
                    <span>发现</span>
                </div>
                <div class="nav-item" data-page="me">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
                        <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
                        <circle cx="12" cy="7" r="4"/>
                    </svg>
                    <span>我</span>
                </div>
            </div>
        </div>
        
        <!-- 我的页面 -->
        <div id="me-page" class="page page-with-nav">
            <header class="header">
                <button onclick="showPage('home-page')">
                    <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M15 18l-6-6 6-6"/>
                    </svg>
                </button>
                <span class="header-title">我</span>
                <span></span>
            </header>
            
            <div class="content" style="background-color: #EDEDED; overflow-y: auto;">
                <!-- 个人信息卡片 -->
                <div style="background: white; margin-bottom: 10px; padding: 20px 16px;">
                    <div style="display: flex; align-items: center; gap: 16px;">
                        <div id="me-page-avatar" style="width: 64px; height: 64px; border-radius: 6px; background: #07c160; display: flex; align-items: center; justify-content: center; color: white; font-size: 24px; font-weight: bold;">我</div>
                        <div style="flex: 1;">
                            <div id="me-page-nickname" style="font-size: 20px; font-weight: 500; color: #333; margin-bottom: 4px;">用户昵称</div>
                            <div style="font-size: 14px; color: #999;">微信号: linglow_user</div>
                        </div>
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#999" stroke-width="2">
                            <path d="M9 18l6-6-6-6"/>
                        </svg>
                    </div>
                </div>
                
                <!-- 功能列表 -->
                <div style="background: white; margin-bottom: 10px;">
                    <!-- 收藏 -->
                    <div onclick="showFavoritesPage()" style="display: flex; align-items: center; padding: 14px 16px; border-bottom: 1px solid #EDEDED; cursor: pointer;">
                        <div style="width: 40px; height: 40px; background: #ffc107; border-radius: 6px; display: flex; align-items: center; justify-content: center; margin-right: 12px;">
                            <span style="font-size: 22px;">⭐</span>
                        </div>
                        <div style="flex: 1; font-size: 16px; color: #333;">收藏</div>
                        <div style="display: flex; align-items: center; gap: 4px;">
                            <span id="favorites-count" style="font-size: 14px; color: #999;">0</span>
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#999" stroke-width="2">
                                <path d="M9 18l6-6-6-6"/>
                            </svg>
                        </div>
                    </div>
                    
                    <!-- 相册（占位） -->
                    <div style="display: flex; align-items: center; padding: 14px 16px; border-bottom: 1px solid #EDEDED; opacity: 0.5;">
                        <div style="width: 40px; height: 40px; background: #5a9fe2; border-radius: 6px; display: flex; align-items: center; justify-content: center; margin-right: 12px;">
                            <span style="font-size: 22px;">📷</span>
                        </div>
                        <div style="flex: 1; font-size: 16px; color: #333;">相册</div>
                        <div style="display: flex; align-items: center; gap: 4px;">
                            <span style="font-size: 12px; color: #999;">开发中</span>
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#999" stroke-width="2">
                                <path d="M9 18l6-6-6-6"/>
                            </svg>
                        </div>
                    </div>
                </div>
                
                <!-- 其他功能 -->
                <div style="background: white; margin-bottom: 10px;">
                    <!-- 钱包入口 -->
                    <div onclick="openWalletPage()" style="display: flex; align-items: center; padding: 14px 16px; border-bottom: 1px solid #EDEDED; cursor: pointer;">
                        <div style="width: 40px; height: 40px; background: #1aad19; border-radius: 6px; display: flex; align-items: center; justify-content: center; margin-right: 12px;">
                            <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <rect x="2" y="5" width="20" height="14" rx="2"/>
                                <path d="M16 12h.01"/>
                                <path d="M2 10h20"/>
                            </svg>
                        </div>
                        <div style="flex: 1; font-size: 16px; color: #333;">钱包</div>
                        <div style="display: flex; align-items: center; gap: 6px;">
                            <span id="me-wallet-balance" style="font-size: 14px; color: #07c160; font-weight: 500;"></span>
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#999" stroke-width="2">
                                <path d="M9 18l6-6-6-6"/>
                            </svg>
                        </div>
                    </div>

                    <div style="display: flex; align-items: center; padding: 14px 16px; border-bottom: 1px solid #EDEDED; opacity: 0.5;">
                        <div style="width: 40px; height: 40px; background: #ff9800; border-radius: 6px; display: flex; align-items: center; justify-content: center; margin-right: 12px;">
                            <span style="font-size: 22px;">💳</span>
                        </div>
                        <div style="flex: 1; font-size: 16px; color: #333;">卡包</div>
                        <div style="display: flex; align-items: center; gap: 4px;">
                            <span style="font-size: 12px; color: #999;">开发中</span>
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#999" stroke-width="2">
                                <path d="M9 18l6-6-6-6"/>
                            </svg>
                        </div>
                    </div>
                    
                    <div style="display: flex; align-items: center; padding: 14px 16px; opacity: 0.5;">
                        <div style="width: 40px; height: 40px; background: #4caf50; border-radius: 6px; display: flex; align-items: center; justify-content: center; margin-right: 12px;">
                            <span style="font-size: 22px;">😊</span>
                        </div>
                        <div style="flex: 1; font-size: 16px; color: #333;">表情</div>
                        <div style="display: flex; align-items: center; gap: 4px;">
                            <span style="font-size: 12px; color: #999;">开发中</span>
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#999" stroke-width="2">
                                <path d="M9 18l6-6-6-6"/>
                            </svg>
                        </div>
                    </div>
                </div>
                
                <!-- 设置 -->
                <div style="background: white;">
                    <div onclick="openSettings()" style="display: flex; align-items: center; padding: 14px 16px; cursor: pointer;">
                        <div style="width: 40px; height: 40px; background: #607d8b; border-radius: 6px; display: flex; align-items: center; justify-content: center; margin-right: 12px;">
                            <span style="font-size: 22px;">⚙️</span>
                        </div>
                        <div style="flex: 1; font-size: 16px; color: #333;">设置</div>
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#999" stroke-width="2">
                            <path d="M9 18l6-6-6-6"/>
                        </svg>
                    </div>
                </div>
            </div>
            
            <!-- 底部导航栏 -->
            <div class="bottom-nav">
                <div class="nav-item" data-page="chat-list">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"/>
                    </svg>
                    <span>微信</span>
                </div>
                <div class="nav-item" data-page="contacts">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
                        <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/>
                        <circle cx="9" cy="7" r="4"/>
                        <path d="M23 21v-2a4 4 0 0 0-3-3.87"/>
                        <path d="M16 3.13a4 4 0 0 1 0 7.75"/>
                    </svg>
                    <span>通讯录</span>
                </div>
                <div class="nav-item" data-page="discover">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
                        <circle cx="12" cy="12" r="10"/>
                        <polygon points="16.24 7.76 14.12 14.12 7.76 16.24 9.88 9.88 16.24 7.76" fill="currentColor"/>
                    </svg>
                    <span>发现</span>
                </div>
                <div class="nav-item active" data-page="me">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
                        <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
                        <circle cx="12" cy="7" r="4"/>
                    </svg>
                    <span>我</span>
                </div>
            </div>
        </div>

        <!-- ===== 钱包页面 ===== -->
        <div id="wallet-page" class="page">
            <header class="header">
                <button onclick="showPage('me-page')">
                    <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M15 18l-6-6 6-6"/>
                    </svg>
                </button>
                <span class="header-title">钱包</span>
                <span></span>
            </header>
            <div class="content" style="background:#EDEDED;overflow-y:auto;">
                <!-- 余额卡片 -->
                <div style="background:linear-gradient(135deg,#07c160 0%,#06ae56 100%);margin:0;padding:32px 24px 28px;color:#fff;">
                    <div style="font-size:13px;opacity:0.85;margin-bottom:8px;">零钱余额</div>
                    <div style="display:flex;align-items:baseline;gap:6px;">
                        <span style="font-size:15px;font-weight:400;">¥</span>
                        <span id="wallet-balance-display" style="font-size:42px;font-weight:600;letter-spacing:-1px;">0.00</span>
                    </div>
                </div>

                <!-- 快捷操作 -->
                <div style="background:#fff;margin-bottom:10px;padding:20px 0;">
                    <div style="display:flex;justify-content:space-around;">
                        <div onclick="window._transferOriginPage='wallet-page';showPage('transfer-page')" style="display:flex;flex-direction:column;align-items:center;gap:8px;cursor:pointer;">
                            <div style="width:52px;height:52px;background:#07c160;border-radius:50%;display:flex;align-items:center;justify-content:center;">
                                <svg width="26" height="26" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round">
                                    <path d="M12 5v14M5 12l7-7 7 7"/>
                                </svg>
                            </div>
                            <span style="font-size:13px;color:#333;">转账</span>
                        </div>
                        <div style="display:flex;flex-direction:column;align-items:center;gap:8px;opacity:0.4;">
                            <div style="width:52px;height:52px;background:#ff9800;border-radius:50%;display:flex;align-items:center;justify-content:center;">
                                <svg width="26" height="26" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round">
                                    <rect x="3" y="8" width="18" height="13" rx="2"/>
                                    <path d="M8 8V6a4 4 0 0 1 8 0v2"/>
                                </svg>
                            </div>
                            <span style="font-size:13px;color:#333;">红包</span>
                        </div>
                        <div style="display:flex;flex-direction:column;align-items:center;gap:8px;opacity:0.4;">
                            <div style="width:52px;height:52px;background:#2196f3;border-radius:50%;display:flex;align-items:center;justify-content:center;">
                                <svg width="26" height="26" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round">
                                    <circle cx="12" cy="12" r="10"/>
                                    <path d="M12 8v4l3 3"/>
                                </svg>
                            </div>
                            <span style="font-size:13px;color:#333;">账单</span>
                        </div>
                    </div>
                </div>

                <!-- 交易记录 -->
                <div style="background:#fff;">
                    <div style="padding:14px 16px;font-size:14px;font-weight:600;color:#333;border-bottom:1px solid #EDEDED;">交易记录</div>
                    <div id="wallet-tx-list" style="min-height:80px;">
                        <div style="text-align:center;color:#ccc;font-size:14px;padding:40px 0;">暂无交易记录</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ===== 转账页面（用户→角色）===== -->
        <div id="transfer-page" class="page">
            <header class="header">
                <button onclick="showPage(window._transferOriginPage || 'wallet-page')">
                    <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M15 18l-6-6 6-6"/>
                    </svg>
                </button>
                <span class="header-title">转账</span>
                <span></span>
            </header>
            <div class="content" style="background:#EDEDED;overflow-y:auto;">
                <div style="background:#fff;margin-bottom:10px;padding:24px 20px;">
                    <!-- 收款方 -->
                    <div style="display:flex;align-items:center;gap:14px;margin-bottom:28px;">
                        <div id="transfer-avatar" style="width:52px;height:52px;border-radius:6px;background:linear-gradient(135deg,#667eea,#764ba2);display:flex;align-items:center;justify-content:center;font-size:22px;color:#fff;flex-shrink:0;overflow:hidden;"></div>
                        <div>
                            <div id="transfer-name" style="font-size:17px;font-weight:500;color:#333;margin-bottom:2px;">角色昵称</div>
                            <div style="font-size:13px;color:#999;">收款方</div>
                        </div>
                    </div>
                    <!-- 金额输入 -->
                    <div style="border-bottom:2px solid #07c160;padding-bottom:12px;margin-bottom:16px;">
                        <div style="display:flex;align-items:center;gap:8px;">
                            <span style="font-size:28px;color:#333;font-weight:400;">¥</span>
                            <input id="transfer-amount-input" type="number" min="0" step="0.01" placeholder="0.00"
                                style="flex:1;border:none;outline:none;font-size:36px;font-weight:500;color:#333;background:transparent;width:0;">
                        </div>
                    </div>
                    <!-- 当前余额提示 -->
                    <div style="font-size:13px;color:#999;margin-bottom:20px;">当前余额：¥<span id="transfer-my-balance">0.00</span></div>
                    <!-- 备注 -->
                    <input id="transfer-note-input" type="text" placeholder="添加备注（选填）" maxlength="30"
                        style="width:100%;box-sizing:border-box;padding:10px 0;border:none;border-bottom:1px solid #EDEDED;outline:none;font-size:15px;color:#333;background:transparent;margin-bottom:8px;">
                </div>
                <div style="padding:0 20px;">
                    <button onclick="confirmTransferToChar()" style="width:100%;padding:14px;background:#07c160;color:#fff;border:none;border-radius:6px;font-size:17px;font-weight:500;cursor:pointer;">转账</button>
                </div>
            </div>
        </div>

        <!-- ===== 转账成功全屏遮罩 ===== -->
        <div id="transfer-success-overlay" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.55);z-index:99999;align-items:center;justify-content:center;">
            <div style="background:#fff;border-radius:16px;width:280px;overflow:hidden;box-shadow:0 8px 32px rgba(0,0,0,0.2);">
                <div style="background:#07c160;padding:28px 20px;text-align:center;">
                    <div style="width:56px;height:56px;border-radius:50%;background:rgba(255,255,255,0.25);display:flex;align-items:center;justify-content:center;margin:0 auto 12px;">
                        <svg width="30" height="30" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="20 6 9 17 4 12"/>
                        </svg>
                    </div>
                    <div style="color:#fff;font-size:18px;font-weight:600;">转账成功</div>
                    <div id="ts-amount" style="color:rgba(255,255,255,0.9);font-size:14px;margin-top:6px;"></div>
                </div>
                <div style="padding:20px;text-align:center;">
                    <div id="ts-detail" style="font-size:13px;color:#999;margin-bottom:20px;"></div>
                    <button onclick="document.getElementById('transfer-success-overlay').style.display='none';showPage('wallet-page');"
                        style="width:100%;padding:12px;background:#07c160;color:#fff;border:none;border-radius:6px;font-size:16px;cursor:pointer;">完成</button>
                </div>
            </div>
        </div>

        <!-- ===== 角色→用户：收款通知弹窗 ===== -->
        <div id="receive-money-overlay" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.55);z-index:99999;align-items:center;justify-content:center;">
            <div style="background:#fff;border-radius:16px;width:280px;overflow:hidden;box-shadow:0 8px 32px rgba(0,0,0,0.2);">
                <div style="background:#07c160;padding:28px 20px;text-align:center;">
                    <div style="width:56px;height:56px;border-radius:50%;background:rgba(255,255,255,0.25);display:flex;align-items:center;justify-content:center;margin:0 auto 12px;">
                        <svg width="30" height="30" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M12 19V5M5 12l7 7 7-7"/>
                        </svg>
                    </div>
                    <div style="color:#fff;font-size:18px;font-weight:600;">收到转账</div>
                    <div id="rm-amount" style="color:rgba(255,255,255,0.9);font-size:28px;font-weight:600;margin-top:6px;"></div>
                </div>
                <div style="padding:20px;text-align:center;">
                    <div id="rm-from" style="font-size:14px;color:#666;margin-bottom:4px;"></div>
                    <div id="rm-note" style="font-size:13px;color:#999;margin-bottom:20px;"></div>
                    <button onclick="document.getElementById('receive-money-overlay').style.display='none';"
                        style="width:100%;padding:12px;background:#07c160;color:#fff;border:none;border-radius:6px;font-size:16px;cursor:pointer;">收下</button>
                </div>
            </div>
        </div>

        <!-- ===== 聊天加号菜单面板 ===== -->
        <div id="plus-menu-panel" style="display:none;position:fixed;bottom:0;left:0;right:0;background:#f7f7f7;border-top:1px solid #ddd;z-index:2000;padding:20px 16px 36px;">
            <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:16px;">
                <!-- 转账 -->
                <div onclick="openTransferFromChat()" style="display:flex;flex-direction:column;align-items:center;gap:8px;cursor:pointer;">
                    <div style="width:56px;height:56px;background:linear-gradient(135deg,#f5a11c,#f0920a);border-radius:12px;display:flex;align-items:center;justify-content:center;">
                        <svg width="30" height="30" viewBox="0 0 30 30" fill="none">
                            <circle cx="15" cy="15" r="12" stroke="white" stroke-width="2"/>
                            <path d="M24 11H4M24 11l-5-5M24 11l-5 5" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            <path d="M6 19H26M6 19l5-5M6 19l5 5" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                    </div>
                    <span style="font-size:12px;color:#333;">转账</span>
                </div>
                <!-- 收款 -->
                <div onclick="openCollectFromChat()" style="display:flex;flex-direction:column;align-items:center;gap:8px;cursor:pointer;">
                    <div style="width:56px;height:56px;background:linear-gradient(135deg,#07c160,#06ad56);border-radius:12px;display:flex;align-items:center;justify-content:center;">
                        <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M12 2v20M2 12h20"/>
                            <path d="M17 7l-5 5-5-5"/>
                        </svg>
                    </div>
                    <span style="font-size:12px;color:#333;">收款</span>
                </div>
                <!-- 红包（占位） -->
                <div style="display:flex;flex-direction:column;align-items:center;gap:8px;opacity:0.4;">
                    <div style="width:56px;height:56px;background:#fff;border-radius:12px;display:flex;align-items:center;justify-content:center;box-shadow:0 1px 4px rgba(0,0,0,0.1);">
                        <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="#e53935" stroke-width="2" stroke-linecap="round">
                            <rect x="3" y="8" width="18" height="13" rx="2"/>
                            <path d="M8 8V6a4 4 0 0 1 8 0v2"/>
                        </svg>
                    </div>
                    <span style="font-size:12px;color:#333;">红包</span>
                </div>
                <!-- 图片（占位） -->
                <div style="display:flex;flex-direction:column;align-items:center;gap:8px;opacity:0.4;">
                    <div style="width:56px;height:56px;background:#fff;border-radius:12px;display:flex;align-items:center;justify-content:center;box-shadow:0 1px 4px rgba(0,0,0,0.1);">
                        <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="#2196f3" stroke-width="2" stroke-linecap="round">
                            <rect x="3" y="3" width="18" height="18" rx="2"/>
                            <circle cx="8.5" cy="8.5" r="1.5" fill="#2196f3"/>
                            <polyline points="21 15 16 10 5 21"/>
                        </svg>
                    </div>
                    <span style="font-size:12px;color:#333;">图片</span>
                </div>
            </div>
        </div>

        <!-- ===== 转账详情页（点击气泡后进入，可收款或退回）===== -->
        <div id="transfer-detail-page" class="page">
            <header class="header">
                <button onclick="showPage('chat-page')">
                    <svg width="10" height="18" viewBox="0 0 10 18" fill="none">
                        <path d="M9 1L1 9L9 17" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </button>
                <span class="header-title">转账详情</span>
                <span></span>
            </header>
            <div class="content" style="background:#EDEDED;overflow-y:auto;">
                <!-- 橙色大卡片 -->
                <div style="background:linear-gradient(180deg,#f5a11c,#f0920a);padding:36px 24px 32px;">
                    <div style="display:flex;align-items:center;gap:16px;">
                        <div id="td-avatar" style="width:54px;height:54px;border-radius:50%;background:rgba(255,255,255,0.25);display:flex;align-items:center;justify-content:center;flex-shrink:0;font-size:24px;overflow:hidden;"></div>
                        <div>
                            <div id="td-label" style="font-size:15px;color:rgba(255,255,255,0.9);margin-bottom:6px;"></div>
                            <div id="td-amount" style="font-size:38px;font-weight:700;color:#fff;letter-spacing:1px;line-height:1;">¥ 0.00</div>
                        </div>
                    </div>
                    <div id="td-note" style="margin-top:18px;font-size:13px;color:rgba(255,255,255,0.85);display:none;">
                        <span style="opacity:0.7;">备注：</span><span id="td-note-text"></span>
                    </div>
                </div>
                <!-- 详情行 -->
                <div style="background:#fff;margin-top:10px;">
                    <div style="padding:15px 20px;display:flex;justify-content:space-between;align-items:center;border-bottom:1px solid #f0f0f0;">
                        <span style="color:#999;font-size:14px;">转账方</span>
                        <span id="td-from" style="color:#333;font-size:14px;"></span>
                    </div>
                    <div style="padding:15px 20px;display:flex;justify-content:space-between;align-items:center;border-bottom:1px solid #f0f0f0;">
                        <span style="color:#999;font-size:14px;">状态</span>
                        <span id="td-status" style="font-size:14px;"></span>
                    </div>
                    <div style="padding:15px 20px;display:flex;justify-content:space-between;align-items:center;">
                        <span style="color:#999;font-size:14px;">转账时间</span>
                        <span id="td-time" style="color:#333;font-size:14px;"></span>
                    </div>
                </div>
                <!-- 收款按钮区（仅对方转给我时显示） -->
                <div id="td-accept-area" style="display:none;padding:30px 20px 16px;">
                    <button onclick="doTransferAccept()" style="width:100%;padding:15px;background:#f5a11c;border:none;border-radius:6px;font-size:18px;font-weight:600;color:#fff;cursor:pointer;letter-spacing:1px;">收款</button>
                    <div style="text-align:center;margin-top:16px;">
                        <span onclick="doTransferRefund()" style="font-size:13px;color:#999;cursor:pointer;text-decoration:underline;text-underline-offset:3px;">退回</span>
                    </div>
                </div>
                <!-- 我发出的，只读，无操作 -->
                <div id="td-readonly-area" style="display:none;padding:24px 20px;text-align:center;color:#bbb;font-size:13px;">
                    等待对方操作
                </div>
                <div style="text-align:center;padding:16px 0 30px;font-size:12px;color:#ccc;">微信转账</div>
            </div>
        </div>

        <!-- ===== 收款页面（角色向用户要钱）===== -->
        <div id="collect-page" class="page">
            <header class="header">
                <button onclick="showPage(window._collectOriginPage||'chat-page')">
                    <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                </button>
                <span class="header-title">收款</span>
                <span></span>
            </header>
            <div class="content" style="background:#EDEDED;overflow-y:auto;">
                <div style="background:#fff;margin-bottom:10px;padding:24px 20px;">
                    <div style="display:flex;align-items:center;gap:14px;margin-bottom:28px;">
                        <div id="collect-avatar" style="width:52px;height:52px;border-radius:6px;background:linear-gradient(135deg,#667eea,#764ba2);display:flex;align-items:center;justify-content:center;font-size:22px;color:#fff;flex-shrink:0;overflow:hidden;"></div>
                        <div>
                            <div id="collect-name" style="font-size:17px;font-weight:500;color:#333;margin-bottom:2px;">角色昵称</div>
                            <div style="font-size:13px;color:#999;">向对方收款</div>
                        </div>
                    </div>
                    <div style="border-bottom:2px solid #07c160;padding-bottom:12px;margin-bottom:16px;">
                        <div style="display:flex;align-items:center;gap:8px;">
                            <span style="font-size:28px;color:#333;font-weight:400;">¥</span>
                            <input id="collect-amount-input" type="number" min="0" step="0.01" placeholder="0.00"
                                style="flex:1;border:none;outline:none;font-size:36px;font-weight:500;color:#333;background:transparent;width:0;">
                        </div>
                    </div>
                    <input id="collect-note-input" type="text" placeholder="添加备注（选填）" maxlength="30"
                        style="width:100%;box-sizing:border-box;padding:10px 0;border:none;border-bottom:1px solid #EDEDED;outline:none;font-size:15px;color:#333;background:transparent;margin-bottom:8px;">
                </div>
                <div style="padding:0 20px;">
                    <button onclick="confirmCollectFromChar()" style="width:100%;padding:14px;background:#07c160;color:#fff;border:none;border-radius:6px;font-size:17px;font-weight:500;cursor:pointer;">发起收款</button>
                </div>
            </div>
        </div>

        <!-- ===== 世界书条目编辑弹窗 ===== -->
        <div id="wb-edit-modal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.5);z-index:99990;align-items:flex-end;justify-content:center;">
            <div style="background:#fff;width:100%;max-height:88vh;border-radius:16px 16px 0 0;display:flex;flex-direction:column;overflow:hidden;">
                <div style="display:flex;align-items:center;justify-content:space-between;padding:14px 16px;border-bottom:1px solid #eee;flex-shrink:0;">
                    <button onclick="wbCloseModal()" style="background:none;border:none;font-size:15px;color:#999;cursor:pointer;padding:0;">取消</button>
                    <span style="font-size:16px;font-weight:600;color:#333;" id="wb-modal-title">新建条目</span>
                    <button onclick="wbSaveEntry()" style="background:none;border:none;font-size:15px;color:#07c160;font-weight:600;cursor:pointer;padding:0;">保存</button>
                </div>
                <div style="overflow-y:auto;padding:16px;flex:1;">
                    <input type="hidden" id="wb-edit-id">
                    <div style="margin-bottom:14px;">
                        <label style="font-size:13px;color:#555;display:block;margin-bottom:6px;">条目名称（备注用，不影响触发）</label>
                        <input id="wb-edit-name" type="text" placeholder="例如：魔法系统" maxlength="40"
                            style="width:100%;box-sizing:border-box;padding:9px 10px;border:1px solid #ddd;border-radius:6px;font-size:14px;">
                    </div>
                    <div style="margin-bottom:14px;">
                        <label style="font-size:13px;color:#555;display:block;margin-bottom:6px;">触发关键词 <span style="color:#999;font-size:12px;">（用逗号分隔，任意一个命中即触发）</span></label>
                        <input id="wb-edit-keys" type="text" placeholder="例如：魔法,法术,咒语"
                            style="width:100%;box-sizing:border-box;padding:9px 10px;border:1px solid #ddd;border-radius:6px;font-size:14px;">
                    </div>
                    <div style="margin-bottom:14px;">
                        <label style="font-size:13px;color:#555;display:block;margin-bottom:6px;">注入内容 <span style="color:#999;font-size:12px;">（命中时添加到系统提示末尾）</span></label>
                        <textarea id="wb-edit-content" rows="6" placeholder="在这里描述这个关键词对应的世界观设定..."
                            style="width:100%;box-sizing:border-box;padding:9px 10px;border:1px solid #ddd;border-radius:6px;font-size:14px;resize:vertical;"></textarea>
                    </div>
                    <div style="display:flex;align-items:center;gap:10px;margin-bottom:6px;">
                        <label style="font-size:13px;color:#555;">启用此条目</label>
                        <label style="position:relative;display:inline-block;width:44px;height:24px;">
                            <input type="checkbox" id="wb-edit-enabled" checked style="opacity:0;width:0;height:0;">
                            <span id="wb-edit-enabled-slider" style="position:absolute;cursor:pointer;inset:0;background:#1AAD19;border-radius:24px;transition:.3s;">
                                <span style="position:absolute;left:23px;top:3px;width:18px;height:18px;background:#fff;border-radius:50%;transition:.3s;display:block;" id="wb-edit-enabled-knob"></span>
                            </span>
                        </label>
                    </div>
                </div>
            </div>
        </div>

        <!-- ===== 状态字段编辑弹窗 ===== -->
        <div id="status-edit-modal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.45);z-index:99995;align-items:center;justify-content:center;">
            <div style="background:#fff;border-radius:14px;width:280px;overflow:hidden;box-shadow:0 8px 32px rgba(0,0,0,0.18);">
                <div style="padding:18px 18px 10px;">
                    <div id="status-edit-label" style="font-size:13px;color:#999;margin-bottom:8px;">编辑</div>
                    <input id="status-edit-input" type="text" style="width:100%;box-sizing:border-box;padding:8px 10px;border:1px solid #ddd;border-radius:6px;font-size:15px;outline:none;">
                    <div id="status-edit-hint" style="font-size:11px;color:#bbb;margin-top:6px;"></div>
                </div>
                <div style="display:flex;border-top:1px solid #eee;">
                    <button onclick="statusEditCancel()" style="flex:1;padding:13px;background:none;border:none;border-right:1px solid #eee;font-size:16px;color:#999;cursor:pointer;">取消</button>
                    <button onclick="statusEditConfirm()" style="flex:1;padding:13px;background:none;border:none;font-size:16px;color:#07c160;font-weight:600;cursor:pointer;">确定</button>
                </div>
            </div>
        </div>

        <!-- 收藏页面 -->
        <div id="favorites-page" class="page">
            <header class="header">
                <button onclick="showPage('me-page')">
                    <svg width="10" height="18" viewBox="0 0 10 18" fill="none">
                        <path d="M9 1L1 9L9 17" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </button>
                <span class="header-title">收藏</span>
                <button onclick="clearAllFavorites()" style="font-size: 14px; color: #ff3b30;">清空</button>
            </header>
            
            <div class="content" style="background-color: #EDEDED; overflow-y: auto;">
                <div id="favorites-container"></div>
                
                <!-- 空状态 -->
                <div id="favorites-empty" style="display: none; padding: 100px 20px; text-align: center; color: #999;">
                    <div style="font-size: 48px; margin-bottom: 16px;">⭐</div>
                    <div style="font-size: 16px; margin-bottom: 8px;">暂无收藏</div>
                    <div style="font-size: 14px;">长按消息可添加到收藏</div>
                </div>
            </div>
        </div>
        
        <!-- 转发选择页面 -->
        <div id="forward-select-page" class="page">
            <header class="header">
                <button onclick="cancelForward()">
                    <svg width="10" height="18" viewBox="0 0 10 18" fill="none">
                        <path d="M9 1L1 9L9 17" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </button>
                <span class="header-title">选择聊天</span>
                <span></span>
            </header>

            <!-- 转发方式选择（多条时显示） -->
            <div id="forward-type-bar" style="display:none;background:#fff;border-bottom:1px solid #eee;padding:10px 16px;">
                <div style="font-size:12px;color:#999;margin-bottom:8px;">转发方式</div>
                <div style="display:flex;gap:10px;">
                    <div id="fwd-type-merged" onclick="setForwardType('merged')"
                        style="flex:1;padding:10px;border-radius:8px;border:2px solid #07c160;background:#f0fff4;text-align:center;cursor:pointer;">
                        <div style="font-size:13px;font-weight:600;color:#07c160;">合并转发</div>
                        <div style="font-size:11px;color:#999;margin-top:2px;">生成聊天记录卡片</div>
                    </div>
                    <div id="fwd-type-separate" onclick="setForwardType('separate')"
                        style="flex:1;padding:10px;border-radius:8px;border:2px solid #ddd;background:#fff;text-align:center;cursor:pointer;">
                        <div style="font-size:13px;font-weight:600;color:#333;">逐条转发</div>
                        <div style="font-size:11px;color:#999;margin-top:2px;">每条单独发送</div>
                    </div>
                </div>
            </div>
            
            <div class="content" style="background-color: #EDEDED; overflow-y: auto;">
                <!-- 搜索框 -->
                <div style="background-color: #EDEDED; padding: 8px 12px; border-bottom: 1px solid #d9d9d9;">
                    <div style="background-color: #fff; border-radius: 6px; padding: 6px 12px; display: flex; align-items: center; gap: 8px;">
                        <svg width="18" height="18" viewBox="0 0 18 18" fill="none">
                            <circle cx="8" cy="8" r="6.5" stroke="#999" stroke-width="1.5"/>
                            <path d="M13 13L17 17" stroke="#999" stroke-width="1.5" stroke-linecap="round"/>
                        </svg>
                        <input type="text" placeholder="搜索" id="forward-search-input" style="border: none; outline: none; flex: 1; font-size: 14px; background: transparent;">
                    </div>
                </div>
                
                <div id="forward-characters-list"></div>
                
                <!-- 空状态 -->
                <div id="forward-empty" style="display: none; padding: 100px 20px; text-align: center; color: #999;">
                    <div style="font-size: 48px; margin-bottom: 16px;">💬</div>
                    <div style="font-size: 16px; margin-bottom: 8px;">暂无可转发的对象</div>
                    <div style="font-size: 14px;">请先创建角色</div>
                </div>
            </div>
        </div>

        <div id="chat-page" class="page">
            <header class="header">
                <button id="back-to-chat-list-btn">
                    <svg width="10" height="18" viewBox="0 0 10 18" fill="none">
                        <path d="M9 1L1 9L9 17" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </button>
                <span class="header-title" id="chat-name" onclick="statusToggleDrawer()" style="cursor:pointer;user-select:none;">AI 聊天对象</span>
                <button onclick="openSettings()">
                    <svg width="20" height="4" viewBox="0 0 20 4" fill="currentColor">
                        <circle cx="2" cy="2" r="2"/>
                        <circle cx="10" cy="2" r="2"/>
                        <circle cx="18" cy="2" r="2"/>
                    </svg>
                </button>
            </header>

            <!-- 状态抽屉（粘在 header 下方，默认隐藏） -->
            <div id="status-drawer" style="background:#fff;border-bottom:1px solid #e8e8e8;overflow:hidden;flex-shrink:0;transition:max-height .3s ease;max-height:0;">
                <div style="padding:10px 16px 12px;">
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:0;">
                        <!-- 位置 -->
                        <div onclick="statusEditField('location')" style="padding:6px 8px 6px 0;cursor:pointer;border-bottom:1px solid #f5f5f5;">
                            <div style="font-size:10px;color:#aaa;margin-bottom:2px;">所在位置</div>
                            <div id="sd-location" style="font-size:13px;color:#333;min-height:20px;line-height:20px;">—</div>
                        </div>
                        <!-- 心情 -->
                        <div onclick="statusEditField('mood')" style="padding:6px 0 6px 8px;cursor:pointer;border-bottom:1px solid #f5f5f5;border-left:1px solid #f5f5f5;">
                            <div style="font-size:10px;color:#aaa;margin-bottom:2px;">心情</div>
                            <div id="sd-mood" style="font-size:13px;color:#333;min-height:20px;line-height:20px;">—</div>
                        </div>
                        <!-- 好感度 -->
                        <div onclick="statusEditField('affection')" style="padding:6px 8px 6px 0;cursor:pointer;border-bottom:1px solid #f5f5f5;">
                            <div style="font-size:10px;color:#aaa;margin-bottom:2px;">好感度</div>
                            <div id="sd-affection" style="font-size:13px;color:#333;min-height:20px;line-height:20px;">—</div>
                        </div>
                        <!-- 穿着 -->
                        <div onclick="statusEditField('outfit')" style="padding:6px 0 6px 8px;cursor:pointer;border-bottom:1px solid #f5f5f5;border-left:1px solid #f5f5f5;">
                            <div style="font-size:10px;color:#aaa;margin-bottom:2px;">穿着</div>
                            <div id="sd-outfit" style="font-size:13px;color:#333;min-height:20px;line-height:20px;">—</div>
                        </div>
                        <!-- 当前在做 -->
                        <div onclick="statusEditField('activity')" style="grid-column:1/-1;padding:6px 0;cursor:pointer;">
                            <div style="font-size:10px;color:#aaa;margin-bottom:2px;">当前在做</div>
                            <div id="sd-activity" style="font-size:13px;color:#333;min-height:20px;line-height:20px;">—</div>
                        </div>
                    </div>
                    <div style="font-size:10px;color:#ccc;text-align:right;margin-top:4px;">点击可手动修改</div>
                </div>
            </div>
            
            <div class="content">
                <div id="chat-container">
                    <div class="message ai">
                        <div class="bubble">你好！有什么想跟我聊聊的吗？我很期待。</div>
                    </div>
                </div>
            </div>

            <div class="chat-input-area" id="chat-input-area">
                <button class="input-tool-btn" id="voice-btn" title="语音输入（开发中）">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
                        <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                        <line x1="12" y1="19" x2="12" y2="23"></line>
                        <line x1="8" y1="23" x2="16" y2="23"></line>
                    </svg>
                </button>
                <textarea id="user-input" placeholder="输入消息..." rows="1"></textarea>
                <button class="input-tool-btn" id="emoji-btn" title="表情包（开发中）">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"></circle>
                        <path d="M8 14s1.5 2 4 2 4-2 4-2"></path>
                        <line x1="9" y1="9" x2="9.01" y2="9"></line>
                        <line x1="15" y1="9" x2="15.01" y2="9"></line>
                    </svg>
                </button>
                <button class="input-tool-btn" id="plus-btn" title="更多功能（开发中）">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"></circle>
                        <line x1="12" y1="8" x2="12" y2="16"></line>
                        <line x1="8" y1="12" x2="16" y2="12"></line>
                    </svg>
                </button>
            </div>
            
            <!-- 多选模式顶部工具栏 -->
            <div class="multi-select-header" id="multi-select-header">
                <button class="multi-select-cancel-btn" onclick="exitMultiSelectMode()">取消</button>
                <span class="multi-select-count" id="multi-select-count">已选择0条</span>
                <span style="width: 40px;"></span>
            </div>
            
            <!-- 多选模式搜索框 -->
            <div class="multi-select-search" id="multi-select-search">
                <input type="text" class="multi-select-search-input" placeholder="搜索">
            </div>
            
            <!-- Select按钮 -->
            <div class="multi-select-btn-container" id="multi-select-btn-container">
                <button class="multi-select-select-btn" onclick="showToast('功能开发中')">
                    <span id="select-btn-icon" style="font-size: 18px; font-weight: 900; line-height: 1;">▼</span>
                    <span id="select-btn-text">选择</span>
                </button>
            </div>
            
            <!-- 多选模式底部工具栏 -->
            <div class="multi-select-toolbar" id="multi-select-toolbar">
                <button class="multi-select-toolbar-btn" onclick="confirmForwardType()">
                    <div class="multi-select-toolbar-icon">
                        <svg width="26" height="26" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                            <polyline points="14 2 14 8 20 8"></polyline>
                            <polyline points="12 18 12 12"></polyline>
                            <polyline points="9 15 12 12 15 15"></polyline>
                        </svg>
                    </div>
                    <div class="multi-select-toolbar-text">转发</div>
                </button>
                <button class="multi-select-toolbar-btn" onclick="favoriteSelectedMessages()">
                    <div class="multi-select-toolbar-icon">
                        <svg width="26" height="26" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                            <path d="M12 2L15.09 8.26L22 9.27L17 14.14L18.18 21.02L12 17.77L5.82 21.02L7 14.14L2 9.27L8.91 8.26L12 2Z"></path>
                        </svg>
                    </div>
                    <div class="multi-select-toolbar-text">收藏</div>
                </button>
                <button class="multi-select-toolbar-btn delete" onclick="deleteSelectedMessages()">
                    <div class="multi-select-toolbar-icon">
                        <svg width="26" height="26" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                            <polyline points="3 6 5 6 21 6"></polyline>
                            <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                        </svg>
                    </div>
                    <div class="multi-select-toolbar-text">删除</div>
                </button>
                <button class="multi-select-toolbar-btn" onclick="showMoreMultiSelectOptions()">
                    <div class="multi-select-toolbar-icon" style="font-size: 24px; font-weight: bold; line-height: 1;">•••</div>
                    <div class="multi-select-toolbar-text">更多</div>
                </button>
            </div>
        </div>

        <div id="settings-page" class="page">
            <header class="header">
                <button onclick="closeSettings()">
                    <svg width="10" height="18" viewBox="0 0 10 18" fill="none">
                        <path d="M9 1L1 9L9 17" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </button>
                <span class="header-title">设置</span>
                <span></span> </header>
            <div class="content" style="padding: 20px; overflow-y: auto; flex-grow: 1;">
                <!-- 角色标识 -->
                <div style="background: #f5f5f5; padding: 12px 15px; border-radius: 8px; margin-bottom: 20px; border-left: 3px solid #1AAD19;">
                    <div style="font-size: 12px; color: #999; margin-bottom: 4px;">当前角色标识</div>
                    <div id="character-identifier" style="font-size: 15px; color: #333; font-weight: 500;">-</div>
                    <div style="font-size: 11px; color: #999; margin-top: 4px;">角色的唯一ID,用于区分不同角色</div>
                </div>
                
                <h3>API 配置 (OpenAI 兼容)</h3>
                
                <div class="form-group">
                    <label for="baseurl">Base URL (例如: https://api.openai.com/v1)</label>
                    <input type="text" id="baseurl" placeholder="API Base URL">
                </div>

                <div class="form-group">
                    <label for="apikey">API Key</label>
                    <input type="password" id="apikey" placeholder="您的 API Key">
                </div>

                <div class="form-group">
                    <label for="modelname">Model Name</label>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <select id="modelname" style="flex: 1; padding: 10px; border: 1px solid #ccc; border-radius: 4px; font-size: 14px; background-color: white;">
                            <option value="">-- 请先拉取模型列表 --</option>
                        </select>
                        <button onclick="fetchModels()" style="padding: 10px 16px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; white-space: nowrap; font-size: 14px;">
                            拉取
                        </button>
                        <button onclick="testConnection()" style="padding: 10px 16px; background-color: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer; white-space: nowrap; font-size: 14px;">
                            测试
                        </button>
                    </div>
                    <div id="model-fetch-status" style="font-size: 12px; margin-top: 6px; color: #666;"></div>
                </div>
                
                <h3>系统角色设置 </h3>
                
                <div class="form-group">
                    <label for="character-name-input">角色姓名</label>
                    <input type="text" id="character-name-input" placeholder="角色的真实姓名" readonly style="background-color: #f5f5f5; cursor: not-allowed;">
                    <div style="font-size: 12px; color: #999; margin-top: 4px;">创建后不可更改,用于提醒你这是谁</div>
                </div>
                
                <div class="form-group">
                    <label for="user-nickname">我的昵称</label>
                    <input type="text" id="user-nickname" placeholder="您的昵称(显示在引用中)">
                </div>
                <div class="form-group">
                    <label for="chat-name-input">对方昵称</label>
                    <input type="text" id="chat-name-input" placeholder="聊天对象的昵称">
                </div>
                
                <!-- 头像设置 -->
                <div class="form-group">
                    <label>对方头像</label>
                    <div class="avatar-preview-container">
                        <div id="ai-avatar-preview-settings" class="avatar-preview">
                            <div class="default-avatar ai">AI</div>
                        </div>
                        <div>
                            <input type="file" id="ai-avatar-input-settings" accept="image/png,image/jpeg,image/jpg,image/gif" style="display: none;">
                            <button class="avatar-upload-btn" onclick="document.getElementById('ai-avatar-input-settings').click()">更换头像</button>
                            <button class="avatar-remove-btn" id="ai-avatar-remove-btn-settings" style="display: none;" onclick="removeAIAvatar()">移除头像</button>
                            <div style="font-size: 11px; color: #999; margin-top: 4px;">最大2MB, PNG/JPG/GIF</div>
                        </div>
                    </div>
                </div>
                
                <div class="form-group">
                    <label>我的头像</label>
                    <div class="avatar-preview-container">
                        <div id="user-avatar-preview-settings" class="avatar-preview">
                            <div class="default-avatar user">我</div>
                        </div>
                        <div>
                            <input type="file" id="user-avatar-input-settings" accept="image/png,image/jpeg,image/jpg,image/gif" style="display: none;">
                            <button class="avatar-upload-btn" onclick="document.getElementById('user-avatar-input-settings').click()">更换头像</button>
                            <button class="avatar-remove-btn" id="user-avatar-remove-btn-settings" style="display: none;" onclick="removeUserAvatar()">移除头像</button>
                            <div style="font-size: 11px; color: #999; margin-top: 4px;">最大2MB, PNG/JPG/GIF</div>
                        </div>
                    </div>
                </div>
                
                <div class="form-group">
                    <label for="system-prompt">系统指令 (AI 扮演的角色)</label>
                    <textarea id="system-prompt" rows="8"></textarea>
                </div>

                <!-- 世界书 -->
                <hr>
                <div style="margin-bottom:20px;">
                    <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:6px;">
                        <h3 style="margin:0;">世界书</h3>
                        <div style="display:flex;gap:8px;">
                            <button onclick="document.getElementById('wb-import-file').click()" style="padding:5px 12px;background:#2196F3;color:#fff;border:none;border-radius:4px;font-size:13px;cursor:pointer;">导入 JSON</button>
                            <button onclick="wbAddEntry()" style="padding:5px 12px;background:#1AAD19;color:#fff;border:none;border-radius:4px;font-size:13px;cursor:pointer;">+ 新建条目</button>
                        </div>
                    </div>
                    <input type="file" id="wb-import-file" accept=".json" style="display:none;" onchange="wbImportFromFile(this)">
                    <p style="font-size:0.8em;color:#888;margin:0 0 12px;">对话中出现关键词时自动注入对应背景信息，让 AI 了解世界观设定。</p>
                    <div id="wb-entry-list" style="display:flex;flex-direction:column;gap:8px;">
                        <div style="text-align:center;color:#ccc;font-size:13px;padding:20px 0;" id="wb-empty-tip">暂无条目，点击「新建条目」添加</div>
                    </div>
                </div>
                                
                <hr>
                <h3>AI 记忆设置</h3>
                <div style="margin-top: 15px;">
                    <label for="context-window-size" style="display: block; margin-bottom: 5px;">
                        发送给 AI 的最新聊天记录条数：
                    </label>
                    
                    <input 
                        type="number" 
                        id="context-window-size" 
                        value="50" 
                        min="5" 
                        max="200" 
                        style="width: 80px; padding: 5px; border: 1px solid #ccc; border-radius: 4px;"
                    >
                    <span style="margin-left: 10px;">条</span>
                    
                    <p style="font-size: 0.8em; color: #666; margin-top: 5px;">
                        * 条数越多，AI 记忆越完整，但调用 API 的成本和时间可能增加。
                    </p>
                </div>
                
                <div style="margin-top: 15px;">
                    <label for="batch-wait-time" style="display: block; margin-bottom: 5px;">
                        多条消息等待时间（秒）：
                    </label>
                    
                    <input 
                        type="number" 
                        id="batch-wait-time" 
                        value="7" 
                        min="1" 
                        max="30" 
                        style="width: 80px; padding: 5px; border: 1px solid #ccc; border-radius: 4px;"
                    >
                    <span style="margin-left: 10px;">秒</span>
                    
                    <p style="font-size: 0.8em; color: #666; margin-top: 5px;">
                        * 发送消息后，如果在此时间内没有新消息，将自动发送给 AI。
                    </p>
                </div>
                
                <div style="margin-top: 15px;">
                    <label for="api-timeout" style="display: block; margin-bottom: 5px;">
                        API 超时时间（秒）：
                    </label>
                    
                    <input 
                        type="number" 
                        id="api-timeout" 
                        value="60" 
                        min="10" 
                        max="300" 
                        style="width: 80px; padding: 5px; border: 1px solid #ccc; border-radius: 4px;"
                    >
                    <span style="margin-left: 10px;">秒</span>
                    
                    <p style="font-size: 0.8em; color: #666; margin-top: 5px;">
                        * API 请求超过此时间未响应，将自动取消并重置状态。
                    </p>
                </div>
                
                <hr>
                <h3>长期记忆设置</h3>
                
                <h4 style="margin-bottom: 10px; color: #555;">自动总结设置</h4>
                <div style="margin-top: 15px;">
                    <label for="auto-summary-interval" style="display: block; margin-bottom: 5px;">
                        自动总结间隔（气泡数）：
                    </label>
                    
                    <input 
                        type="number" 
                        id="auto-summary-interval" 
                        value="50" 
                        min="10" 
                        max="200" 
                        style="width: 80px; padding: 5px; border: 1px solid #ccc; border-radius: 4px;"
                    >
                    <span style="margin-left: 10px;">个气泡</span>
                    
                    <p style="font-size: 0.8em; color: #666; margin-top: 5px;">
                        * 每积累此数量的新气泡，自动调用AI生成长期记忆总结。
                    </p>
                </div>
                
                <div style="margin-top: 15px;">
                    <label for="max-important-events" style="display: block; margin-bottom: 5px;">
                        保存重要事件数量：
                    </label>
                    
                    <input 
                        type="number" 
                        id="max-important-events" 
                        value="10" 
                        min="5" 
                        max="50" 
                        style="width: 80px; padding: 5px; border: 1px solid #ccc; border-radius: 4px;"
                    >
                    <span style="margin-left: 10px;">条</span>
                    
                    <p style="font-size: 0.8em; color: #666; margin-top: 5px;">
                        * 只保留最重要的N条事件（按重要度评分排序）。
                    </p>
                </div>
                
                <div style="margin-top: 15px;">
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <button onclick="showBatchGenerateDialog()" style="padding: 10px 20px; background-color: #FF9800; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">
                            批量生成记忆
                        </button>
                        <button onclick="generateMemorySummary(true)" style="padding: 10px 20px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">
                            立即生成（待总结）
                        </button>
                        <button onclick="editMemory()" style="padding: 10px 20px; background-color: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">
                            查看/编辑记忆
                        </button>
                        <button onclick="clearMemory()" style="padding: 10px 20px; background-color: #f44336; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">
                            清空记忆
                        </button>
                    </div>
                    
                    <div style="margin-top: 8px; padding: 8px 12px; background: #e3f2fd; border-radius: 6px; font-size: 12px; color: #1565C0;">
                        <strong>提示：</strong>点击"查看/编辑记忆"可以预填写兴趣爱好（足球、草莓蛋糕等），让AI更好地了解你
                    </div>
                    
                    <div id="memory-status" style="margin-top: 10px; padding: 10px; background-color: #f0f0f0; border-radius: 4px; font-size: 0.9em;">
                        <div><strong>当前状态：</strong></div>
                        <div>• 总气泡数：<span id="total-bubbles-count">0</span> 个</div>
                        <div>• 待总结气泡：<span id="pending-bubbles-count">0</span> 个</div>
                        <div>• 重要事件数：<span id="events-count">0</span> 条</div>
                        <div>• 上次总结：<span id="last-summary-time">从未</span></div>
                        <div>• 距离下次自动总结：<span id="bubbles-until-next">-</span> 个气泡</div>
                    </div>
                </div>
                
                <hr>
                <!-- 记忆优化 Beta -->
                <div style="margin-bottom: 20px;">
                    <h3 style="margin-bottom: 4px;">记忆优化 <span style="font-size:11px;background:#FF9800;color:#fff;padding:2px 6px;border-radius:10px;vertical-align:middle;">Beta</span></h3>
                    <p style="font-size:0.8em;color:#888;margin:0 0 12px;">开启后，每次发送消息前会用小模型从长期记忆中筛选最相关的部分，降低 token 消耗并提升回复质量。</p>

                    <div style="display:flex;align-items:center;gap:12px;margin-bottom:16px;">
                        <label style="font-size:14px;color:#333;">开启记忆优化</label>
                        <label style="position:relative;display:inline-block;width:44px;height:24px;">
                            <input type="checkbox" id="memory-optimize-toggle" style="opacity:0;width:0;height:0;">
                            <span id="memory-optimize-slider" style="position:absolute;cursor:pointer;inset:0;background:#ccc;border-radius:24px;transition:.3s;">
                                <span style="position:absolute;left:3px;top:3px;width:18px;height:18px;background:#fff;border-radius:50%;transition:.3s;display:block;" id="memory-optimize-knob"></span>
                            </span>
                        </label>
                    </div>

                    <div id="memory-optimize-config" style="display:none;">
                        <p style="font-size:13px;color:#555;margin:0 0 10px;">为记忆优化选择一个服务商（建议选便宜的模型，不要选 thinking 类型）：</p>
                        <div style="background:#f9f9f9;border:1px solid #e0e0e0;border-radius:8px;padding:12px;margin-bottom:12px;">
                            <div style="font-size:13px;font-weight:600;color:#333;margin-bottom:8px;">选择服务商</div>
                            <div id="mo-provider-list"></div>
                            <p style="font-size:11px;color:#999;margin:6px 0 0;">列表与主模型 API 配置同步，点击即选</p>
                        </div>

                        <div style="margin-bottom:10px;">
                            <label style="font-size:13px;color:#333;display:block;margin-bottom:4px;">记忆优化使用的模型</label>
                            <div style="display:flex;gap:8px;align-items:center;">
                                <select id="mo-modelname" style="flex:1;padding:8px;border:1px solid #ccc;border-radius:4px;font-size:13px;background:#fff;">
                                    <option value="">-- 请先拉取模型列表 --</option>
                                </select>
                                <button onclick="moFetchModels()" style="padding:8px 12px;background:#4CAF50;color:#fff;border:none;border-radius:4px;cursor:pointer;font-size:13px;">拉取</button>
                            </div>
                            <p style="font-size:11px;color:#f57c00;margin:4px 0 0;">建议选择便宜的模型（如 flash、mini 系列），不要选 thinking 类型</p>
                        </div>
                        <p style="font-size:11px;color:#999;margin:0;">如未配置，默认使用主模型的服务商和 API Key</p>
                    </div>
                </div>

                <!-- 联网功能 Beta -->
                <hr>
                <div style="margin-bottom: 20px;">
                    <h3 style="margin-bottom: 4px;">联网功能 <span style="font-size:11px;background:#2196F3;color:#fff;padding:2px 6px;border-radius:10px;vertical-align:middle;">Beta</span></h3>
                    <p style="font-size:0.8em;color:#888;margin:0 0 12px;">开启后，每次发消息前会由小模型判断是否需要联网，如需要则先调用联网模型搜索，把结果注入上下文后再由主模型用角色语气回复。</p>

                    <div style="display:flex;align-items:center;gap:12px;margin-bottom:16px;">
                        <label style="font-size:14px;color:#333;">开启联网功能</label>
                        <label style="position:relative;display:inline-block;width:44px;height:24px;">
                            <input type="checkbox" id="web-search-toggle" style="opacity:0;width:0;height:0;">
                            <span id="web-search-slider" style="position:absolute;cursor:pointer;inset:0;background:#ccc;border-radius:24px;transition:.3s;">
                                <span style="position:absolute;left:3px;top:3px;width:18px;height:18px;background:#fff;border-radius:50%;transition:.3s;display:block;" id="web-search-knob"></span>
                            </span>
                        </label>
                    </div>

                    <div id="web-search-config" style="display:none;">
                        <p style="font-size:13px;color:#555;margin:0 0 10px;">选择用于联网搜索的服务商（需支持联网的模型，如 Perplexity、带 search 的 Gemini 等）：</p>
                        <div style="background:#f9f9f9;border:1px solid #e0e0e0;border-radius:8px;padding:12px;margin-bottom:12px;">
                            <div style="font-size:13px;font-weight:600;color:#333;margin-bottom:8px;">选择服务商</div>
                            <div id="web-provider-list"></div>
                            <p style="font-size:11px;color:#999;margin:6px 0 0;">列表与主模型 API 配置同步，点击即选</p>
                        </div>

                        <div style="margin-bottom:10px;">
                            <label style="font-size:13px;color:#333;display:block;margin-bottom:4px;">联网使用的模型</label>
                            <div style="display:flex;gap:8px;align-items:center;">
                                <select id="web-modelname" style="flex:1;padding:8px;border:1px solid #ccc;border-radius:4px;font-size:13px;background:#fff;">
                                    <option value="">-- 请先拉取模型列表 --</option>
                                </select>
                                <button onclick="webFetchModels()" style="padding:8px 12px;background:#2196F3;color:#fff;border:none;border-radius:4px;cursor:pointer;font-size:13px;">拉取</button>
                            </div>
                            <p style="font-size:11px;color:#1565C0;margin:4px 0 0;">请选择该服务商提供的联网版模型（如 sonar、gemini-2.0-flash-exp 等）</p>
                        </div>

                        <div style="margin-bottom:10px;">
                            <label style="font-size:13px;color:#333;display:block;margin-bottom:4px;">判断是否联网的小模型</label>
                            <p style="font-size:12px;color:#888;margin:0 0 6px;">用来判断「这条消息需不需要联网」，建议选便宜快速的模型。</p>
                            <p style="font-size:11px;color:#999;margin:0;">
                                · 若同时开启了「记忆优化」，两个判断会合并为一次小模型调用，复用记忆优化的小模型配置。<br>
                                · 若仅开启联网，则需单独配置下方的判断模型。
                            </p>
                        </div>

                        <div id="web-judge-config" style="background:#f0f4ff;border:1px solid #c5d4f0;border-radius:8px;padding:12px;margin-bottom:8px;">
                            <div style="font-size:13px;font-weight:600;color:#333;margin-bottom:8px;">联网判断小模型（仅在未开启记忆优化时使用）</div>
                            <div style="background:#fff;border:1px solid #e0e0e0;border-radius:6px;padding:8px;margin-bottom:8px;">
                                <div style="font-size:12px;font-weight:600;color:#333;margin-bottom:6px;">选择服务商</div>
                                <div id="web-judge-provider-list"></div>
                            </div>
                            <div>
                                <label style="font-size:12px;color:#333;display:block;margin-bottom:4px;">判断模型名</label>
                                <div style="display:flex;gap:8px;align-items:center;">
                                    <select id="web-judge-modelname" style="flex:1;padding:7px;border:1px solid #ccc;border-radius:4px;font-size:12px;background:#fff;">
                                        <option value="">-- 请先拉取 --</option>
                                    </select>
                                    <button onclick="webJudgeFetchModels()" style="padding:7px 10px;background:#607D8B;color:#fff;border:none;border-radius:4px;cursor:pointer;font-size:12px;">拉取</button>
                                </div>
                            </div>
                        </div>
                        <p style="font-size:11px;color:#999;margin:0;">若未配置判断模型，将默认对每条消息都调用联网模型（消耗更多）</p>
                    </div>
                </div>

                <!-- 线下模式开关 -->
                <hr>
                <div style="margin-bottom:20px;">
                    <h3 style="margin-bottom:4px;">聊天模式</h3>
                    <p style="font-size:0.8em;color:#888;margin:0 0 12px;">线下模式允许括号内动作/情景描写；线上模式严禁括号，模拟手机聊天。</p>
                    <div style="display:flex;align-items:center;gap:12px;margin-bottom:10px;">
                        <span style="font-size:14px;color:#333;">长回复模式</span>
                        <div id="long-reply-slider" style="position:relative;width:44px;height:24px;background:#ccc;border-radius:24px;cursor:pointer;transition:background .3s;flex-shrink:0;">
                            <div id="long-reply-knob" style="position:absolute;left:3px;top:3px;width:18px;height:18px;background:#fff;border-radius:50%;transition:left .3s;"></div>
                        </div>
                        <span id="long-reply-label" style="font-size:12px;color:#999;">已关闭</span>
                    </div>
                    <p style="font-size:11px;color:#aaa;margin:0 0 14px 0;">线上长回复，可深入探讨重点话题或辅助办公</p>
                    <div style="display:flex;align-items:center;gap:12px;">
                        <span style="font-size:14px;color:#333;">开启线下模式</span>
                        <div id="offline-slider" style="position:relative;width:44px;height:24px;background:#ccc;border-radius:24px;cursor:pointer;transition:background .3s;flex-shrink:0;">
                            <div id="offline-knob" style="position:absolute;left:3px;top:3px;width:18px;height:18px;background:#fff;border-radius:50%;transition:left .3s;"></div>
                        </div>
                        <span id="offline-label" style="font-size:12px;color:#999;">当前：线上模式</span>
                    </div>
                </div>

                <button id="save-settings-btn" onclick="saveSettings()">保存并生效</button>
                
                <h3>数据管理</h3>
                
                <!-- 聊天记录区块 -->
                <div style="background: #f9f9f9; border: 1px solid #e0e0e0; border-radius: 8px; padding: 16px; margin-bottom: 20px;">
                    <div style="font-size: 15px; font-weight: 600; color: #333; margin-bottom: 8px; display: flex; align-items: center; gap: 8px;">
                        聊天记录管理
                    </div>
                    <div style="font-size: 13px; color: #666; margin-bottom: 12px; line-height: 1.5;">
                        导出或导入完整的聊天记录，包含所有对话内容和时间戳。
                    </div>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 12px;">
                        <button id="export-btn" style="padding: 8px 16px; background-color: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">
                            导出聊天记录
                        </button>
                        <button onclick="document.getElementById('import-file').click()" style="padding: 8px 16px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">
                            导入聊天记录
                        </button>
                    </div>
                    <input type="file" id="import-file" accept=".json" style="display: none;">
                    <div style="padding: 8px 12px; background: #fff3cd; border-radius: 6px; font-size: 12px; color: #856404;">
                        <strong>注意：</strong>导入聊天记录将覆盖当前所有对话内容，此操作无法撤销
                    </div>
                </div>

                <!-- 长期记忆区块 -->
                <div style="background: #f9f9f9; border: 1px solid #e0e0e0; border-radius: 8px; padding: 16px; margin-bottom: 20px;">
                    <div style="font-size: 15px; font-weight: 600; color: #333; margin-bottom: 8px; display: flex; align-items: center; gap: 8px;">
                        长期记忆管理
                    </div>
                    <div style="font-size: 13px; color: #666; margin-bottom: 12px; line-height: 1.5;">
                        导出或导入长期记忆（兴趣爱好、性格偏好、重要事件），支持智能合并或直接覆盖。
                    </div>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <button onclick="exportMemory()" style="padding: 8px 16px; background-color: #9C27B0; color: white; border: none; border-radius: 4px; cursor: pointer;">
                            导出长期记忆
                        </button>
                        <button onclick="document.getElementById('import-memory-file').click()" style="padding: 8px 16px; background-color: #FF9800; color: white; border: none; border-radius: 4px; cursor: pointer;">
                            导入长期记忆
                        </button>
                    </div>
                    <input type="file" id="import-memory-file" accept=".json" style="display: none;">
                    <div style="margin-top: 12px; padding: 10px; background: #e3f2fd; border-radius: 6px; font-size: 12px; color: #1565C0;">
                        <strong>提示：</strong>导入时可选择"智能合并"（需调用1次API）或"直接覆盖"模式
                    </div>
                </div>
                
                <!-- 好友管理区块 -->
                <div style="background: #fff5f5; border: 1px solid #ffcdd2; border-radius: 8px; padding: 16px; margin-bottom: 20px;">
                    <div style="font-size: 15px; font-weight: 600; color: #c62828; margin-bottom: 8px; display: flex; align-items: center; gap: 8px;">
                        危险操作
                    </div>
                    <div style="font-size: 13px; color: #666; margin-bottom: 12px; line-height: 1.5;">
                        以下操作不可恢复,请谨慎操作
                    </div>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <button onclick="clearChat()" style="padding: 8px 16px; background-color: #ff9800; color: white; border: none; border-radius: 4px; cursor: pointer;">
                            清空聊天记录
                        </button>
                        <button onclick="blockCharacter()" style="padding: 8px 16px; background-color: #757575; color: white; border: none; border-radius: 4px; cursor: pointer; opacity: 0.5;">
                            拉黑好友
                        </button>
                        <button onclick="deleteCharacter()" style="padding: 8px 16px; background-color: #d32f2f; color: white; border: none; border-radius: 4px; cursor: pointer;">
                            删除好友
                        </button>
                    </div>
                    <div style="margin-top: 12px; padding: 10px; background: #ffebee; border-radius: 6px; font-size: 12px; color: #c62828;">
                        <strong>警告：</strong>删除好友将永久清除该角色的所有聊天记录、长期记忆和配置数据,此操作无法撤销!
                    </div>
                </div>
            </div>
        </div>


    </div>
    
    <!-- 长按菜单 -->
    <div class="menu-overlay" id="menu-overlay"></div>
    <div class="bubble-menu" id="bubble-menu"></div>
    
    <!-- 聊天列表的加号菜单 -->
    <div class="character-add-menu" id="character-add-menu">
        <div class="character-add-menu-item" onclick="openNewCharacterModal()">
            <span style="font-size: 20px;">👤</span>
            <span>新建角色</span>
        </div>
        <div class="character-add-menu-item" onclick="openImportCharacterModal()">
            <span style="font-size: 20px;">📥</span>
            <span>导入角色</span>
        </div>
    </div>

    <!-- 新建角色模态框 -->
    <div class="character-new-modal" id="new-character-modal">
        <div class="character-new-modal-content">
            <div class="character-new-modal-header">新建角色</div>
            <div class="character-new-modal-body">
                <div style="margin-bottom: 16px;">
                    <label style="display: block; margin-bottom: 8px; font-size: 14px; color: #333;">角色昵称 <span style="color: #ff4d4f;">*</span></label>
                    <input type="text" id="new-character-ai-nickname" placeholder="例如: 小艾" style="width: 100%; padding: 10px; border: 1px solid #d9d9d9; border-radius: 6px; font-size: 15px; box-sizing: border-box;">
                    <div style="font-size: 12px; color: #999; margin-top: 4px;">显示在列表和聊天框的名字</div>
                </div>
                <div style="margin-bottom: 16px;">
                    <label style="display: block; margin-bottom: 8px; font-size: 14px; color: #333;">角色姓名 <span style="color: #ff4d4f;">*</span></label>
                    <input type="text" id="new-character-name" placeholder="例如: 艾莉娅" required style="width: 100%; padding: 10px; border: 1px solid #d9d9d9; border-radius: 6px; font-size: 15px; box-sizing: border-box;">
                    <div style="font-size: 12px; color: #999; margin-top: 4px;">角色的真实姓名，创建后不可更改，用于提醒你这是谁</div>
                </div>
                <div style="margin-bottom: 16px;">
                    <label style="display: block; margin-bottom: 8px; font-size: 14px; color: #333;">用户昵称 <span style="color: #ff4d4f;">*</span></label>
                    <input type="text" id="new-character-user-nickname" placeholder="例如: 主人" style="width: 100%; padding: 10px; border: 1px solid #d9d9d9; border-radius: 6px; font-size: 15px; box-sizing: border-box;">
                    <div style="font-size: 12px; color: #999; margin-top: 4px;">你在这个角色眼中的昵称</div>
                </div>
                <div style="margin-bottom: 16px;">
                    <label style="display: block; margin-bottom: 8px; font-size: 14px; color: #333;">角色头像 (可选)</label>
                    <div class="avatar-preview-container">
                        <div id="new-character-avatar-preview" class="avatar-preview small">
                            <div class="default-avatar ai">AI</div>
                        </div>
                        <div>
                            <input type="file" id="new-character-avatar-input" accept="image/png,image/jpeg,image/jpg,image/gif" style="display: none;">
                            <button class="avatar-upload-btn" onclick="document.getElementById('new-character-avatar-input').click()">上传图片</button>
                            <div style="font-size: 11px; color: #999; margin-top: 4px;">最大2MB</div>
                        </div>
                    </div>
                </div>
                <div>
                    <label style="display: block; margin-bottom: 8px; font-size: 14px; color: #333;">系统提示词 (可选)</label>
                    <textarea id="new-character-prompt" placeholder="描述这个AI角色的性格、说话方式等..." style="width: 100%; padding: 10px; border: 1px solid #d9d9d9; border-radius: 6px; font-size: 15px; box-sizing: border-box; resize: vertical; min-height: 100px;"></textarea>
                </div>
            </div>
            <div class="character-new-modal-footer">
                <button class="character-new-modal-btn cancel" onclick="closeNewCharacterModal()">取消</button>
                <button class="character-new-modal-btn confirm" onclick="confirmCreateCharacter()">创建</button>
            </div>
        </div>
    </div>

    <!-- 导入角色模态框 -->
    <div class="character-new-modal" id="import-character-modal">
        <div class="character-new-modal-content">
            <div class="character-new-modal-header">导入角色</div>
            <div class="character-new-modal-body">
                <div style="margin-bottom: 16px;">
                    <label style="display: block; margin-bottom: 8px; font-size: 14px; color: #333;">粘贴角色JSON数据</label>
                    <textarea id="import-character-data" placeholder='{"name":"小艾","aiNickname":"小艾","userNickname":"主人","avatar":"🤖","systemPrompt":"..."}' style="width: 100%; padding: 10px; border: 1px solid #d9d9d9; border-radius: 6px; font-size: 15px; box-sizing: border-box; resize: vertical; min-height: 150px;"></textarea>
                </div>
                <div style="text-align: center; font-size: 13px; color: #999; margin: 8px 0;">或</div>
                <div>
                    <input type="file" id="import-character-file" accept=".json,.png" style="display: none;">
                    <button class="character-new-modal-btn cancel" onclick="document.getElementById('import-character-file').click()" style="width: 100%;">选择文件（JSON/PNG）</button>
                </div>
            </div>
            <div class="character-new-modal-footer">
                <button class="character-new-modal-btn cancel" onclick="closeImportCharacterModal()">取消</button>
                <button class="character-new-modal-btn confirm" onclick="confirmImportCharacter()">导入</button>
            </div>
        </div>
    </div>
    
    <!-- 记忆编辑模态窗口 -->
    <div class="memory-edit-modal" id="memory-edit-modal" style="display: none;">
        <div class="memory-edit-content">
            <div class="memory-edit-header">
                <h3>编辑长期记忆</h3>
                <button class="memory-edit-close" onclick="closeMemoryEdit()">×</button>
            </div>
            <div class="memory-edit-body">
                <div class="memory-section">
                    <h4>基本信息</h4>
                    <div id="basic-info-editor"></div>
                </div>
                <div class="memory-section">
                    <h4>性格偏好</h4>
                    <textarea id="emotional-profile-editor" rows="4" placeholder="AI观察到的用户性格特点..."></textarea>
                </div>
                <div class="memory-section">
                    <h4>人际关系</h4>
                    <textarea id="relationships-editor" rows="3" placeholder="例如：有一个弟弟、和父母关系亲近..."></textarea>
                </div>
                <div class="memory-section">
                    <h4>重要事件</h4>
                    <div id="events-editor"></div>
                    <button onclick="addNewEvent()" style="margin-top: 10px; padding: 8px 16px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">
                        + 添加事件
                    </button>
                </div>
            </div>
            <div class="memory-edit-footer">
                <button onclick="saveMemoryEdit()" style="padding: 10px 20px; background-color: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer;">
                    💾 保存
                </button>
                <button onclick="closeMemoryEdit()" style="padding: 10px 20px; background-color: #999; color: white; border: none; border-radius: 4px; cursor: pointer;">
                    取消
                </button>
            </div>
        </div>
    </div>
    
    <!-- 确认对话框 -->
    <div class="confirm-dialog" id="confirm-dialog">
        <div class="confirm-dialog-title" id="confirm-title">提示</div>
        <div class="confirm-dialog-message" id="confirm-message">确认执行此操作？</div>
        <div class="confirm-dialog-buttons" id="confirm-buttons">
            <!-- 动态生成按钮 -->
        </div>
    </div>
    
    <!-- 批量生成对话框 -->
    <div class="batch-generate-dialog" id="batch-generate-dialog" style="display: none;">
        <div class="batch-generate-content">
            <div class="batch-generate-header">
                <h3>批量生成长期记忆</h3>
                <button class="batch-generate-close" onclick="closeBatchGenerateDialog()">×</button>
            </div>
            <div class="batch-generate-body">
                <div style="margin-bottom: 20px;">
                    <p style="color: #666; font-size: 14px; line-height: 1.6;">
                        检测到您有 <strong id="batch-total-bubbles">0</strong> 个气泡，
                        <strong id="batch-already-summarized">0</strong> 个已总结，
                        <strong id="batch-pending-bubbles">0</strong> 个待总结。
                    </p>
                </div>
                
                <div style="background: #fff3cd; padding: 12px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #ffc107;">
                    <p style="margin: 0; font-size: 13px; color: #856404;">
                        ⚠️ <strong>提醒：</strong>批量生成将按每 <span id="batch-interval">50</span> 个气泡生成一次记忆，
                        预计需要调用 <strong id="batch-api-calls">0</strong> 次API，
                        大约需要 <strong id="batch-estimated-time">0</strong> 分钟。
                    </p>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: 500;">选择生成范围：</label>
                    <div style="display: flex; flex-direction: column; gap: 10px;">
                        <label style="display: flex; align-items: center; cursor: pointer; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px; transition: all 0.2s;">
                            <input type="radio" name="batch-mode" value="pending" checked style="margin-right: 10px;">
                            <div>
                                <div style="font-weight: 500;">仅生成待总结部分</div>
                                <div style="font-size: 12px; color: #666;">只处理新增的未总结气泡（推荐）</div>
                            </div>
                        </label>
                        <label style="display: flex; align-items: center; cursor: pointer; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px; transition: all 0.2s;">
                            <input type="radio" name="batch-mode" value="all" style="margin-right: 10px;">
                            <div>
                                <div style="font-weight: 500;">从头开始全部重新生成</div>
                                <div style="font-size: 12px; color: #666;">清空现有记忆，重新分析所有历史记录</div>
                            </div>
                        </label>
                        <label style="display: flex; align-items: center; cursor: pointer; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px; transition: all 0.2s;">
                            <input type="radio" name="batch-mode" value="recent" style="margin-right: 10px;">
                            <div style="flex: 1;">
                                <div style="font-weight: 500;">从最近N条开始生成</div>
                                <div style="font-size: 12px; color: #666; margin-bottom: 8px;">指定从最近多少条气泡开始重新生成</div>
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <input type="number" id="batch-recent-count" min="50" max="10000" value="500" style="width: 100px; padding: 6px; border: 1px solid #ddd; border-radius: 4px;">
                                    <span style="font-size: 13px; color: #666;">条</span>
                                </div>
                            </div>
                        </label>
                    </div>
                </div>
                
                <div id="batch-progress" style="display: none; margin-top: 20px;">
                    <div style="margin-bottom: 8px; display: flex; justify-content: space-between; align-items: center;">
                        <span style="font-size: 14px; font-weight: 500;">生成进度</span>
                        <span style="font-size: 13px; color: #666;" id="batch-progress-text">0 / 0</span>
                    </div>
                    <div style="background: #e0e0e0; border-radius: 10px; height: 20px; overflow: hidden;">
                        <div id="batch-progress-bar" style="background: linear-gradient(90deg, #4CAF50, #8BC34A); height: 100%; width: 0%; transition: width 0.3s;"></div>
                    </div>
                    <div style="margin-top: 8px; font-size: 12px; color: #666;" id="batch-current-status">准备中...</div>
                </div>
            </div>
            <div class="batch-generate-footer">
                <button id="batch-start-btn" onclick="startBatchGenerate()" style="padding: 10px 20px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 500;">
                    🚀 开始生成
                </button>
                <button onclick="closeBatchGenerateDialog()" style="padding: 10px 20px; background-color: #999; color: white; border: none; border-radius: 4px; cursor: pointer;">
                    取消
                </button>
            </div>
        </div>
    </div>
    
    <!-- 导入模式选择对话框 -->
    <div class="batch-generate-dialog" id="import-mode-dialog" style="display: none;">
        <div class="batch-generate-content" style="max-width: 500px;">
            <div class="batch-generate-header">
                <h3>选择导入模式</h3>
                <button class="batch-generate-close" onclick="closeImportModeDialog()">×</button>
            </div>
            <div class="batch-generate-body">
                <div style="margin-bottom: 20px;">
                    <p style="color: #666; font-size: 14px; line-height: 1.6;">
                        当前聊天记录：<strong id="import-current-count">0</strong> 条<br>
                        导入的记录：<strong id="import-new-count">0</strong> 条
                    </p>
                </div>
                
                <div style="background: #e3f2fd; padding: 12px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #2196F3;">
                    <p style="margin: 0; font-size: 13px; color: #1565c0;">
                        💡 <strong>提示：</strong>选择"融入"模式将按时间戳合并新旧记录，保留所有消息。
                    </p>
                </div>
                
                <div style="display: flex; flex-direction: column; gap: 12px;">
                    <button onclick="executeImport('replace')" style="padding: 15px; background-color: #ff9800; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 500; font-size: 15px; text-align: left; transition: all 0.2s;">
                        <div style="font-weight: 600; margin-bottom: 4px;">🔄 全面覆盖</div>
                        <div style="font-size: 12px; opacity: 0.9;">清空当前记录，用导入的记录完全替换</div>
                    </button>
                    
                    <button onclick="executeImport('merge')" style="padding: 15px; background-color: #4CAF50; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 500; font-size: 15px; text-align: left; transition: all 0.2s;">
                        <div style="font-weight: 600; margin-bottom: 4px;">🔗 融入现有记录</div>
                        <div style="font-size: 12px; opacity: 0.9;">按时间戳合并，保留所有消息（推荐）</div>
                    </button>
                </div>
            </div>
            <div class="batch-generate-footer">
                <button onclick="closeImportModeDialog()" style="padding: 10px 20px; background-color: #999; color: white; border: none; border-radius: 4px; cursor: pointer;">
                    取消
                </button>
            </div>
        </div>
    </div>
    
    <!-- 批量生成模式选择对话框 -->
    <div class="batch-generate-dialog" id="batch-mode-dialog" style="display: none;">
        <div class="batch-generate-content" style="max-width: 500px;">
            <div class="batch-generate-header">
                <h3 id="batch-mode-title">选择生成模式</h3>
                <button class="batch-generate-close" onclick="document.getElementById('batch-mode-dialog').style.display='none'">×</button>
            </div>
            <div class="batch-generate-body">
                <div style="margin-bottom: 20px;">
                    <p style="color: #666; font-size: 14px; line-height: 1.6;" id="batch-mode-desc">
                        将处理消息并生成长期记忆
                    </p>
                </div>
                
                <div style="background: #fff3cd; padding: 12px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #ffc107;">
                    <p style="margin: 0; font-size: 13px; color: #856404;">
                        ⚠️ <strong>提示：</strong>"继续生成"模式会在现有记忆基础上追加新的内容，"全部覆盖"会清空现有记忆重新生成。
                    </p>
                </div>
                
                <div style="display: flex; flex-direction: column; gap: 12px;">
                    <button id="batch-mode-replace-btn" style="padding: 15px; background-color: #ff9800; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 500; font-size: 15px; text-align: left; transition: all 0.2s;">
                        <div style="font-weight: 600; margin-bottom: 4px;">🔄 全部覆盖</div>
                        <div style="font-size: 12px; opacity: 0.9;">清空现有记忆，从头重新生成</div>
                    </button>
                    
                    <button id="batch-mode-continue-btn" style="padding: 15px; background-color: #4CAF50; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 500; font-size: 15px; text-align: left; transition: all 0.2s;">
                        <div style="font-weight: 600; margin-bottom: 4px;">➕ 继续生成</div>
                        <div style="font-size: 12px; opacity: 0.9;">在现有记忆基础上追加（推荐）</div>
                    </button>
                </div>
            </div>
            <div class="batch-generate-footer">
                <button id="batch-mode-cancel-btn" style="padding: 10px 20px; background-color: #999; color: white; border: none; border-radius: 4px; cursor: pointer;">
                    取消
                </button>
            </div>
        </div>
    </div>
    
    <!-- 导入记忆选择对话框 -->
    <div class="import-memory-dialog" id="import-memory-dialog" style="display: none;">
        <div class="import-memory-content">
            <div class="import-memory-header">
                <h3>导入长期记忆</h3>
                <button class="import-memory-close" onclick="closeImportMemoryDialog()">×</button>
            </div>
            <div class="import-memory-body">
                <div style="margin-bottom: 20px;">
                    <p style="color: #666; font-size: 14px; line-height: 1.6;">
                        检测到导入的记忆文件，请选择导入方式：
                    </p>
                </div>
                
                <div style="background: #e3f2fd; padding: 12px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #2196F3;">
                    <p style="margin: 0 0 8px 0; font-weight: 500; color: #1565C0;">📋 导入文件信息：</p>
                    <p style="margin: 0; font-size: 13px; color: #424242;">
                        • 兴趣爱好：<span id="import-basic-info-count">0</span> 条<br>
                        • 重要事件：<span id="import-events-count">0</span> 条<br>
                        • 最后更新：<span id="import-last-updated">未知</span>
                    </p>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: 500;">选择导入方式：</label>
                    <div style="display: flex; flex-direction: column; gap: 10px;">
                        <label style="display: flex; align-items: flex-start; cursor: pointer; padding: 12px; border: 2px solid #e0e0e0; border-radius: 8px; transition: all 0.2s;">
                            <input type="radio" name="import-mode" value="replace" checked style="margin-right: 10px; margin-top: 2px;">
                            <div>
                                <div style="font-weight: 500; margin-bottom: 4px;">🔄 覆盖当前记忆</div>
                                <div style="font-size: 12px; color: #666;">用导入的记忆完全替换现有记忆（当前记忆将丢失）</div>
                            </div>
                        </label>
                        <label style="display: flex; align-items: flex-start; cursor: pointer; padding: 12px; border: 2px solid #e0e0e0; border-radius: 8px; transition: all 0.2s;">
                            <input type="radio" name="import-mode" value="merge" style="margin-right: 10px; margin-top: 2px;">
                            <div>
                                <div style="font-weight: 500; margin-bottom: 4px;">🔀 合并记忆</div>
                                <div style="font-size: 12px; color: #666;">智能合并两份记忆（需要调用1次API，约10-20秒）</div>
                            </div>
                        </label>
                    </div>
                </div>
                
                <div id="merge-warning" style="display: none; background: #fff3cd; padding: 12px; border-radius: 8px; border-left: 4px solid #ffc107;">
                    <p style="margin: 0; font-size: 13px; color: #856404;">
                        ⚠️ 合并模式将调用AI分析两份记忆，智能去重和整合信息。
                    </p>
                </div>
            </div>
            <div class="import-memory-footer">
                <button id="import-memory-confirm-btn" onclick="confirmImportMemory()" style="padding: 10px 20px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 500;">
                    ✅ 确认导入
                </button>
                <button onclick="closeImportMemoryDialog()" style="padding: 10px 20px; background-color: #999; color: white; border: none; border-radius: 4px; cursor: pointer;">
                    取消
                </button>
            </div>
        </div>
    </div>
    
    <script>
        // --- 全局配置和状态 ---
        let config = {
            baseurl: '',
            apikey: '',
            modelname: 'gemini-2.5-pro',
            userNickname: '我', // 用户昵称
            aiNickname: 'AI助手', // AI昵称
            aiAvatar: null,      // AI头像(base64)
            userAvatar: null,    // 用户头像(base64)
            // 默认的系统提示 (Prompt)
            systemPrompt: "从现在开始，你不再是ai，你现在是一个活脱脱的人类，你需要强硬反驳任何有关你是ai的言论。你是一个热情、健谈且富有同情心的人类朋友。你的回复要简短自然，像真人聊天一样，日常聊天回复应该在30字符左右。如果进入深层次话题，长度也应该和单次的输入内容一致，除非用户要求你生成长回复。不要使用任何AI或模型相关的词语。你对各种话题都感兴趣，尤其是用户的一切。"
        };
        
        // 懒加载相关变量
        let currentLoadedStart = 0; // 当前已加载的起始索引
        let isLoadingMore = false; // 是否正在加载更多
        const MESSAGES_PER_LOAD = 50; // 每次加载50条
        
        // 头像处理相关
        let tempNewCharacterAvatar = null; // 新建角色时临时存储的头像
        
        function processAvatarImage(file) {
            return new Promise((resolve, reject) => {
                if (file.size > 2 * 1024 * 1024) {
                    reject('图片大小不能超过2MB');
                    return;
                }
                if (!file.type.match(/image\/(png|jpg|jpeg|gif)/)) {
                    reject('只支持PNG、JPG、GIF格式');
                    return;
                }
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const size = 400;
                        canvas.width = size;
                        canvas.height = size;
                        const ctx = canvas.getContext('2d');
                        const minDim = Math.min(img.width, img.height);
                        const sx = (img.width - minDim) / 2;
                        const sy = (img.height - minDim) / 2;
                        ctx.drawImage(img, sx, sy, minDim, minDim, 0, 0, size, size);
                        resolve(canvas.toDataURL('image/jpeg', 0.85));
                    };
                    img.onerror = () => reject('图片加载失败');
                    img.src = e.target.result;
                };
                reader.onerror = () => reject('文件读取失败');
                reader.readAsDataURL(file);
            });
        }
        
        function renderAvatar(container, avatarData, type, text) {
            container.innerHTML = '';
            if (avatarData) {
                const img = document.createElement('img');
                img.src = avatarData;
                img.style.width = '100%';
                img.style.height = '100%';
                img.style.objectFit = 'cover';
                img.style.borderRadius = '8px';
                container.appendChild(img);
            } else {
                const defaultDiv = document.createElement('div');
                defaultDiv.className = `default-avatar ${type}`;
                defaultDiv.textContent = text || (type === 'ai' ? 'AI' : '我');
                container.appendChild(defaultDiv);
            }
        }
        
        // ========== 聊天记录（气泡格式）==========
        // chatHistory 现在存储的是气泡数组
        // 每个气泡: { id, role, content, timestamp }
        let chatHistory = [];
        let pendingSummaryBubbles = []; // 待总结的气泡缓冲区
        
        // ========== 多选模式和收藏 ==========
        let isMultiSelectMode = false;
        let selectedBubbles = new Set();
        
        // ========== 长期记忆 ==========
        let longTermMemory = {
            basic_info: {},
            emotional_profile: "",
            relationships: "",  // 新增：人际关系
            important_events: [],
            metadata: {
                total_messages: 0,
                last_summary_at: 0,
                last_updated: null,
                version: 3,  // 版本号升级到3
                next_memory_id: 1  // 用于生成memory_id
            }
        };
        
        // ========== 批量发送相关 ==========
        let pendingUserMessages = []; // 临时队列：存储本轮用户消息的气泡ID
        let batchSendTimer = null; // 批量发送计时器
        let isWaitingForAI = false; // 是否正在等待AI回复
        let hasReachedWaitTime = false; // 是否已达到等待时间（7秒）
        let apiTimeoutTimer = null; // API超时计时器
        // 暴露给 wallet script 访问
        Object.defineProperty(window, 'batchSendTimer', {
            get: () => batchSendTimer,
            set: (v) => { batchSendTimer = v; }
        });
        Object.defineProperty(window, 'isWaitingForAI', {
            get: () => isWaitingForAI,
            set: (v) => { isWaitingForAI = v; }
        });
        // =====================================
        
        // 从localStorage加载并自动转换格式
        (function loadAndMigrateChatHistory() {
            const saved = localStorage.getItem('chatHistory');
            if (!saved) {
                chatHistory = [];
                return;
            }
            
            try {
                const data = JSON.parse(saved);
                if (data.length === 0) {
                    chatHistory = [];
                    return;
                }
                
                // 检查是否是旧格式（合并的消息）
                const firstItem = data[0];
                if (firstItem.id && firstItem.content && !firstItem.content.includes('\n\n')) {
                    // 已经是气泡格式
                    chatHistory = data;
                    console.log('✅ 加载气泡格式:', chatHistory.length, '个气泡');
                } else {
                    // 旧格式，需要转换
                    console.log('🔄 检测到旧格式，开始转换...');
                    chatHistory = [];
                    
                    data.forEach(msg => {
                        const segments = msg.content.split('\n\n').filter(s => s.trim());
                        segments.forEach(segment => {
                            chatHistory.push({
                                id: 'bubble_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                                role: msg.role,
                                content: segment.trim(),
                                timestamp: msg.timestamp || new Date().toISOString()
                            });
                        });
                    });
                    
                    // 保存转换后的格式
                    localStorage.setItem('chatHistory', JSON.stringify(chatHistory));
                    console.log('✅ 转换完成:', chatHistory.length, '个气泡');
                }
            } catch (e) {
                console.error('❌ 加载失败:', e);
                chatHistory = [];
            }
            
            // 加载待总结缓冲区
            try {
                const savedPending = localStorage.getItem('pendingSummaryBubbles');
                if (savedPending) {
                    pendingSummaryBubbles = JSON.parse(savedPending);
                    console.log('📝 待总结:', pendingSummaryBubbles.length, '个气泡');
                }
            } catch (e) {
                pendingSummaryBubbles = [];
            }
            
            // 加载长期记忆
            try {
                const savedMemory = localStorage.getItem('longTermMemory');
                if (savedMemory) {
                    longTermMemory = JSON.parse(savedMemory);
                    console.log('🧠 长期记忆已加载，事件数:', longTermMemory.important_events?.length || 0);
                }
            } catch (e) {
                console.error('❌ 长期记忆加载失败:', e);
            }
        })();
        
        // 保存到localStorage（带防抖）
        let saveDebounceTimer = null;
        function saveChatHistory() {
            // 清除之前的定时器
            if (saveDebounceTimer) {
                clearTimeout(saveDebounceTimer);
            }
            
            // 300ms后才真正保存，避免频繁写入
            saveDebounceTimer = setTimeout(() => {
                try {
                    localStorage.setItem('chatHistory', JSON.stringify(chatHistory));
                    localStorage.setItem('pendingSummaryBubbles', JSON.stringify(pendingSummaryBubbles));
                    localStorage.setItem('longTermMemory', JSON.stringify(longTermMemory));
                    console.log('💾 已保存聊天记录');
                } catch (e) {
                    console.error('❌ 保存失败:', e);
                }
            }, 300);
        }
        
        // 立即保存（不防抖，用于关键操作）
        function saveChatHistoryImmediate() {
            if (saveDebounceTimer) {
                clearTimeout(saveDebounceTimer);
                saveDebounceTimer = null;
            }
            try {
                localStorage.setItem('chatHistory', JSON.stringify(chatHistory));
                localStorage.setItem('pendingSummaryBubbles', JSON.stringify(pendingSummaryBubbles));
                localStorage.setItem('longTermMemory', JSON.stringify(longTermMemory));
                console.log('💾 已立即保存聊天记录');
            } catch (e) {
                console.error('❌ 保存失败:', e);
            }
        }
        
        /**
         * 导出所有数据
         */
        function exportAllData() {
            try {
                // 收集所有localStorage数据
                const allData = {
                    version: '1.0',
                    exportTime: new Date().toISOString(),
                    data: {}
                };
                
                // 遍历所有localStorage键
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    const value = localStorage.getItem(key);
                    
                    // 尝试解析JSON，如果失败则保存原始字符串
                    try {
                        allData.data[key] = JSON.parse(value);
                    } catch {
                        allData.data[key] = value;
                    }
                }
                
                // 创建下载
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                const filename = `system_backup_${timestamp}.json`;
                const dataStr = JSON.stringify(allData, null, 2);
                
                // 检测是否为小米浏览器
                const isMiuiBrowser = /MiuiBrowser/i.test(navigator.userAgent);
                
                if (isMiuiBrowser) {
                    console.log('🔍 检测到小米浏览器，使用 Blob URL 方案');
                    
                    try {
                        const blob = new Blob([dataStr], { type: 'text/plain;charset=utf-8' });
                        const url = URL.createObjectURL(blob);
                        
                        alert('即将在新窗口打开系统备份\n\n包含 ' + Object.keys(allData.data).length + ' 个数据项\n\n保存方法：\n1. 在新页面点击"⋮"\n2. 选择"保存网页"\n3. 改名为：' + filename);
                        
                        const newWindow = window.open(url, '_blank');
                        
                        if (!newWindow) {
                            alert('⚠️ 无法打开新窗口，请允许弹出窗口权限');
                        } else {
                            console.log('✅ 导出成功:', filename);
                            setTimeout(() => URL.revokeObjectURL(url), 60000);
                        }
                        return;
                    } catch (error) {
                        console.error('❌ Blob URL 方案失败:', error);
                        alert('导出失败：' + error.message);
                        return;
                    }
                }
                
                // 非小米浏览器：使用标准方案
                const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);
                
                const link = document.createElement('a');
                link.setAttribute('href', dataUri);
                link.setAttribute('download', filename);
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                console.log('✅ 导出成功:', filename);
                alert(`导出成功！\n\n文件名：${filename}\n包含 ${Object.keys(allData.data).length} 个数据项`);
                
            } catch (error) {
                console.error('❌ 导出失败:', error);
                alert('导出失败：' + error.message);
            }
        }

        /**
         * 导入所有数据
         */
        function importAllData(input) {
            const file = input.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const imported = JSON.parse(e.target.result);
                    
                    // 验证数据格式
                    if (!imported.data || typeof imported.data !== 'object') {
                        throw new Error('数据格式不正确');
                    }
                    
                    // 二次确认
                    const itemCount = Object.keys(imported.data).length;
                    const confirmed = confirm(
                        `确定要导入数据吗？\n\n` +
                        `导入文件：${file.name}\n` +
                        `导出时间：${new Date(imported.exportTime).toLocaleString('zh-CN')}\n` +
                        `数据项数：${itemCount} 个\n\n` +
                        `⚠️ 警告：这将完全替换当前所有数据！`
                    );
                    
                    if (!confirmed) {
                        input.value = ''; // 清空文件选择
                        return;
                    }
                    
                    // 再次确认
                    const doubleConfirmed = confirm('最后确认：真的要替换所有当前数据吗？此操作无法撤销！');
                    if (!doubleConfirmed) {
                        input.value = '';
                        return;
                    }
                    
                    // 清空当前localStorage
                    localStorage.clear();
                    
                    // 导入所有数据
                    let successCount = 0;
                    for (const [key, value] of Object.entries(imported.data)) {
                        try {
                            const valueStr = typeof value === 'string' ? value : JSON.stringify(value);
                            localStorage.setItem(key, valueStr);
                            successCount++;
                        } catch (error) {
                            console.warn(`⚠️ 导入键 "${key}" 失败:`, error);
                        }
                    }
                    
                    console.log(`✅ 导入完成: ${successCount}/${itemCount} 项成功`);
                    
                    // 清空文件选择
                    input.value = '';
                    
                    // 提示并刷新
                    alert(`导入成功！\n\n成功导入 ${successCount} 个数据项\n页面将自动刷新...`);
                    
                    // 延迟刷新，让用户看到提示
                    setTimeout(() => {
                        window.location.reload();
                    }, 500);
                    
                } catch (error) {
                    console.error('❌ 导入失败:', error);
                    alert('导入失败：' + error.message);
                    input.value = '';
                }
            };
            
            reader.onerror = function() {
                alert('文件读取失败');
                input.value = '';
            };
            
            reader.readAsText(file);
        }
        
        // 转换为API格式（合并相邻同role的消息）
        function convertToAPIFormat(bubbles) {
            if (!bubbles || bubbles.length === 0) return [];
            const apiMessages = [];
            let currentMessage = null;
            
            // 清洗内容：移除历史里残留的原始钱包标记（避免污染上下文）
            function cleanWalletTags(content) {
                return content
                    .replace(/\[收款[:：]\d+(?:\.\d{1,2})?\]/g, '')
                    .replace(/\[退回[:：]\d+(?:\.\d{1,2})?\]/g, '')
                    .trim();
            }

            bubbles.forEach(bubble => {
                const cleanContent = cleanWalletTags(bubble.content);
                if (!cleanContent) return; // 跳过清洗后为空的气泡
                if (!currentMessage || currentMessage.role !== bubble.role) {
                    if (currentMessage) apiMessages.push(currentMessage);
                    currentMessage = {
                        role: bubble.role,
                        content: cleanContent,
                        timestamp: bubble.timestamp
                    };
                } else {
                    currentMessage.content += '\n\n' + cleanContent;
                }
            });
            
            if (currentMessage) apiMessages.push(currentMessage);
            return apiMessages;
        }
        
        /**
         * 向前回溯，确保第一条消息是完整的
         * @param {Array} bubbles - 当前的气泡列表
         * @param {Array} fullHistory - 完整的chatHistory
         * @returns {Array} - 补全后的气泡列表
         */
        function extendBackward(bubbles, fullHistory) {
            if (!bubbles || bubbles.length === 0) return bubbles;
            
            const firstBubble = bubbles[0];
            const firstId = firstBubble.id;
            const firstRole = firstBubble.role;
            
            // 在完整历史中找到第一条的位置
            const firstIndex = fullHistory.findIndex(b => b.id === firstId);
            if (firstIndex <= 0) return bubbles; // 已经是最开始了
            
            // 向前查找同role的消息
            const prependBubbles = [];
            for (let i = firstIndex - 1; i >= 0; i--) {
                if (fullHistory[i].role === firstRole) {
                    prependBubbles.unshift(fullHistory[i]);
                } else {
                    break; // 遇到不同角色，停止
                }
            }
            
            if (prependBubbles.length > 0) {
                console.log('📍 向前回溯：补充了', prependBubbles.length, '条', firstRole, '消息');
                return [...prependBubbles, ...bubbles];
            }
            
            return bubbles;
        }
        
        /**
         * 向后延伸，确保最后一条消息是完整的
         * @param {Array} bubbles - 当前的气泡列表
         * @param {Array} fullHistory - 完整的chatHistory
         * @returns {Array} - 补全后的气泡列表
         */
        function extendForward(bubbles, fullHistory) {
            if (!bubbles || bubbles.length === 0) return bubbles;
            
            const lastBubble = bubbles[bubbles.length - 1];
            const lastId = lastBubble.id;
            const lastRole = lastBubble.role;
            
            // 在完整历史中找到最后一条的位置
            const lastIndex = fullHistory.findIndex(b => b.id === lastId);
            if (lastIndex === -1 || lastIndex === fullHistory.length - 1) return bubbles; // 已经是最末尾了
            
            // 向后查找同role的消息
            const appendBubbles = [];
            for (let i = lastIndex + 1; i < fullHistory.length; i++) {
                if (fullHistory[i].role === lastRole) {
                    appendBubbles.push(fullHistory[i]);
                } else {
                    break; // 遇到不同角色，停止
                }
            }
            
            if (appendBubbles.length > 0) {
                console.log('📍 向后延伸：补充了', appendBubbles.length, '条', lastRole, '消息');
                return [...bubbles, ...appendBubbles];
            }
            
            return bubbles;
        }
        
        /**
         * 转换为API格式，智能合并消息
         * - 相邻同role且时间差<1分钟：正常合并
         * - 相邻同role但时间差≥1分钟：合并但每段保留时间戳
         * - 等待期间的消息组：加前缀标记
         */
        function convertToAPIFormatWithPending(bubbles) {
            if (!bubbles || bubbles.length === 0) return [];
            
            const TIME_THRESHOLD = 60 * 1000; // 1分钟的毫秒数
            
            // 1. 分离pending和非pending消息
            const nonPendingBubbles = bubbles.filter(b => !b.isPending);
            const pendingBubbles = bubbles.filter(b => b.isPending);
            
            console.log('🔍 分离消息：非pending', nonPendingBubbles.length, '条，pending', pendingBubbles.length, '条');
            
            // 2. 处理非pending消息（正常合并逻辑）
            const apiMessages = [];
            let currentMessage = null;
            let currentGroupBubbles = [];
            let hasLargeTimeDiff = false;
            
            nonPendingBubbles.forEach(bubble => {
                if (!currentMessage || currentMessage.role !== bubble.role) {
                    // 角色变化，保存当前消息
                    if (currentMessage) {
                        // 如果有大时间差，给第一条也加时间戳
                        if (hasLargeTimeDiff && currentGroupBubbles.length > 1) {
                            const firstTimeStr = new Date(currentGroupBubbles[0].timestamp).toLocaleString('zh-CN', {
                                year: 'numeric', month: '2-digit', day: '2-digit',
                                hour: '2-digit', minute: '2-digit', hour12: false
                            }).replace(/\//g, '-');
                            currentMessage.content = '[' + firstTimeStr + '] ' + currentMessage.content;
                        }
                        apiMessages.push(currentMessage);
                    }
                    
                    // 开始新消息
                    currentMessage = {
                        role: bubble.role,
                        content: bubble.content,
                        timestamp: bubble.timestamp
                    };
                    currentGroupBubbles = [bubble];
                    hasLargeTimeDiff = false;
                } else {
                    // 同角色，检查时间差
                    const lastBubble = currentGroupBubbles[currentGroupBubbles.length - 1];
                    const timeDiff = new Date(bubble.timestamp) - new Date(lastBubble.timestamp);
                    
                    if (timeDiff >= TIME_THRESHOLD) {
                        // 时间差>=1分钟，合并但保留时间戳
                        hasLargeTimeDiff = true;
                        const timeStr = new Date(bubble.timestamp).toLocaleString('zh-CN', {
                            year: 'numeric', month: '2-digit', day: '2-digit',
                            hour: '2-digit', minute: '2-digit', hour12: false
                        }).replace(/\//g, '-');
                        currentMessage.content += '\n[' + timeStr + '] ' + bubble.content;
                    } else {
                        // 时间差<1分钟，正常合并
                        currentMessage.content += '\n\n' + bubble.content;
                    }
                    
                    currentGroupBubbles.push(bubble);
                }
            });
            
            // 保存最后一条非pending消息
            if (currentMessage) {
                if (hasLargeTimeDiff && currentGroupBubbles.length > 1) {
                    const firstTimeStr = new Date(currentGroupBubbles[0].timestamp).toLocaleString('zh-CN', {
                        year: 'numeric', month: '2-digit', day: '2-digit',
                        hour: '2-digit', minute: '2-digit', hour12: false
                    }).replace(/\//g, '-');
                    currentMessage.content = '[' + firstTimeStr + '] ' + currentMessage.content;
                }
                apiMessages.push(currentMessage);
            }
            
            // 3. 处理pending消息 - 全部合并成一条，放在最后
            if (pendingBubbles.length > 0) {
                console.log('✅ 合并', pendingBubbles.length, '条pending消息到最后');
                
                let pendingContent = '';
                let pendingGroupBubbles = [];
                let pendingHasLargeTimeDiff = false;
                
                pendingBubbles.forEach((bubble, index) => {
                    if (index === 0) {
                        pendingContent = bubble.content;
                        pendingGroupBubbles.push(bubble);
                    } else {
                        // 检查时间差
                        const lastBubble = pendingGroupBubbles[pendingGroupBubbles.length - 1];
                        const timeDiff = new Date(bubble.timestamp) - new Date(lastBubble.timestamp);
                        
                        if (timeDiff >= TIME_THRESHOLD) {
                            // 时间差>=1分钟，加时间戳
                            pendingHasLargeTimeDiff = true;
                            const timeStr = new Date(bubble.timestamp).toLocaleString('zh-CN', {
                                year: 'numeric', month: '2-digit', day: '2-digit',
                                hour: '2-digit', minute: '2-digit', hour12: false
                            }).replace(/\//g, '-');
                            pendingContent += '\n[' + timeStr + '] ' + bubble.content;
                        } else {
                            // 时间差<1分钟，正常合并
                            pendingContent += '\n\n' + bubble.content;
                        }
                        
                        pendingGroupBubbles.push(bubble);
                    }
                });
                
                // 如果有大时间差，给第一条也加时间戳
                if (pendingHasLargeTimeDiff && pendingGroupBubbles.length > 1) {
                    const firstTimeStr = new Date(pendingGroupBubbles[0].timestamp).toLocaleString('zh-CN', {
                        year: 'numeric', month: '2-digit', day: '2-digit',
                        hour: '2-digit', minute: '2-digit', hour12: false
                    }).replace(/\//g, '-');
                    pendingContent = '[' + firstTimeStr + '] ' + pendingContent;
                }
                
                // 加上[在等待回复期间补充发送]前缀
                pendingContent = '[在等待回复期间补充发送] ' + pendingContent;
                
                // 添加到最后
                apiMessages.push({
                    role: 'user',
                    content: pendingContent,
                    timestamp: pendingBubbles[0].timestamp
                });
            }
            
            return apiMessages;
        }
        // ==========================================
        
        //let chatHistory = JSON.parse(localStorage.getItem('chatHistory')) || [];//试图调取之前的聊天记录
        //let chatHistory = [];  
        // 当前的数据模型（全局），避免频繁从 DOM 读取导致不一致
        let currentLayout = null;

        const chatContainer = document.getElementById('chat-container');
        const userInput = document.getElementById('user-input');
        const systemPromptArea = document.getElementById('system-prompt');
        
        // 输入框工具按钮（开发中的功能）
        const voiceBtn = document.getElementById('voice-btn');
        const emojiBtn = document.getElementById('emoji-btn');
        const plusBtn = document.getElementById('plus-btn');
        
        // 工具按钮点击事件（占位）
        if (voiceBtn) {
            voiceBtn.onclick = () => {
                showToast('语音输入功能开发中...');
            };
        }
        
        if (emojiBtn) {
            emojiBtn.onclick = () => {
                showToast('表情包功能开发中...');
            };
        }
        
        if (plusBtn) {
            plusBtn.onclick = (e) => {
                e.stopPropagation();
                const panel = document.getElementById('plus-menu-panel');
                panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
            };
            // 点击其他地方关闭
            document.addEventListener('click', (e) => {
                const panel = document.getElementById('plus-menu-panel');
                if (panel && !panel.contains(e.target) && e.target !== plusBtn && !plusBtn.contains(e.target)) {
                    panel.style.display = 'none';
                }
            });
        }

        // 播放轻量级音效
        function playSnapSound() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                osc.connect(gain);
                gain.connect(audioContext.destination);
                
                osc.frequency.setValueAtTime(800, audioContext.currentTime);
                osc.frequency.setValueAtTime(600, audioContext.currentTime + 0.05);
                gain.gain.setValueAtTime(0.1, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                
                osc.start(audioContext.currentTime);
                osc.stop(audioContext.currentTime + 0.1);
            } catch (e) {
                // 浏览器不支持或用户禁用音频
            }
        }

        // 加载和保存桌面布局
        function loadDesktopLayout() {
            const saved = localStorage.getItem('desktopLayout');
            if (saved) {
                try {
                    const parsed = JSON.parse(saved);
                    // ensure we have normalized arrays: desktop length 12, dock length 3
                    const def = getDefaultLayout();
                    const out = { desktop: Array.from(def.desktop), dock: Array.from(def.dock) };

                    // Preserve explicit nulls from saved layout. If parsed provides entries, copy them
                    if (parsed.desktop && Array.isArray(parsed.desktop)) {
                        for (let i = 0; i < out.desktop.length; i++) {
                            if (i < parsed.desktop.length) {
                                // allow parsed.desktop[i] to be null (explicitly empty)
                                out.desktop[i] = parsed.desktop[i];
                            }
                        }
                    }

                    if (parsed.dock && Array.isArray(parsed.dock)) {
                        for (let i = 0; i < out.dock.length; i++) {
                            if (i < parsed.dock.length) {
                                out.dock[i] = parsed.dock[i];
                            }
                        }
                    }


                    // If parsed layout already contains the wechat-app somewhere (desktop or dock),
                    // ensure we do not re-add the default wechat into slot 0 (avoid duplicate)
                    const existsInDesktop = out.desktop.some((it, idx) => it && it.id === 'wechat-app' && idx !== 0);
                    const existsInDock = out.dock.some(it => it && it.id === 'wechat-app');
                    if (existsInDesktop || existsInDock) {
                        if (out.desktop[0] && out.desktop[0].id === 'wechat-app') {
                            out.desktop[0] = null;
                        }
                    }

                    // Normalize items: if an item exists but lacks emoji or label, fill from defaults by id
                    const defaultLayout = getDefaultLayout();
                    function fillDefaultsForItem(item) {
                        if (!item) return item;
                        const defMatch = defaultLayout.desktop.concat(defaultLayout.dock).find(d => d && d.id === item.id);
                        if (defMatch) {
                            if (!item.emoji) item.emoji = defMatch.emoji || item.emoji;
                            if (!item.label) item.label = defMatch.label || item.label;
                        }
                        return item;
                    }
                    out.desktop = out.desktop.map(item => (item && item.id) ? fillDefaultsForItem(item) : null);
                    out.dock = out.dock.map(item => (item && item.id) ? fillDefaultsForItem(item) : null);

                    return out;
                } catch (e) {
                    return getDefaultLayout();
                }
            }
            return getDefaultLayout();
        }

        function getDefaultLayout() {
            // desktop has 12 fixed slots (some may be null), dock has 3 fixed slots
            const desktop = new Array(12).fill(null);
            desktop[0] = { id: 'wechat-app', emoji: '💬', label: '仿微信', clickHandler: 'openChat' };
            const dock = [
                { id: 'dock-preset', emoji: '🧰', label: '预设', clickHandler: 'openPreset' },
                { id: 'dock-worldbook', emoji: '🌐', label: '世界书', clickHandler: 'openWorldBook' },
                { id: 'dock-api', emoji: '⚙️', label: 'API 设置', clickHandler: 'openApiSettings' }
            ];
            return { desktop, dock };
        }

        function saveDesktopLayout(layout) {
            localStorage.setItem('desktopLayout', JSON.stringify(layout));
        }

        function getCurrentLayout() {
            // Build a layout object by reading slot-indexed slots (supports empty slots)
            const desktop = new Array(12).fill(null);
            const desktopGrid = document.getElementById('desktop-grid');
            if (desktopGrid) {
                desktopGrid.querySelectorAll('.desktop-slot').forEach(slot => {
                    const idx = parseInt(slot.getAttribute('data-slot-index'));
                    const iconEl = slot.querySelector('[data-icon-id]');
                    if (!isNaN(idx)) {
                        if (iconEl) {
                            const id = iconEl.getAttribute('data-icon-id');
                            const emoji = iconEl.querySelector('.app-icon')?.textContent || iconEl.textContent || '';
                            const label = iconEl.querySelector('.app-label')?.textContent || iconEl.getAttribute('title') || '';
                            desktop[idx] = { id, emoji, label, clickHandler: getClickHandlerByType(id, 'desktop') };
                        } else {
                            desktop[idx] = null;
                        }
                    }
                });
            }

            const dock = new Array(3).fill(null);
            const dockInner = document.querySelector('.dock-inner');
            if (dockInner) {
                dockInner.querySelectorAll('.dock-slot').forEach(slot => {
                    const idx = parseInt(slot.getAttribute('data-slot-index'));
                    const iconEl = slot.querySelector('[data-icon-id]');
                    if (!isNaN(idx)) {
                        if (iconEl) {
                            const id = iconEl.getAttribute('data-icon-id');
                            const emoji = iconEl.textContent || '';
                            const label = iconEl.getAttribute('title') || '';
                            dock[idx] = { id, emoji, label, clickHandler: getClickHandlerByType(id, 'dock') };
                        } else {
                            dock[idx] = null;
                        }
                    }
                });
            }

            return { desktop, dock };
        }

        function getClickHandlerByType(id, type) {
            if (id.includes('wechat')) return 'openChat';
            if (id.includes('preset')) return 'openPreset';
            if (id.includes('worldbook')) return 'openWorldBook';
            if (id.includes('api')) return 'openApiSettings';
            return 'none';
        }

        // 确保 Dock 的三个固定图标在 Dock 区，如果它们被误移到桌面则恢复到 Dock
        function ensureDockItemsInDock(layout) {
            if (!layout) return;
            const dockIds = ['dock-preset', 'dock-worldbook', 'dock-api'];

            // Helper: find index by id in array, return -1 if not found
            function findIndexById(arr, id) {
                return arr.findIndex(item => item && item.id === id);
            }

            // For each required dock id, ensure it's in layout.dock; if found on desktop, move it back.
            for (const id of dockIds) {
                const dockIdx = findIndexById(layout.dock, id);
                if (dockIdx !== -1) {
                    // already present in dock; remove duplicates from desktop
                    const dIdx = findIndexById(layout.desktop, id);
                    if (dIdx !== -1) layout.desktop[dIdx] = null;
                    continue;
                }

                // Not present in dock: search desktop
                const desktopIdx = findIndexById(layout.desktop, id);
                if (desktopIdx !== -1) {
                    // find first empty dock slot
                    const emptyDockIdx = layout.dock.findIndex(item => item === null || item === undefined);
                    if (emptyDockIdx !== -1) {
                        // move it to empty dock slot
                        layout.dock[emptyDockIdx] = layout.desktop[desktopIdx];
                        layout.desktop[desktopIdx] = null;
                    } else {
                        // no empty dock slot: swap with first dock slot
                        const tmp = layout.dock[0];
                        layout.dock[0] = layout.desktop[desktopIdx];
                        layout.desktop[desktopIdx] = tmp || null;
                    }
                    continue;
                }

                // If not found anywhere (missing), fill with default from getDefaultLayout()
                const def = getDefaultLayout();
                const firstEmpty = layout.dock.findIndex(item => item === null || item === undefined);
                if (firstEmpty !== -1) {
                    layout.dock[firstEmpty] = def.dock[dockIds.indexOf(id)] || null;
                } else {
                    // replace first dock slot as fallback
                    layout.dock[0] = def.dock[dockIds.indexOf(id)] || layout.dock[0];
                }
            }

            // Save normalized layout back
            currentLayout = layout;
            saveDesktopLayout(currentLayout);
        }

        // 确保 仿微信 图标存在于桌面；若被误移到 Dock，则移回桌面优先放入第一个空位
        function ensureWechatOnDesktop(layout) {
            if (!layout) return;
            // 如果 wechat 已在 desktop 任意位置，保持不变
            const dIdx = layout.desktop.findIndex(it => it && it.id === 'wechat-app');
            if (dIdx !== -1) return;

            // 如果 wechat 在 dock 中，移回桌面第一个空位
            const kIdx = layout.dock.findIndex(it => it && it.id === 'wechat-app');
            if (kIdx !== -1) {
                // remove from dock
                const item = layout.dock[kIdx];
                layout.dock[kIdx] = null;

                // place into first empty desktop slot
                const empty = layout.desktop.findIndex(it => it === null || it === undefined);
                if (empty !== -1) {
                    layout.desktop[empty] = item;
                } else {
                    // no empty desktop slot: replace slot 0
                    layout.desktop[0] = item;
                }
                currentLayout = layout;
                saveDesktopLayout(currentLayout);
            }
            // 如果既不在 desktop，也不在 dock，则创建默认的仿微信放入第一个空位
            const stillMissing = !layout.desktop.some(it => it && it.id === 'wechat-app') && !layout.dock.some(it => it && it.id === 'wechat-app');
            if (stillMissing) {
                const def = getDefaultLayout();
                const empty = layout.desktop.findIndex(it => it === null || it === undefined);
                const item = def.desktop[0];
                if (empty !== -1) {
                    layout.desktop[empty] = item;
                } else {
                    layout.desktop[0] = item;
                }
                currentLayout = layout;
                saveDesktopLayout(currentLayout);
            }
        }

        function renderDesktop(layout) {
            const desktopGrid = document.getElementById('desktop-grid');
            desktopGrid.innerHTML = '';
            // Ensure we render exactly 12 slots
            for (let i = 0; i < 12; i++) {
                const slot = document.createElement('div');
                slot.className = 'desktop-slot';
                slot.setAttribute('data-slot-index', String(i));
                slot.style.display = 'flex';
                slot.style.flexDirection = 'column';
                slot.style.alignItems = 'center';
                slot.setAttribute('draggable', 'false');

                const icon = layout.desktop && layout.desktop[i] ? layout.desktop[i] : null;
                if (icon) {
                    const appWrapper = document.createElement('div');
                    appWrapper.setAttribute('data-icon-id', icon.id);
                    appWrapper.setAttribute('draggable', 'false');

                    const appIcon = document.createElement('div');
                    appIcon.className = 'app-icon';
                    appIcon.textContent = icon.emoji;

                    const appLabel = document.createElement('div');
                    appLabel.className = 'app-label';
                    appLabel.textContent = icon.label;

                    appWrapper.appendChild(appIcon);
                    appWrapper.appendChild(appLabel);
                    slot.appendChild(appWrapper);
                }

                desktopGrid.appendChild(slot);
            }
        }

        function renderDock(layout) {
            const dockInner = document.querySelector('.dock-inner');
            dockInner.innerHTML = '';
            // render exactly 3 dock slots
            for (let i = 0; i < 3; i++) {
                const slot = document.createElement('div');
                slot.className = 'dock-slot';
                slot.setAttribute('data-slot-index', String(i));

                const icon = layout.dock && layout.dock[i] ? layout.dock[i] : null;
                if (icon) {
                    const dockItem = document.createElement('div');
                    dockItem.className = 'dock-item';
                    dockItem.setAttribute('data-icon-id', icon.id);
                    dockItem.textContent = icon.emoji;
                    dockItem.setAttribute('title', icon.label);
                    slot.appendChild(dockItem);
                }

                dockInner.appendChild(slot);
            }
        }

        // 初始化加载配置和历史记录
        document.addEventListener('DOMContentLoaded', () => {
            loadSettings();
            // 将默认Prompt显示在设置界面
            systemPromptArea.value = config.systemPrompt; 
            // 启用或禁用发送按钮
            
            
            // 更新聊天对象名称
            updateChatName();

            // 加载并渲染桌面布局（保存在全局 currentLayout）
            currentLayout = loadDesktopLayout();
            // 确保 仿微信 在桌面（如果误在 Dock 中则恢复），然后恢复 Dock 的默认图标
            ensureWechatOnDesktop(currentLayout);
            ensureDockItemsInDock(currentLayout);
            renderDesktop(currentLayout);
            renderDock(currentLayout);

            // 注册所有图标的点击事件（不会重复注册拖拽监听）
            initializeIconInteractions();
            // 启用拖拽（只注册一次）
            enableDragAndDrop();
            
            // 初始化底部导航栏
            initializeBottomNav();
            
            // 初始化消息通知
            initializeMessageNotification();
        });

        function initializeIconInteractions() {
            const allIcons = document.querySelectorAll('[data-icon-id]');
            const iconHandlers = {
                'wechat-app': () => { loadCharactersList(); renderCharactersList(); showPage('chat-list-page'); },
                'dock-api': () => showPage('system-settings-page'),
                'dock-preset': () => alert('预设 (占位)'),
                'dock-worldbook': () => { openSettings(); setTimeout(() => { document.getElementById('wb-entry-list')?.scrollIntoView({behavior:'smooth'}); }, 400); }
            };
            allIcons.forEach(icon => {
                const id = icon.getAttribute('data-icon-id');
                const handler = iconHandlers[id];
                if (handler) {
                    icon.onclick = handler;
                } else {
                    icon.onclick = null;
                }
            });
        }

        function enableDragAndDrop() {
            // 确保只注册一次全局拖拽监听
            if (window.__miniphone_drag_enabled) return;
            window.__miniphone_drag_enabled = true;
            let draggedIcon = null;
            let clone = null;
            let isDragging = false;
            let longPressTimer = null;
            let startPos = { x: 0, y: 0 };

            const desktopGrid = document.getElementById('desktop-grid');
            const dockInner = document.querySelector('.dock-inner');
            const dropZones = [
                { element: desktopGrid, type: 'desktop' },
                { element: dockInner, type: 'dock' }
            ];

            function getDropZoneAtPoint(clientX, clientY) {
                // 优先使用 elementFromPoint，通常更可靠（clone 已设置 pointer-events: none）
                try {
                    const elem = document.elementFromPoint(clientX, clientY);
                    console.log('elementFromPoint result:', elem && elem.className ? elem.className : elem);
                    if (elem) {
                        const dockEl = elem.closest('.dock-inner');
                        if (dockEl) {
                            console.log('elementFromPoint detected dock-inner');
                            return dropZones.find(z => z.type === 'dock');
                        }
                        const desktopEl = elem.closest('#desktop-grid');
                        if (desktopEl) {
                            console.log('elementFromPoint detected desktop-grid');
                            return dropZones.find(z => z.type === 'desktop');
                        }
                    }
                } catch (e) {
                    console.log('elementFromPoint failed:', e);
                }

                // 如果 elementFromPoint 没有命中，再使用边界检测（扩大容差到 150px）
                const tolerance = 150;
                const desktopZone = dropZones.find(z => z.type === 'desktop');
                const dockZone = dropZones.find(z => z.type === 'dock');
                const desktopRect = desktopZone ? desktopZone.element.getBoundingClientRect() : null;
                const dockRect = dockZone ? dockZone.element.getBoundingClientRect() : null;

                console.log('Fallback bounding rects check. Window size:', window.innerWidth, window.innerHeight);
                if (desktopRect) console.log('Desktop rect:', { left: desktopRect.left, top: desktopRect.top, right: desktopRect.right, bottom: desktopRect.bottom, width: desktopRect.width, height: desktopRect.height });
                if (dockRect) console.log('Dock rect:', { left: dockRect.left, top: dockRect.top, right: dockRect.right, bottom: dockRect.bottom, width: dockRect.width, height: dockRect.height });

                for (const zone of dropZones) {
                    const rect = zone.element.getBoundingClientRect();
                    const leftCheck = clientX >= rect.left - tolerance;
                    const rightCheck = clientX <= rect.right + tolerance;
                    const topCheck = clientY >= rect.top - tolerance;
                    const bottomCheck = clientY <= rect.bottom + tolerance;

                    console.log(`Checking ${zone.type}: left=${rect.left}, right=${rect.right}, top=${rect.top}, bottom=${rect.bottom}, visible=${rect.width>0&&rect.height>0}`, { leftCheck, rightCheck, topCheck, bottomCheck });

                    if (leftCheck && rightCheck && topCheck && bottomCheck) {
                        console.log('Drop zone found by rect:', zone.type);
                        return zone;
                    }
                }

                // 继续回退：如果 Y 坐标在 dock 上方较近，则判为 dock；否则判为 desktop
                if (dockRect && clientY >= dockRect.top - 80) {
                    console.log('Fallback heuristic: choose dock by Y proximity');
                    return dropZones.find(z => z.type === 'dock');
                }
                if (desktopRect && clientY <= desktopRect.bottom + 80) {
                    console.log('Fallback heuristic: choose desktop by Y proximity');
                    return dropZones.find(z => z.type === 'desktop');
                }

                console.log('No drop zone found for point:', clientX, clientY);
                return null;
            }

            function findNearestDropSlot(clientX, clientY, zone) {
                // zone.element contains slot wrappers (desktop-slot or dock-slot)
                const slotSelector = zone.type === 'desktop' ? '.desktop-slot' : '.dock-slot';
                const slots = Array.from(zone.element.querySelectorAll(slotSelector));

                // first try: find a slot whose rect contains the point
                for (const slot of slots) {
                    const rect = slot.getBoundingClientRect();
                    if (clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom) {
                        return slot;
                    }
                }

                // fallback: nearest by center, but skip the slot that currently contains the dragged icon
                let nearest = null;
                let minDist = Infinity;
                const draggedId = draggedIcon ? draggedIcon.getAttribute('data-icon-id') : null;
                for (const slot of slots) {
                    const iconEl = slot.querySelector('[data-icon-id]');
                    if (iconEl && draggedId && iconEl.getAttribute('data-icon-id') === draggedId) continue;
                    const rect = slot.getBoundingClientRect();
                    const cx = rect.left + rect.width / 2;
                    const cy = rect.top + rect.height / 2;
                    const dist = Math.hypot(clientX - cx, clientY - cy);
                    if (dist < minDist) {
                        minDist = dist;
                        nearest = slot;
                    }
                }
                return nearest;
            }

            // Move (or swap) icons based on slot indices in the fixed-slot layout
            function moveIconToSlot(sourceId, targetZoneType, targetIndex) {
                if (!currentLayout) currentLayout = getCurrentLayout();
                const layout = currentLayout;

                function findInLayout(id) {
                    const dIndex = layout.desktop.findIndex(i => i && i.id === id);
                    if (dIndex !== -1) return { zone: 'desktop', index: dIndex };
                    const kIndex = layout.dock.findIndex(i => i && i.id === id);
                    if (kIndex !== -1) return { zone: 'dock', index: kIndex };
                    return null;
                }

                const src = findInLayout(sourceId);
                if (!src) {
                    console.log('moveIconToSlot: source not found', sourceId);
                    return false;
                }

                // validate target zone/index
                const tZone = targetZoneType === 'desktop' ? 'desktop' : 'dock';
                const maxIndex = tZone === 'desktop' ? layout.desktop.length - 1 : layout.dock.length - 1;
                if (isNaN(targetIndex) || targetIndex < 0 || targetIndex > maxIndex) {
                    console.log('moveIconToSlot: invalid target index', targetIndex);
                    return false;
                }

                // Disallow any cross-zone moves: dock items must stay in dock; desktop items must stay on desktop.
                if (src.zone !== tZone) {
                    console.log('moveIconToSlot: cross-zone moves are not allowed', src.zone, '->', tZone);
                    return false;
                }

                const sArr = layout[src.zone];
                const tArr = layout[tZone];
                const sObj = sArr[src.index];
                const tObj = tArr[targetIndex];

                if (src.zone === tZone && src.index === targetIndex) {
                    console.log('moveIconToSlot: source and target are the same slot');
                    return false;
                }

                // if target is occupied -> swap; else move
                if (tObj) {
                    // swap
                    sArr[src.index] = tObj;
                    tArr[targetIndex] = sObj;
                } else {
                    // move: place source into target, clear source
                    tArr[targetIndex] = sObj;
                    sArr[src.index] = null;
                }

                currentLayout = layout;
                saveDesktopLayout(currentLayout);
                renderDesktop(currentLayout);
                renderDock(currentLayout);
                initializeIconInteractions();
                console.log('moveIconToSlot: moved', sourceId, 'to', tZone, targetIndex);
                return true;
            }

            // 单一的鼠标按下事件处理
            document.addEventListener('mousedown', (ev) => {
                // Try to find the exact icon element; if not found, check if click was inside a desktop-slot and
                // then pick the slot's icon (helps when slot elements are clicked rather than the icon wrapper).
                let icon = ev.target.closest('[data-icon-id]');
                if (!icon) {
                    const slot = ev.target.closest('.desktop-slot');
                    if (slot) {
                        icon = slot.querySelector('[data-icon-id]');
                    }
                }
                if (!icon) return;

                // Do not allow starting a drag from dock slots (keep dock icons fixed)
                if (icon.closest('.dock-slot')) return;

                ev.preventDefault();
                longPressTimer = setTimeout(() => {
                    draggedIcon = icon;
                    isDragging = true;
                    startPos = { x: ev.clientX, y: ev.clientY };

                    console.log('Starting drag:', draggedIcon.getAttribute('data-icon-id'));

                    // 创建浮动克隆
                    clone = icon.cloneNode(true);
                    clone.style.position = 'fixed';
                    clone.style.left = (ev.clientX - 28) + 'px';
                    clone.style.top = (ev.clientY - 28) + 'px';
                    clone.style.zIndex = 9999;
                    clone.style.pointerEvents = 'none';
                    clone.classList.add('dragging');
                    clone.removeAttribute('data-icon-id');
                    document.body.appendChild(clone);
                }, 450);
            }, true);

            // 单一的鼠标移动事件处理
            document.addEventListener('mousemove', (ev) => {
                if (!isDragging || !clone) return;
                clone.style.left = (ev.clientX - 28) + 'px';
                clone.style.top = (ev.clientY - 28) + 'px';
            }, true);

            // 单一的鼠标抬起事件处理
            document.addEventListener('mouseup', (ev) => {
                clearTimeout(longPressTimer);
                longPressTimer = null;

                if (isDragging && clone && draggedIcon) {
                    console.log('Ending drag at:', ev.clientX, ev.clientY);
                    
                    const targetZone = getDropZoneAtPoint(ev.clientX, ev.clientY);
                    const targetIcon = targetZone ? findNearestDropSlot(ev.clientX, ev.clientY, targetZone) : null;

                    console.log('Target zone:', targetZone?.type, 'Target icon:', targetIcon?.getAttribute('data-icon-id'));

                    if (targetIcon) {
                        // determine original slot of draggedIcon
                        const originalSlot = draggedIcon.closest('.desktop-slot, .dock-slot');
                        const targetSlot = targetIcon;
                        let sameSlot = false;
                        if (originalSlot && targetSlot) {
                            const oIdx = originalSlot.getAttribute('data-slot-index');
                            const tIdx = targetSlot.getAttribute('data-slot-index');
                            const oZone = originalSlot.classList.contains('desktop-slot') ? 'desktop' : 'dock';
                            const tZone = targetSlot.classList.contains('desktop-slot') ? 'desktop' : 'dock';
                            if (oIdx === tIdx && oZone === tZone) sameSlot = true;
                        }

                        if (!sameSlot) {
                            const draggedId = draggedIcon.getAttribute('data-icon-id');
                            const targetIndex = parseInt(targetSlot.getAttribute('data-slot-index'));
                            const ok = moveIconToSlot(draggedId, targetZone.type, targetIndex);
                            if (clone && clone.parentNode) clone.parentNode.removeChild(clone);
                            if (ok) playSnapSound();
                        } else {
                            if (clone && clone.parentNode) clone.parentNode.removeChild(clone);
                        }
                    } else {
                        console.log('No valid target, canceling swap');
                        if (clone && clone.parentNode) clone.parentNode.removeChild(clone);
                    }
                }

                draggedIcon = null;
                clone = null;
                isDragging = false;
            }, true);

            // 触摸事件
            document.addEventListener('touchstart', (ev) => {
                const icon = ev.target.closest('[data-icon-id]');
                if (!icon) return;
                // Do not allow starting a touch-drag from dock slots (keep dock icons fixed)
                if (icon.closest('.dock-slot')) return;

                const t = ev.touches[0];
                longPressTimer = setTimeout(() => {
                    draggedIcon = icon;
                    isDragging = true;
                    startPos = { x: t.clientX, y: t.clientY };

                    clone = icon.cloneNode(true);
                    clone.style.position = 'fixed';
                    clone.style.left = (t.clientX - 28) + 'px';
                    clone.style.top = (t.clientY - 28) + 'px';
                    clone.style.zIndex = 9999;
                    clone.style.pointerEvents = 'none';
                    clone.classList.add('dragging');
                    clone.removeAttribute('data-icon-id');
                    document.body.appendChild(clone);
                }, 450);
            }, { passive: true, capture: true });

            document.addEventListener('touchmove', (ev) => {
                if (!isDragging || !clone) return;
                const t = ev.touches[0];
                if (t) {
                    clone.style.left = (t.clientX - 28) + 'px';
                    clone.style.top = (t.clientY - 28) + 'px';
                }
            }, { passive: true, capture: true });

            document.addEventListener('touchend', (ev) => {
                clearTimeout(longPressTimer);
                longPressTimer = null;

                if (isDragging && clone && draggedIcon) {
                    const t = ev.changedTouches[0];
                    if (t) {
                        const targetZone = getDropZoneAtPoint(t.clientX, t.clientY);
                        const targetSlot = targetZone ? findNearestDropSlot(t.clientX, t.clientY, targetZone) : null;

                        if (targetSlot) {
                            const originalSlot = draggedIcon.closest('.desktop-slot, .dock-slot');
                            let sameSlot = false;
                            if (originalSlot && targetSlot) {
                                const oIdx = originalSlot.getAttribute('data-slot-index');
                                const tIdx = targetSlot.getAttribute('data-slot-index');
                                const oZone = originalSlot.classList.contains('desktop-slot') ? 'desktop' : 'dock';
                                const tZone = targetSlot.classList.contains('desktop-slot') ? 'desktop' : 'dock';
                                if (oIdx === tIdx && oZone === tZone) sameSlot = true;
                            }
                            if (!sameSlot) {
                                const draggedId = draggedIcon.getAttribute('data-icon-id');
                                const targetIndex = parseInt(targetSlot.getAttribute('data-slot-index'));
                                const ok = moveIconToSlot(draggedId, targetZone.type, targetIndex);
                                if (clone && clone.parentNode) clone.parentNode.removeChild(clone);
                                if (ok) playSnapSound();
                            } else {
                                if (clone && clone.parentNode) clone.parentNode.removeChild(clone);
                            }
                        } else {
                            if (clone && clone.parentNode) clone.parentNode.removeChild(clone);
                        }
                    }
                }

                draggedIcon = null;
                clone = null;
                isDragging = false;
            }, { capture: true });
        }

        // --- 核心功能函数 ---

        /**
         * 加载本地存储的配置
         */
        function loadSettings() {
            // 【修复】加载全局配置（API配置等）
            const savedConfig = localStorage.getItem('aiChatConfig');
            if (savedConfig) {
                try {
                    const loadedConfig = JSON.parse(savedConfig);
                    // 只加载API相关的全局配置，不覆盖角色特定的配置
                    if (!currentCharacterId) {
                        // 如果没有选中角色，加载所有配置
                        Object.assign(config, loadedConfig);
                    } else {
                        // 如果有角色，只加载API配置（baseurl, apikey, modelname）
                        config.baseurl = loadedConfig.baseurl || config.baseurl;
                        config.apikey = loadedConfig.apikey || config.apikey;
                        config.modelname = loadedConfig.modelname || config.modelname;
                    }
                    console.log('📖 已加载全局配置 - API:', config.baseurl ? '✓' : '✗');
                } catch (e) {
                    console.error('❌ 加载配置失败:', e);
                }
            }
            
            // 多角色模式下,config已经在loadCharacterData中加载
            // 这里只需要填充UI即可
            
            // 显示角色标识
            if (currentCharacterId) {
                const character = charactersList.find(c => c.id === currentCharacterId);
                if (character) {
                    document.getElementById('character-identifier').textContent = character.name;
                }
            }
            
            // 填充设置页面的输入框
            document.getElementById('baseurl').value = config.baseurl || '';
            document.getElementById('apikey').value = config.apikey || '';
            
            // 加载模型下拉框
            const modelSelect = document.getElementById('modelname');
            const savedModel = config.modelname || 'gemini-2.5-pro';
            
            // 如果下拉框中没有当前保存的模型,添加它作为选项
            let modelExists = false;
            for (let i = 0; i < modelSelect.options.length; i++) {
                if (modelSelect.options[i].value === savedModel) {
                    modelExists = true;
                    break;
                }
            }
            
            if (!modelExists && savedModel) {
                const option = document.createElement('option');
                option.value = savedModel;
                option.textContent = savedModel;
                modelSelect.appendChild(option);
            }
            
            modelSelect.value = savedModel;
            document.getElementById('system-prompt').value = config.systemPrompt || '';
            
            // 加载昵称
            document.getElementById('user-nickname').value = config.userNickname || '我';
            document.getElementById('chat-name-input').value = config.aiNickname || 'AI助手';
            
            // 加载角色姓名(只读显示)
            if (currentCharacterId) {
                const character = charactersList.find(c => c.id === currentCharacterId);
                if (character) {
                    document.getElementById('character-name-input').value = character.name || '';
                }
            }
            
            // 更新聊天页面标题显示AI昵称
            document.getElementById('chat-name').textContent = config.aiNickname || 'AI助手';
            
            // 加载头像预览
            renderAvatar(document.getElementById('ai-avatar-preview-settings'), config.aiAvatar, 'ai', config.aiNickname ? config.aiNickname.substring(0, 1) : 'AI');
            renderAvatar(document.getElementById('user-avatar-preview-settings'), config.userAvatar, 'user', config.userNickname ? config.userNickname.substring(0, 1) : '我');
            document.getElementById('ai-avatar-remove-btn-settings').style.display = config.aiAvatar ? 'inline-block' : 'none';
            document.getElementById('user-avatar-remove-btn-settings').style.display = config.userAvatar ? 'inline-block' : 'none';
            
            // 【修复】从localStorage加载上下文窗口大小
            const contextWindowSize = localStorage.getItem('contextWindowSize') || '50';
            document.getElementById('context-window-size').value = contextWindowSize;
            
            // 【修复】从localStorage加载批量发送等待时间
            const batchWaitTime = localStorage.getItem('batchWaitTime') || '7';
            document.getElementById('batch-wait-time').value = batchWaitTime;
            
            // 加载API超时时间(全局)
            const apiTimeout = localStorage.getItem('apiTimeout') || '60';
            document.getElementById('api-timeout').value = apiTimeout;
            
            // 【修复】从localStorage加载长期记忆设置
            const autoSummaryInterval = localStorage.getItem('autoSummaryInterval') || '50';
            document.getElementById('auto-summary-interval').value = autoSummaryInterval;
            
            const maxImportantEvents = localStorage.getItem('maxImportantEvents') || '10';
            document.getElementById('max-important-events').value = maxImportantEvents;
            
            // 更新记忆状态显示
            updateMemoryStatus();
            
            console.log('📖 设置页面已刷新,显示当前角色配置');
        }

        /**
         * 加载聊天记录到界面
         */
        /*如果单次ai回复不拆分显示，可以用这个函数
        function loadHistoryUI() {
            const chatContainer = document.getElementById('chat-container');
            if (!chatContainer) return;

            // 1. 获取当前页面上已经显示的气泡数量
            // 假设每个消息都有 .message 类名
            const currentDisplayCount = chatContainer.querySelectorAll('.message').length;

            // 2. 获取数据数组的总长度
            const dataCount = chatHistory.length;

            // 🧐 情况 A：数据被清空了，或者比显示的还少（比如用户刚点过删除）
            if (dataCount < currentDisplayCount) {
                chatContainer.innerHTML = ''; // 这种情况下只能暴力清空
                if (dataCount === 0) {
                    displayMessage("你好！有什么想跟我聊聊的吗？我很期待。", "ai");
                    return;
                }
            }

            // 🧐 情况 B：数据比显示的多（增量渲染）
            // 我们只从索引为 currentDisplayCount 的地方开始渲染
            if (dataCount > currentDisplayCount) {
                const newMessages = chatHistory.slice(currentDisplayCount);
                
                newMessages.forEach(item => {
                    const displayRole = (item.role === 'assistant' || item.role === 'ai') ? 'ai' : 'user';
                    displayMessage(item.content, displayRole);
                });
            }

            // 始终滚动到底部
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }
       function loadHistoryUI() {
            const chatContainer = document.getElementById('chat-container');
            if (!chatContainer) return;

            // 暴力重置
            chatContainer.innerHTML = '';

            if (chatHistory.length === 0) {
                displayMessage("你好！有什么想跟我聊聊的吗？我很期待。", "ai");
                requestAnimationFrame(() => {
                    chatContainer.scrollTop = chatContainer.scrollHeight;
                });
                return;
            }

            // 完整渲染所有记录
            chatHistory.forEach(item => {
                const isAI = (item.role === 'assistant' || item.role === 'ai');
                if (isAI) {
                    const segments = item.content.split('\n\n');
                    segments.forEach(seg => {
                        if (seg.trim()) displayMessage(seg.trim(), 'ai');
                    });
                } else {
                    displayMessage(item.content, 'user');
                }
            });
            // 确保 DOM 完全渲染后再滚动
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    chatContainer.scrollTop = chatContainer.scrollHeight;
                    console.log('滚动完成:', chatContainer.scrollTop, chatContainer.scrollHeight);
                });
            });
        }

        function loadHistoryUI() {
            const chatContainer = document.getElementById('chat-container');
            if (!chatContainer) return;

            chatContainer.innerHTML = '';

            if (chatHistory.length === 0) {
                displayMessage("你好！有什么想跟我聊聊的吗？我很期待。", "ai");
                scrollToBottom();
                return;
            }

            chatHistory.forEach(item => {
                const isAI = (item.role === 'assistant' || item.role === 'ai');
                if (isAI) {
                    const segments = item.content.split('\n\n');
                    segments.forEach(seg => {
                        if (seg.trim()) displayMessage(seg.trim(), 'ai');
                    });
                } else {
                    displayMessage(item.content, 'user');
                }
            });
            
            scrollToBottom();
        }*/
        /**
         * 加载聊天记录到界面（懒加载版本）
         * 初次只加载最后50条消息
         */
        function loadHistoryUI() {
            const chatContainer = document.getElementById('chat-container');
            if (!chatContainer) return;

            chatContainer.innerHTML = '';

            if (chatHistory.length === 0) {
                displayMessage("你好！有什么想跟我聊聊的吗？我很期待。", "assistant");
                currentLoadedStart = 0;
                return;
            }

            // 计算要加载的范围：最后50条
            const total = chatHistory.length;
            currentLoadedStart = Math.max(0, total - MESSAGES_PER_LOAD);
            
            console.log(`📜 懒加载：总共${total}条消息，加载最后${total - currentLoadedStart}条（索引${currentLoadedStart}-${total-1}）`);
            
            // 渲染这个范围的消息
            renderMessagesRange(currentLoadedStart, total, false);
            
            // 滚动到底部
            scrollToBottom();
            
            // 设置滚动监听（如果还没设置）
            setupScrollListener();
        }
        
        /**
         * 渲染指定范围的消息
         * @param {number} start - 起始索引（包含）
         * @param {number} end - 结束索引（不包含）
         * @param {boolean} prepend - 是否插入到顶部
         */
        function renderMessagesRange(start, end, prepend = false) {
            const chatContainer = document.getElementById('chat-container');
            const fragment = document.createDocumentFragment();
            
            for (let i = start; i < end; i++) {
                const bubble = chatHistory[i];
                const status = bubble.role === 'user' ? 2 : 0;
                
                // 创建消息元素但不添加到DOM（避免多次重排）
                const tempContainer = document.createElement('div');
                displayMessage(bubble.content, bubble.role, status, bubble.timestamp, false, bubble.id, true, null, tempContainer);
                
                // 将创建的消息添加到fragment
                while (tempContainer.firstChild) {
                    fragment.appendChild(tempContainer.firstChild);
                }
            }
            
            // 一次性添加到DOM
            if (prepend) {
                chatContainer.insertBefore(fragment, chatContainer.firstChild);
            } else {
                chatContainer.appendChild(fragment);
            }
        }
        
        /**
         * 设置滚动监听，实现上滑加载更多
         */
        function setupScrollListener() {
            // 【修复】监听真正滚动的容器 .content
            const chatPage = document.getElementById('chat-page');
            if (!chatPage) return;
            
            const scrollContainer = chatPage.querySelector('.content');
            if (!scrollContainer) return;
            
            // 避免重复绑定
            if (scrollContainer.dataset.scrollListenerBound === 'true') return;
            scrollContainer.dataset.scrollListenerBound = 'true';
            
            scrollContainer.addEventListener('scroll', () => {
                // 滚动到顶部且没有在加载且还有更多消息
                if (scrollContainer.scrollTop < 100 && !isLoadingMore && currentLoadedStart > 0) {
                    console.log('🔝 触发加载更多，scrollTop:', scrollContainer.scrollTop);
                    loadMoreMessages();
                }
            });
            
            console.log('✅ 滚动监听已设置到.content容器');
        }
        
        /**
         * 加载更多历史消息（向上翻）
         */
        function loadMoreMessages() {
            if (isLoadingMore || currentLoadedStart <= 0) return;
            
            isLoadingMore = true;
            
            // 【修复】获取真正滚动的容器
            const chatPage = document.getElementById('chat-page');
            const scrollContainer = chatPage ? chatPage.querySelector('.content') : null;
            if (!scrollContainer) {
                isLoadingMore = false;
                return;
            }
            
            // 记录当前滚动位置和高度
            const oldScrollHeight = scrollContainer.scrollHeight;
            const oldScrollTop = scrollContainer.scrollTop;
            
            // 计算要加载的范围
            const newStart = Math.max(0, currentLoadedStart - MESSAGES_PER_LOAD);
            const loadCount = currentLoadedStart - newStart;
            
            console.log(`📜 加载更多：加载${loadCount}条消息（索引${newStart}-${currentLoadedStart-1}）`);
            
            // 显示加载提示
            showToast(`加载中...`);
            
            // 渲染新消息到顶部
            setTimeout(() => {
                renderMessagesRange(newStart, currentLoadedStart, true);
                
                // 更新已加载的起始位置
                currentLoadedStart = newStart;
                
                // 恢复滚动位置（保持在原来看的消息处）
                const newScrollHeight = scrollContainer.scrollHeight;
                scrollContainer.scrollTop = oldScrollTop + (newScrollHeight - oldScrollHeight);
                
                isLoadingMore = false;
                
                if (newStart === 0) {
                    showToast('已加载全部历史消息');
                }
            }, 100); // 小延迟，让UI更流畅
        }


        /**
         * 保存配置到本地存储
         */
        function saveSettings() {
            config.baseurl = document.getElementById('baseurl').value.trim();
            config.apikey = document.getElementById('apikey').value.trim();
            
            // 从下拉框获取选中的模型
            const modelSelect = document.getElementById('modelname');
            config.modelname = modelSelect.value.trim();
            
            config.systemPrompt = document.getElementById('system-prompt').value.trim();
            
            // 保存昵称
            config.userNickname = document.getElementById('user-nickname').value.trim() || '我';
            config.aiNickname = document.getElementById('chat-name-input').value.trim() || 'AI助手';
            
            // 获取上下文窗口大小
            const contextWindowSize = document.getElementById('context-window-size').value;
            
            // 保存配置
            localStorage.setItem('aiChatConfig', JSON.stringify(config));
            
            // 保存上下文窗口大小
            localStorage.setItem('contextWindowSize', contextWindowSize);
            
            // 保存批量发送等待时间
            const batchWaitTime = document.getElementById('batch-wait-time').value;
            localStorage.setItem('batchWaitTime', batchWaitTime);
            
            // 保存API超时时间
            const apiTimeout = document.getElementById('api-timeout').value;
            localStorage.setItem('apiTimeout', apiTimeout);
            
            // 保存长期记忆设置
            const autoSummaryInterval = document.getElementById('auto-summary-interval').value;
            localStorage.setItem('autoSummaryInterval', autoSummaryInterval);
            
            const maxImportantEvents = document.getElementById('max-important-events').value;
            localStorage.setItem('maxImportantEvents', maxImportantEvents);
            
            console.log('💾 已保存上下文窗口大小:', contextWindowSize);
            console.log('💾 已保存批量等待时间:', batchWaitTime, '秒');
            console.log('💾 已保存API超时时间:', apiTimeout, '秒');
            console.log('💾 已保存昵称 - 用户:', config.userNickname, 'AI:', config.aiNickname);
            console.log('🧠 已保存自动总结间隔:', autoSummaryInterval, '个气泡');
            console.log('🧠 已保存最大事件数:', maxImportantEvents, '条');
            
            // 立即更新聊天页面标题
            document.getElementById('chat-name').textContent = config.aiNickname;
            
            alert('设置已保存并生效！');
            
            closeSettings();
        }
        /**
         * 保存聊天记录到本地存储
         */
        function saveChatToLocal() {
            localStorage.setItem('chatHistory', JSON.stringify(chatHistory));
        }

        // 专门用于历史记录加载的瞬时分段显示
        function displaySegmentsInstantly(fullText, role) {
            const separator = '\n\n';
            const segments = fullText.split(separator);
            
            segments.forEach(segment => {
                const cleanSegment = segment.trim();
                if (cleanSegment.length > 0) {
                    displayMessage(cleanSegment, role);
                }
            });
        }
        
        /**
         * 切换页面
         */
        function showPage(pageId, navElement) {
            document.querySelectorAll('.page').forEach(page => page.classList.remove('active'));
            document.getElementById(pageId).classList.add('active');

            document.querySelectorAll('.nav-item').forEach(item => item.classList.remove('active'));
            if (navElement) {
                navElement.classList.add('active');
            }
            // 进入聊天页时进行“尾值比对”
            if (pageId === 'chat-page') {
                const chatContainer = document.getElementById('chat-container');
                // 获取页面上最后一条消息元素（注意：ID保存在 .message 这一层，不是 .bubble）
                const lastUiMessage = chatContainer.querySelector('.message:last-child');
                
                // 1. 获取 UI 上的最后一个 ID
                const lastUiId = lastUiMessage ? lastUiMessage.dataset.bubbleId : null;

                // 2. 获取数据里的最后一个 ID
                const lastDataId = chatHistory.length > 0 ? chatHistory[chatHistory.length - 1].id : null;

                // 3. 简单粗暴的对比
                // 如果 ID 不一样，或者（数据有东西但界面没东西），则重绘
                if (lastUiId !== lastDataId || (chatHistory.length > 0 && !lastUiMessage)) {
                    console.log("检测到 ID 不一致，执行重置渲染");
                    loadHistoryUI();
                } else {
                    console.log("内容匹配，保持当前界面状态");
                }
                
                // 滚动到底部逻辑
                scrollToBottom();
            }
        }
        /**
         * 打开和关闭设置页面 (用于头部按钮)
         */
        function openSettings() {
            // 刷新设置页面,显示当前角色的配置
            loadSettings();
            showPage('settings-page', document.querySelector('.nav-item:last-child'));
        }

        function closeSettings() {
            showPage('chat-page', document.querySelector('.nav-item:nth-child(2)'));
        }

        /**
         * 拉取模型列表
         */
        async function fetchModels() {
            const baseurl = document.getElementById('baseurl').value.trim();
            const apikey = document.getElementById('apikey').value.trim();
            const statusEl = document.getElementById('model-fetch-status');
            const modelSelect = document.getElementById('modelname');
            
            if (!baseurl) {
                statusEl.textContent = '❌ 请先填写 Base URL';
                statusEl.style.color = '#f44336';
                return;
            }
            
            if (!apikey) {
                statusEl.textContent = '❌ 请先填写 API Key';
                statusEl.style.color = '#f44336';
                return;
            }
            
            statusEl.textContent = '🔄 正在拉取模型列表...';
            statusEl.style.color = '#2196F3';
            
            try {
                // 确保URL格式正确
                let url = baseurl.trim();
                if (!url.endsWith('/')) {
                    url += '/';
                }
                url += 'models';
                
                const response = await fetch(url, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${apikey}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                // 检查返回的数据格式
                if (!data.data || !Array.isArray(data.data)) {
                    throw new Error('返回的数据格式不正确');
                }
                
                // 清空现有选项
                modelSelect.innerHTML = '';
                
                // 保存当前选中的模型
                const currentModel = config.modelname;
                
                // 添加模型选项
                if (data.data.length === 0) {
                    const option = document.createElement('option');
                    option.value = '';
                    option.textContent = '-- 未找到可用模型 --';
                    modelSelect.appendChild(option);
                    statusEl.textContent = '⚠️ 未找到可用模型';
                    statusEl.style.color = '#ff9800';
                } else {
                    data.data.forEach(model => {
                        const option = document.createElement('option');
                        option.value = model.id;
                        option.textContent = model.id;
                        modelSelect.appendChild(option);
                    });
                    
                    // 如果之前有选中的模型，保持选中
                    if (currentModel) {
                        let found = false;
                        for (let i = 0; i < modelSelect.options.length; i++) {
                            if (modelSelect.options[i].value === currentModel) {
                                modelSelect.value = currentModel;
                                found = true;
                                break;
                            }
                        }
                        
                        // 如果之前的模型不在列表中，选择第一个
                        if (!found && modelSelect.options.length > 0) {
                            modelSelect.selectedIndex = 0;
                        }
                    } else if (modelSelect.options.length > 0) {
                        modelSelect.selectedIndex = 0;
                    }
                    
                    statusEl.textContent = `✅ 成功拉取 ${data.data.length} 个模型`;
                    statusEl.style.color = '#4CAF50';
                }
                
                console.log('✅ 成功拉取模型列表:', data.data.length, '个模型');
            } catch (error) {
                console.error('❌ 拉取模型列表失败:', error);
                statusEl.textContent = `❌ 拉取失败: ${error.message}`;
                statusEl.style.color = '#f44336';
                
                // 添加一个默认选项
                modelSelect.innerHTML = '<option value="">-- 拉取失败,请检查配置 --</option>';
            }
        }
        
        /**
         * 测试API连接
         */
        async function testConnection() {
            const baseurl = document.getElementById('baseurl').value.trim();
            const apikey = document.getElementById('apikey').value.trim();
            const modelSelect = document.getElementById('modelname');
            const modelname = modelSelect.value.trim();
            const statusEl = document.getElementById('model-fetch-status');
            
            if (!baseurl) {
                statusEl.textContent = '❌ 请先填写 Base URL';
                statusEl.style.color = '#f44336';
                return;
            }
            
            if (!apikey) {
                statusEl.textContent = '❌ 请先填写 API Key';
                statusEl.style.color = '#f44336';
                return;
            }
            
            if (!modelname) {
                statusEl.textContent = '❌ 请先选择模型';
                statusEl.style.color = '#f44336';
                return;
            }
            
            statusEl.textContent = '🔍 正在测试连接...';
            statusEl.style.color = '#2196F3';
            
            try {
                // 确保URL格式正确
                let url = baseurl.trim();
                if (!url.endsWith('/')) {
                    url += '/';
                }
                url += 'chat/completions';
                
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apikey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: modelname,
                        messages: [
                            {
                                role: 'user',
                                content: '你好'
                            }
                        ],
                        max_tokens: 10
                    })
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP ${response.status}: ${errorText}`);
                }
                
                const data = await response.json();
                
                if (data.choices && data.choices.length > 0) {
                    statusEl.textContent = `✅ 连接成功! 模型: ${modelname}`;
                    statusEl.style.color = '#4CAF50';
                    console.log('✅ API测试成功:', data);
                } else {
                    throw new Error('返回数据格式异常');
                }
            } catch (error) {
                console.error('❌ API测试失败:', error);
                statusEl.textContent = `❌ 测试失败: ${error.message}`;
                statusEl.style.color = '#f44336';
            }
        }


        /**
         * 更新聊天页面的标题
         */
        function updateChatName() {
            const savedChatName = localStorage.getItem('chatName');
            const chatNameElement = document.getElementById('chat-name');
            if (chatNameElement && savedChatName) {
                chatNameElement.textContent = savedChatName;
            }
        }

        /**
         * 导出聊天记录为 JSON 文件
         * 改进版本：支持小米浏览器等多种浏览器
         */
        document.getElementById('export-btn').addEventListener('click', async () => {
            // 导出包含所有必要数据的完整对象
            const exportData = {
                chatHistory: chatHistory,
                longTermMemory: longTermMemory,
                pendingSummaryBubbles: pendingSummaryBubbles,
                exportTime: new Date().toISOString(),
                characterId: currentCharacterId
            };
            
            const dataStr = JSON.stringify(exportData, null, 2); // 格式化 JSON
            const exportFileName = 'Linglow_Chat_Backup_' + new Date().toISOString().slice(0, 10) + '.json';
            const dataSize = new Blob([dataStr]).size;
            const dataSizeMB = (dataSize / 1024 / 1024).toFixed(2);

            // 三按钮弹窗选择导出方式
            const exportMethod = await showExportMethodPicker(`备份大小：${dataSizeMB} MB`);
            if (exportMethod === 'cancel') return;
            
            // 执行对应的导出方法
            if (exportMethod === 'clipboard') {
                // 分段复制方案
                console.log('📋 使用分段复制方案');
                
                // 如果小于 2MB，尝试一次性复制
                if (dataSize < 2 * 1024 * 1024) {
                    const tryOnce = confirm(`备份大小：${dataSizeMB} MB\n\n尝试一次性复制到剪贴板？\n\n- 点击"确定"：一次性复制\n- 点击"取消"：分段复制（更安全）`);
                    
                    if (tryOnce) {
                        try {
                            await navigator.clipboard.writeText(dataStr);
                            alert(`✅ 已复制到剪贴板！\n\n请立即：\n1. 打开"备忘录"或"WPS"\n2. 新建文档\n3. 粘贴\n4. 保存为：${exportFileName}`);
                            return;
                        } catch (e) {
                            alert('一次性复制失败，将使用分段复制');
                        }
                    }
                }
                
                // 分段复制
                const chunkSize = 500 * 1024; // 每段 500KB
                const chunks = [];
                for (let i = 0; i < dataStr.length; i += chunkSize) {
                    chunks.push(dataStr.substring(i, i + chunkSize));
                }
                
                alert(`📦 备份大小：${dataSizeMB} MB\n\n将分成 ${chunks.length} 段复制\n\n操作步骤：\n1. 每次复制后，粘贴到备忘录\n2. 不要换行，直接接着粘贴下一段\n3. 全部完成后保存为：\n   ${exportFileName}\n\n点击"确定"开始`);
                
                for (let i = 0; i < chunks.length; i++) {
                    try {
                        await navigator.clipboard.writeText(chunks[i]);
                        
                        if (i < chunks.length - 1) {
                            const shouldContinue = confirm(`✅ 第 ${i + 1}/${chunks.length} 段已复制\n\n请立即粘贴到备忘录（不要换行）\n\n粘贴完成后，点击"确定"复制下一段`);
                            if (!shouldContinue) {
                                alert('⚠️ 已取消。请保存已复制的部分，稍后重新导出。');
                                return;
                            }
                        } else {
                            alert(`🎉 全部完成！\n\n已复制 ${chunks.length} 段数据\n\n请粘贴最后一段，然后保存文件为：\n${exportFileName}`);
                        }
                    } catch (e) {
                        alert(`❌ 第 ${i + 1} 段复制失败：${e.message}\n\n请截图此错误并重试`);
                        return;
                    }
                }
                
                return;
            }
            
            // 标准下载方案
            console.log('💾 使用标准下载方案');
            // 方案1: 使用 Blob + URL.createObjectURL（兼容性最好）
            try {
                const blob = new Blob([dataStr], { type: 'application/json;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                
                const linkElement = document.createElement('a');
                linkElement.href = url;
                linkElement.download = exportFileName;
                linkElement.style.display = 'none';
                document.body.appendChild(linkElement);
                
                // 强制触发点击（适配移动端）
                linkElement.dispatchEvent(new MouseEvent('click', {
                    view: window,
                    bubbles: true,
                    cancelable: true
                }));
                
                // 清理
                setTimeout(() => {
                    document.body.removeChild(linkElement);
                    URL.revokeObjectURL(url);
                }, 100);
                
                console.log('✅ 导出聊天记录完成（Blob方案）');
            } catch (error) {
                console.warn('Blob方案失败，尝试data URI方案:', error);
                
                // 方案2: 降级使用 data URI（某些浏览器不支持Blob）
                try {
                    const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);
                    const linkElement = document.createElement('a');
                    linkElement.setAttribute('href', dataUri);
                    linkElement.setAttribute('download', exportFileName);
                    linkElement.style.display = 'none';
                    document.body.appendChild(linkElement);
                    
                    linkElement.dispatchEvent(new MouseEvent('click', {
                        view: window,
                        bubbles: true,
                        cancelable: true
                    }));
                    
                    setTimeout(() => {
                        document.body.removeChild(linkElement);
                    }, 100);
                    
                    console.log('✅ 导出聊天记录完成（data URI方案）');
                } catch (error2) {
                    // 方案3: 降级使用 window.open（最后的救命稻草）
                    console.warn('data URI方案也失败，使用window.open:', error2);
                    const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);
                    window.open(dataUri, '_blank');
                    alert('已在新标签页打开备份数据。请长按保存或复制内容。');
                    console.log('✅ 导出聊天记录完成（window.open方案）');
                }
            }
        });
        
        /**
         * 导入聊天记录从 JSON 文件
         */
        document.getElementById('import-file').addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;
            
            if (file.type === "application/json") {
                const reader = new FileReader();

                reader.onload = function(e) {
                    try {
                        const importedData = JSON.parse(e.target.result);
                        
                        // 解析导入数据
                        let importedChatHistory = [];
                        let importedLongTermMemory = null;
                        let importedPendingSummaryBubbles = [];
                        
                        // 兼容旧格式(直接导出chatHistory数组)和新格式(包含完整数据的对象)
                        if (Array.isArray(importedData)) {
                            // 旧格式：直接是chatHistory数组
                            console.log('📥 检测到旧格式导入数据');
                            importedChatHistory = importedData;
                        } else if (importedData.chatHistory) {
                            // 新格式：包含完整数据
                            console.log('📥 检测到新格式导入数据');
                            importedChatHistory = importedData.chatHistory || [];
                            importedLongTermMemory = importedData.longTermMemory || null;
                            importedPendingSummaryBubbles = importedData.pendingSummaryBubbles || [];
                        } else {
                            throw new Error('不支持的文件格式');
                        }
                        
                        // 显示导入模式选择对话框
                        showImportModeDialog(importedChatHistory, importedLongTermMemory, importedPendingSummaryBubbles);
                        event.target.value = ''; // 清空文件选择
                    } catch (error) {
                        console.error('❌ 导入失败:', error);
                        alert('❌ 文件解析失败，请确保文件是有效的 JSON 格式。\n\n错误信息：' + error.message);
                        event.target.value = ''; // 清空文件选择
                    }
                };
                reader.readAsText(file);
            } else {
                alert('❌ 请选择 JSON 文件。');
                event.target.value = ''; // 清空文件选择
            }
        });
        
        /**
         * 显示导入模式选择对话框
         */
        function showImportModeDialog(importedChatHistory, importedLongTermMemory, importedPendingSummaryBubbles) {
            const dialog = document.getElementById('import-mode-dialog');
            
            // 更新统计信息
            document.getElementById('import-current-count').textContent = chatHistory.length;
            document.getElementById('import-new-count').textContent = importedChatHistory.length;
            
            // 存储导入数据到临时变量
            window.pendingImportData = {
                chatHistory: importedChatHistory,
                longTermMemory: importedLongTermMemory,
                pendingSummaryBubbles: importedPendingSummaryBubbles
            };
            
            dialog.style.display = 'flex';
        }
        
        /**
         * 关闭导入模式对话框
         */
        function closeImportModeDialog() {
            const dialog = document.getElementById('import-mode-dialog');
            dialog.style.display = 'none';
            window.pendingImportData = null;
        }
        
        /**
         * 执行导入操作
         */
        function executeImport(mode) {
            if (!window.pendingImportData) {
                alert('❌ 导入数据丢失，请重新选择文件');
                return;
            }
            
            const { chatHistory: importedChatHistory, longTermMemory: importedLongTermMemory, pendingSummaryBubbles: importedPendingSummaryBubbles } = window.pendingImportData;
            
            if (mode === 'replace') {
                // 全面覆盖模式
                console.log('📥 执行全面覆盖导入');
                chatHistory = importedChatHistory;
                if (importedLongTermMemory) {
                    longTermMemory = importedLongTermMemory;
                }
                pendingSummaryBubbles = importedPendingSummaryBubbles;
            } else if (mode === 'merge') {
                // 融入模式：按时间戳合并
                console.log('📥 执行融入导入，开始合并聊天记录');
                
                // 合并聊天记录，按时间戳排序
                const mergedHistory = [...chatHistory, ...importedChatHistory];
                mergedHistory.sort((a, b) => {
                    const timeA = new Date(a.timestamp || 0).getTime();
                    const timeB = new Date(b.timestamp || 0).getTime();
                    return timeA - timeB;
                });
                
                chatHistory = mergedHistory;
                
                // 合并待总结的气泡
                const mergedPending = [...pendingSummaryBubbles, ...importedPendingSummaryBubbles];
                pendingSummaryBubbles = mergedPending;
                
                console.log('✅ 融入完成，合并后总消息数:', chatHistory.length);
            }
            
            // 保存到正确的localStorage键
            if (currentCharacterId) {
                localStorage.setItem(`char_${currentCharacterId}_chatHistory`, JSON.stringify(chatHistory));
                localStorage.setItem(`char_${currentCharacterId}_longTermMemory`, JSON.stringify(longTermMemory));
                localStorage.setItem(`char_${currentCharacterId}_pendingSummaryBubbles`, JSON.stringify(pendingSummaryBubbles));
            } else {
                // 兼容旧版本，保存到全局键
                localStorage.setItem('chatHistory', JSON.stringify(chatHistory));
                localStorage.setItem('longTermMemory', JSON.stringify(longTermMemory));
                localStorage.setItem('pendingSummaryBubbles', JSON.stringify(pendingSummaryBubbles));
            }
            
            // 重新渲染聊天（只加载最后50条）
            loadHistoryUI();
            
            // 更新记忆状态显示
            updateMemoryStatus();
            
            // 关闭对话框
            closeImportModeDialog();
            
            showToast(`✅ 聊天记录${mode === 'replace' ? '覆盖' : '融入'}导入成功！`);
            console.log('✅ 导入完成，chatHistory长度:', chatHistory.length);
        }

        /**
         * 更新发送按钮的状态
         */
        // 监听用户输入，回车发送消息（Shift+Enter换行）
        userInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                
                // 检查API配置
                if (!config.baseurl || !config.apikey) {
                    showConfigReminder();
                    return;
                }
                
                // 检查输入内容
                if (userInput.value.trim().length > 0) {
                    generateResponse();
                }
            }
        });
        
        /**
         * 显示配置缺失提醒
         */
        function showConfigReminder() {
            document.getElementById('config-reminder-dialog').classList.add('show');
        }
        
        /**
         * 关闭配置提醒
         */
        function closeConfigReminder() {
            document.getElementById('config-reminder-dialog').classList.remove('show');
        }
        
        /**
         * 前往设置页面
         */
        function goToSettings() {
            closeConfigReminder();
            openSettings();
        }
        
        /**
         * 清空聊天记录
         */
        function clearChat() {
            if (confirm("确定要清空所有聊天记录吗？（包括缓存）")) {
                chatHistory = [];
                pendingSummaryBubbles = [];
                saveChatHistory();
                
                // 更新记忆状态显示
                updateMemoryStatus();
                
                chatContainer.innerHTML = '';
                displayMessage("你好！有什么想跟我聊聊的吗？我很期待。", "assistant");
            }
        }
        
        // ========== 长按菜单功能 ==========
        /**
         * 设置气泡的长按菜单
         */
        function setupLongPressMenu(bubbleElement, bubble) {
            // 【修复】防止重复绑定
            if (bubbleElement.dataset.menuBound === 'true') return;
            bubbleElement.dataset.menuBound = 'true';
            
            let pressTimer = null;
            
            // 触摸开始
            bubbleElement.addEventListener('touchstart', (e) => {
                pressTimer = setTimeout(() => {
                    showBubbleMenu(bubbleElement, bubble, e.touches[0]);
                }, 500); // 500ms长按
            });
            
            // 触摸结束或移动时取消
            bubbleElement.addEventListener('touchend', () => {
                if (pressTimer) clearTimeout(pressTimer);
            });
            
            bubbleElement.addEventListener('touchmove', () => {
                if (pressTimer) clearTimeout(pressTimer);
            });
            
            // PC端支持：右键点击
            bubbleElement.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                showBubbleMenu(bubbleElement, bubble, e);
            });
        }
        
        /**
         * 显示气泡菜单
         */
        function showBubbleMenu(bubbleElement, bubble, touchOrEvent) {
            const menuOverlay = document.getElementById('menu-overlay');
            const bubbleMenu = document.getElementById('bubble-menu');
            
            if (!menuOverlay || !bubbleMenu) {
                console.error('❌ 菜单元素未找到');
                return;
            }
            
            // 高亮当前气泡
            bubbleElement.classList.add('menu-active');
            
            // 构建菜单项
            const menuItems = [];
            
            // 第一项：复制
            menuItems.push({
                text: '复制',
                action: () => copyBubbleContent(bubble)
            });
            
            // 第二项：转发
            menuItems.push({
                text: '转发',
                action: () => forwardSingleMessage(bubble)
            });
            
            // 第三项：收藏
            menuItems.push({
                text: '收藏',
                action: () => favoriteSingleMessage(bubble)
            });
            
            // 所有气泡都有的选项
            menuItems.push({
                text: '引用',
                action: () => quoteBubble(bubble)
            });
            
            menuItems.push({
                text: '编辑',
                action: () => editBubble(bubble)
            });
            
            menuItems.push({
                text: '多选',
                action: () => enterMultiSelectMode(bubble)
            });
            
            menuItems.push({
                text: '删除',
                danger: true,
                action: () => deleteBubble(bubble, bubbleElement)
            });
            
            // assistant气泡额外选项
            if (bubble.role === 'assistant') {
                menuItems.push({
                    text: '重新生成',
                    action: () => regenerateResponse(bubble)
                });
                // 如果有备选开场白
                if (bubble.alternativeGreetings && bubble.alternativeGreetings.length > 0) {
                    menuItems.push({
                        text: '切换开场白',
                        action: () => {
                            const idx = chatHistory.findIndex(b => b.id === bubble.id);
                            if (idx >= 0 && window.switchGreeting) window.switchGreeting(idx);
                            closeBubbleMenu(bubbleElement);
                        }
                    });
                }
            }
            
            // 渲染菜单
            bubbleMenu.innerHTML = menuItems.map(item => `
                <div class="bubble-menu-item ${item.danger ? 'danger' : ''}" data-action="${item.text}">
                    <span>${item.text}</span>
                </div>
            `).join('');
            
            // 绑定点击事件
            bubbleMenu.querySelectorAll('.bubble-menu-item').forEach((item, index) => {
                item.onclick = (e) => {
                    e.stopPropagation();
                    menuItems[index].action();
                    closeBubbleMenu(bubbleElement);
                };
            });
            
            // 定位菜单 - 智能定位避免超出屏幕
            const x = touchOrEvent.clientX || touchOrEvent.pageX;
            const y = touchOrEvent.clientY || touchOrEvent.pageY;
            
            // 先设置初始位置，以便获取菜单尺寸
            bubbleMenu.style.left = x + 'px';
            bubbleMenu.style.top = y + 'px';
            
            // 显示菜单（先显示才能获取尺寸）
            menuOverlay.classList.add('active');
            bubbleMenu.classList.add('active');
            
            // 获取菜单和视口尺寸
            const menuRect = bubbleMenu.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            
            let finalX = x;
            let finalY = y;
            
            // 水平方向调整
            if (x + menuRect.width > viewportWidth - 10) {
                // 菜单右边超出屏幕，调整到鼠标左边
                finalX = x - menuRect.width;
                // 如果左边也不够，则贴着右边缘
                if (finalX < 10) {
                    finalX = viewportWidth - menuRect.width - 10;
                }
            }
            
            // 垂直方向调整
            if (y + menuRect.height > viewportHeight - 10) {
                // 菜单下边超出屏幕，调整到鼠标上方
                finalY = y - menuRect.height;
                // 如果上边也不够，则贴着底部边缘
                if (finalY < 10) {
                    finalY = viewportHeight - menuRect.height - 10;
                }
            }
            
            // 应用最终位置
            bubbleMenu.style.left = Math.max(10, finalX) + 'px';
            bubbleMenu.style.top = Math.max(10, finalY) + 'px';
            
            // 点击遮罩关闭
            menuOverlay.onclick = () => closeBubbleMenu(bubbleElement);
        }
        
        /**
         * 关闭菜单
         */
        function closeBubbleMenu(bubbleElement) {
            const menuOverlay = document.getElementById('menu-overlay');
            const bubbleMenu = document.getElementById('bubble-menu');
            
            if (menuOverlay) {
                menuOverlay.classList.remove('active');
                menuOverlay.onclick = null; // 清除旧的点击处理器，防止事件穿透
            }
            if (bubbleMenu) bubbleMenu.classList.remove('active');
            if (bubbleElement) bubbleElement.classList.remove('menu-active');
        }
        
        /**
         * 复制气泡内容到剪贴板
         */
        async function copyBubbleContent(bubble) {
            try {
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(bubble.content);
                    showToast('已复制');
                } else {
                    // 降级方案
                    const textarea = document.createElement('textarea');
                    textarea.value = bubble.content;
                    textarea.style.position = 'fixed';
                    textarea.style.opacity = '0';
                    document.body.appendChild(textarea);
                    textarea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textarea);
                    showToast('已复制');
                }
            } catch (error) {
                console.error('❌ 复制失败:', error);
                alert('复制失败');
            }
        }
        
        /**
         * 显示临时提示
         */
        function showToast(message) {
            const toast = document.createElement('div');
            toast.textContent = message;
            toast.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(128, 128, 128, 0.9);
                color: white;
                padding: 12px 24px;
                border-radius: 8px;
                font-size: 14px;
                z-index: 10001;
                pointer-events: none;
            `;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 1000);
        }
        
        /**
         * 删除气泡
         */
        function deleteBubble(bubble, bubbleElement) {
            chatHistory = chatHistory.filter(b => b.id !== bubble.id);
            pendingSummaryBubbles = pendingSummaryBubbles.filter(b => b.id !== bubble.id);
            saveChatHistory();
            
            const messageDiv = chatContainer.querySelector(`[data-bubble-id="${bubble.id}"]`);
            if (messageDiv) messageDiv.remove();
            
            console.log('🗑️ 已删除气泡:', bubble.id);
        }
        
        /**
         * 重新生成回复
         */
        async function regenerateResponse(bubble) {
            const bubbleIndex = chatHistory.findIndex(b => b.id === bubble.id);
            if (bubbleIndex === -1) return;
            
            // 检查是否有后续对话
            const hasFollowingMessages = bubbleIndex < chatHistory.length - 1;
            
            if (hasFollowingMessages) {
                // 有后续对话，显示确认对话框
                showConfirmDialog({
                    title: '重新生成确认',
                    message: '重新生成会删除当前回复及之后的所有对话。是否保存当前分支？',
                    buttons: [
                        {
                            text: '保存并重新生成',
                            className: 'primary',
                            action: async () => {
                                // 导出当前分支
                                exportCurrentBranch();
                                // 执行重新生成
                                await doRegenerate(bubbleIndex);
                            }
                        },
                        {
                            text: '直接生成',
                            className: 'secondary',
                            action: async () => {
                                await doRegenerate(bubbleIndex);
                            }
                        },
                        {
                            text: '取消',
                            className: 'cancel',
                            action: () => {
                                hideConfirmDialog();
                            }
                        }
                    ]
                });
            } else {
                // 是最后一条，直接重新生成
                await doRegenerate(bubbleIndex);
            }
        }
        
        /**
         * 执行重新生成（内部函数）
         */
        async function doRegenerate(bubbleIndex) {
            console.log('🔄 开始重新生成流程');
            console.log('📍 点击的气泡索引:', bubbleIndex);
            console.log('📍 点击的气泡内容:', chatHistory[bubbleIndex]?.content?.substring(0, 50));
            console.log('📍 点击的气泡角色:', chatHistory[bubbleIndex]?.role);
            
            // 向上查找：找到本轮assistant回复的第一条
            // 即向上找到最后一个user气泡后的第一个assistant气泡
            let startIndex = bubbleIndex;
            
            // 向上遍历，找到同一组的第一个assistant
            while (startIndex > 0 && chatHistory[startIndex - 1].role === 'assistant') {
                startIndex--;
            }
            
            console.log('🔍 向上查找: 从索引', bubbleIndex, '找到第一个assistant在索引', startIndex);
            console.log('📊 删除前 chatHistory 长度:', chatHistory.length);
            console.log('📊 删除前最后3条:', chatHistory.slice(-3).map((b, i) => `[${chatHistory.length - 3 + i}] ${b.role}: ${b.content.substring(0, 30)}`));
            
            // 删除从startIndex开始的所有气泡（包括user和assistant）
            const bubblestoDelete = chatHistory.slice(startIndex);
            
            console.log('🗑️ 将要删除的气泡:', bubblestoDelete.map((b, i) => `[${startIndex + i}] ${b.role}: ${b.content.substring(0, 30)}`));
            
            // 从UI删除
            bubblestoDelete.forEach(b => {
                const msgDiv = chatContainer.querySelector(`[data-bubble-id="${b.id}"]`);
                if (msgDiv) msgDiv.remove();
            });
            
            // 从数据删除
            chatHistory = chatHistory.slice(0, startIndex);
            pendingSummaryBubbles = pendingSummaryBubbles.filter(b => 
                !bubblestoDelete.find(deleted => deleted.id === b.id)
            );
            saveChatHistory();
            
            console.log('🔄 重新生成，删除了', bubblestoDelete.length, '个气泡 (从索引', startIndex, '开始)');
            console.log('📊 删除后 chatHistory 长度:', chatHistory.length);
            console.log('📊 删除后最后3条:', chatHistory.slice(-3).map((b, i) => `[${chatHistory.length - 3 + i}] ${b.role}: ${b.content.substring(0, 30)}`));
            
            // 调用API
            await callAPIForRegeneration();
        }
        
        /**
         * 导出当前分支
         */
        function exportCurrentBranch() {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            const filename = `chat_branch_${timestamp}.json`;
            
            const dataStr = JSON.stringify(chatHistory, null, 2);
            
            // 检测是否为小米浏览器
            const isMiuiBrowser = /MiuiBrowser/i.test(navigator.userAgent);
            
            if (isMiuiBrowser) {
                console.log('🔍 检测到小米浏览器，使用 Blob URL 方案');
                
                try {
                    const blob = new Blob([dataStr], { type: 'text/plain;charset=utf-8' });
                    const url = URL.createObjectURL(blob);
                    
                    alert('即将在新窗口打开分支数据\n\n保存方法：\n1. 在新页面点击"⋮"\n2. 选择"保存网页"\n3. 改名为：' + filename);
                    
                    const newWindow = window.open(url, '_blank');
                    
                    if (!newWindow) {
                        alert('⚠️ 无法打开新窗口，请允许弹出窗口权限');
                    } else {
                        showToast('分支已在新窗口打开');
                        console.log('💾 已导出分支:', filename);
                        setTimeout(() => URL.revokeObjectURL(url), 60000);
                    }
                    return;
                } catch (error) {
                    console.error('❌ Blob URL 方案失败:', error);
                    alert('导出失败：' + error.message);
                    return;
                }
            }
            
            // 非小米浏览器：使用标准方案
            const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);
            
            const link = document.createElement('a');
            link.setAttribute('href', dataUri);
            link.setAttribute('download', filename);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            showToast('分支已保存');
            console.log('💾 已导出分支:', filename);
        }
        
        /**
         * 显示确认对话框
         */
        function showConfirmDialog({ title, message, buttons }) {
            const dialog = document.getElementById('confirm-dialog');
            const overlay = document.getElementById('menu-overlay');
            const titleEl = document.getElementById('confirm-title');
            const messageEl = document.getElementById('confirm-message');
            const buttonsEl = document.getElementById('confirm-buttons');
            
            if (!dialog || !overlay) return;
            
            // 设置内容
            titleEl.textContent = title;
            messageEl.textContent = message;
            
            // 生成按钮
            buttonsEl.innerHTML = buttons.map((btn, idx) => `
                <button class="confirm-dialog-button ${btn.className}" data-btn-index="${idx}">
                    ${btn.text}
                </button>
            `).join('');
            
            // 绑定事件
            buttonsEl.querySelectorAll('button').forEach((btnEl, idx) => {
                btnEl.onclick = () => {
                    hideConfirmDialog();
                    if (buttons[idx].action) {
                        buttons[idx].action();
                    }
                };
            });
            
            // 显示
            overlay.classList.add('active');
            dialog.classList.add('active');
            
            // 点击遮罩关闭（延迟绑定，避免移动端触摸事件立即触发）
            overlay.onclick = null;
            setTimeout(() => {
                overlay.onclick = hideConfirmDialog;
            }, 300);
        }
        
        /**
         * 隐藏确认对话框
         */
        function hideConfirmDialog() {
            const dialog = document.getElementById('confirm-dialog');
            const overlay = document.getElementById('menu-overlay');
            
            if (dialog) dialog.classList.remove('active');
            if (overlay) {
                overlay.classList.remove('active');
                overlay.onclick = null; // 清除点击处理器
            }
        }
        
        /**
         * 调用API重新生成
         */
        async function callAPIForRegeneration() {
            console.log('🤖 callAPIForRegeneration 开始');
            console.log('📊 当前 chatHistory 长度:', chatHistory.length);
            
            showTypingIndicator();
            isWaitingForAI = true;
            
            try {
                const N = parseInt(localStorage.getItem('contextWindowSize')) || 50;
                const recentBubbles = chatHistory.slice(-N);
                console.log('📊 取最近', N, '条，实际取到', recentBubbles.length, '条');
                
                const apiMessages = convertToAPIFormat(recentBubbles);
                console.log('📊 转换为API格式后:', apiMessages.length, '条消息');
                console.log('📊 API消息列表:', apiMessages.map((m, i) => `[${i}] ${m.role}: ${m.content.substring(0, 50)}`));
                
                // 验证：确保最后一条消息是user（否则API会报错）
                if (apiMessages.length === 0 || apiMessages[apiMessages.length - 1].role !== 'user') {
                    hideTypingIndicator();
                    isWaitingForAI = false;
                    console.error('❌ 重新生成失败：没有找到上一条用户消息');
                    console.error('❌ 最后一条消息是:', apiMessages[apiMessages.length - 1]);
                    alert('重新生成失败：找不到用户消息，请检查聊天记录');
                    return;
                }
                
                let finalSystemPrompt = (window._offlinePrefix ? window._offlinePrefix() : '') + config.systemPrompt;
                
                // 注入状态栏
                finalSystemPrompt += statusBuildPromptInjection();
                
                // 注入世界书
                const wbInj = buildWorldbookInjection(apiMessages);
                if (wbInj) finalSystemPrompt += wbInj;
                
                // 添加长期记忆到系统提示
                if (longTermMemory && longTermMemory.metadata) {
                    let memoryPrompt = '\n\n=== 长期记忆 ===\n\n';
                    
                    // 添加兴趣爱好
                    if (longTermMemory.basic_info && Object.keys(longTermMemory.basic_info).length > 0) {
                        memoryPrompt += '以下是用户的兴趣爱好，你应该记住这些：\n';
                        for (const [key, value] of Object.entries(longTermMemory.basic_info)) {
                            memoryPrompt += `${key}: ${value}\n`;
                        }
                        memoryPrompt += '\n';
                    }
                    
                    // 添加性格偏好
                    if (longTermMemory.emotional_profile) {
                        memoryPrompt += `性格偏好: ${longTermMemory.emotional_profile}\n\n`;
                    }
                    
                    // 添加人际关系
                    if (longTermMemory.relationships) {
                        memoryPrompt += `人际关系: ${longTermMemory.relationships}\n\n`;
                    }
                    
                    // 添加所有记忆（按last_mentioned倒序）
                    if (longTermMemory.important_events && longTermMemory.important_events.length > 0) {
                        // 按last_mentioned倒序排序（最近的在前）
                        const sortedMemories = [...longTermMemory.important_events].sort((a, b) => 
                            new Date(b.last_mentioned) - new Date(a.last_mentioned)
                        );
                        
                        memoryPrompt += '以下是你和用户交互时，你产生的记忆片段和你对于事件的情绪，你应该深深记住并且基于以上事实对用户的最新消息进行回复（越靠前的记忆越重要）：\n\n';
                        
                        sortedMemories.forEach((m, i) => {
                            const date = new Date(m.last_mentioned).toLocaleDateString('zh-CN');
                            memoryPrompt += `${i + 1}. ${m.title}（${date}`;
                            if (m.mention_count) {
                                memoryPrompt += `，提及${m.mention_count}次`;
                            }
                            memoryPrompt += `）\n`;
                            memoryPrompt += `${m.content}\n`;
                            if (m.心路历程) {
                                memoryPrompt += `心路历程: ${m.心路历程}\n`;
                            }
                            memoryPrompt += '\n';
                        });
                    }
                    
                    memoryPrompt += '=== 记忆结束 ===\n';
                    finalSystemPrompt += memoryPrompt;
                }
                
                const now = new Date();
                const currentTimeStr = now.toLocaleString('zh-CN', {
                    year: 'numeric', month: '2-digit', day: '2-digit',
                    hour: '2-digit', minute: '2-digit', weekday: 'long', hour12: false
                });
                finalSystemPrompt += `\n\n[当前时间]: ${currentTimeStr}`;
                
                const messagesWithTime = apiMessages.map(msg => {
                    if (msg.timestamp) {
                        const time = new Date(msg.timestamp);
                        const timeStr = time.toLocaleString('zh-CN', {
                            year: 'numeric', month: '2-digit', day: '2-digit',
                            hour: '2-digit', minute: '2-digit', hour12: false
                        });
                        return { role: msg.role, content: `[${timeStr}] ${msg.content}` };
                    }
                    return { role: msg.role, content: msg.content };
                });
                
                const messages = [
                    { role: "system", content: finalSystemPrompt },
                    ...messagesWithTime
                ];
                
                const response = await fetch(config.baseurl + '/chat/completions', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${config.apikey}` },
                    body: JSON.stringify({ model: config.modelname, messages: messages })
                });
                
                const data = await response.json();
                hideTypingIndicator();
                
                if (data.choices && data.choices[0]) {
                    const aiResponseText = data.choices[0].message.content.trim();
                    processAndDisplaySegments(aiResponseText);
                } else {
                    isWaitingForAI = false;
                    const errMsg = data.error?.message || '未知错误';
                    console.error('❌ 重新生成API返回异常:', data);
                    alert('重新生成失败：' + errMsg);
                }
            } catch (error) {
                hideTypingIndicator();
                isWaitingForAI = false;
                console.error('重新生成失败:', error);
                alert('重新生成失败：' + error.message);
            }
        }
        
        /**
         * 引用气泡
         */
        let currentQuote = null; // 当前引用的气泡
        
        function quoteBubble(bubble) {
            currentQuote = bubble;
            
            // 显示引用预览
            showQuotePreview(bubble);
            
            // 聚焦输入框
            userInput.focus();
            
            showToast('已引用该消息');
        }
        
        /**
         * 显示引用预览
         */
        function showQuotePreview(bubble) {
            const inputArea = document.getElementById('chat-input-area');
            
            // 移除已有的引用预览
            const existingQuote = inputArea.querySelector('.quote-reference');
            if (existingQuote) {
                existingQuote.remove();
            }
            
            // 获取发送者昵称
            const senderName = bubble.role === 'user' ? config.userNickname : config.aiNickname;
            
            // 创建引用预览元素 (微信风格：昵称：内容)
            const quoteDiv = document.createElement('div');
            quoteDiv.classList.add('quote-reference');
            quoteDiv.innerHTML = `
                <div class="quote-content">${escapeHtml(senderName)}：${escapeHtml(bubble.content)}</div>
                <span class="quote-close" onclick="clearQuote()">×</span>
            `;
            
            // 添加到输入区域底部 (textarea之后)
            const textarea = inputArea.querySelector('#user-input');
            inputArea.insertBefore(quoteDiv, textarea.nextSibling);
        }
        
        /**
         * 清除引用
         */
        function clearQuote() {
            currentQuote = null;
            const inputArea = document.getElementById('chat-input-area');
            const quoteDiv = inputArea.querySelector('.quote-reference');
            if (quoteDiv) {
                quoteDiv.remove();
            }
        }
        
        /**
         * HTML转义
         */
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        /**
         * 编辑气泡
         */
        function editBubble(bubble) {
            // 找到对应的DOM元素
            const messageDiv = chatContainer.querySelector(`[data-bubble-id="${bubble.id}"]`);
            if (!messageDiv) {
                console.error('❌ 未找到气泡元素');
                return;
            }
            
            const bubbleDiv = messageDiv.querySelector('.bubble');
            if (!bubbleDiv) {
                console.error('❌ 未找到气泡内容元素');
                return;
            }
            
            // 保存原始内容和元素
            const originalContent = bubble.content;
            const originalHtml = bubbleDiv.innerHTML;
            
            // 标记为编辑状态
            bubbleDiv.classList.add('editing');
            
            // 创建编辑界面
            const textarea = document.createElement('textarea');
            textarea.classList.add('edit-textarea');
            textarea.value = originalContent;
            
            const buttonsDiv = document.createElement('div');
            buttonsDiv.classList.add('edit-buttons');
            
            const saveBtn = document.createElement('button');
            saveBtn.classList.add('edit-btn', 'save');
            saveBtn.textContent = '保存';
            
            const cancelBtn = document.createElement('button');
            cancelBtn.classList.add('edit-btn', 'cancel');
            cancelBtn.textContent = '取消';
            
            buttonsDiv.appendChild(saveBtn);
            buttonsDiv.appendChild(cancelBtn);
            
            // 替换气泡内容
            bubbleDiv.innerHTML = '';
            bubbleDiv.appendChild(textarea);
            bubbleDiv.appendChild(buttonsDiv);
            
            // 自动聚焦并选中文本
            textarea.focus();
            textarea.setSelectionRange(textarea.value.length, textarea.value.length);
            
            // 取消按钮
            cancelBtn.onclick = () => {
                bubbleDiv.classList.remove('editing');
                bubbleDiv.innerHTML = originalHtml;
                
                // 重新绑定长按菜单
                setupLongPressMenu(bubbleDiv, bubble);
            };
            
            // 保存按钮
            saveBtn.onclick = async () => {
                const newContent = textarea.value.trim();
                
                if (!newContent) {
                    alert('内容不能为空');
                    return;
                }
                
                if (newContent === originalContent) {
                    // 内容未改变，直接取消
                    cancelBtn.click();
                    return;
                }
                
                // 根据角色处理不同的保存逻辑
                if (bubble.role === 'assistant') {
                    // AI消息：直接更新内容（不需要重新生成）
                    await saveEditedAIMessage(bubble, newContent, bubbleDiv, originalHtml);
                } else if (bubble.role === 'user') {
                    // 用户消息：必须重新生成
                    const bubbleIndex = chatHistory.findIndex(b => b.id === bubble.id);
                    if (bubbleIndex === -1) {
                        console.error('❌ 未找到气泡索引');
                        return;
                    }
                    
                    // 检查是否有后续消息
                    const hasFollowingMessages = bubbleIndex < chatHistory.length - 1;
                    
                    if (hasFollowingMessages) {
                        // 有后续消息，询问是否保存分支
                        showConfirmDialog({
                            title: '重新生成确认',
                            message: '编辑后将重新生成回复，这会删除此消息之后的所有对话。是否保存当前分支？',
                            buttons: [
                                {
                                    text: '保存分支并重新生成',
                                    className: 'primary',
                                    action: async () => {
                                        exportCurrentBranch();
                                        await doEditAndRegenerate(bubble, bubbleIndex, newContent);
                                    }
                                },
                                {
                                    text: '直接重新生成',
                                    className: 'secondary',
                                    action: async () => {
                                        await doEditAndRegenerate(bubble, bubbleIndex, newContent);
                                    }
                                },
                                {
                                    text: '取消',
                                    className: 'cancel',
                                    action: () => {
                                        // 恢复编辑界面
                                        const messageDiv = chatContainer.querySelector(`[data-bubble-id="${bubble.id}"]`);
                                        const bubbleDiv = messageDiv?.querySelector('.bubble');
                                        if (bubbleDiv) {
                                            const textarea = bubbleDiv.querySelector('.edit-textarea');
                                            if (textarea) {
                                                textarea.value = newContent;
                                            }
                                        }
                                    }
                                }
                            ]
                        });
                    } else {
                        // 是最后一条，直接重新生成
                        await doEditAndRegenerate(bubble, bubbleIndex, newContent);
                    }
                }
            };
        }
        
        /**
         * 保存编辑后的AI消息
         */
        async function saveEditedAIMessage(bubble, newContent, bubbleDiv, originalHtml) {
            // 更新所有地方的内容
            bubble.content = newContent;
            
            // 更新chatHistory
            const historyIndex = chatHistory.findIndex(b => b.id === bubble.id);
            if (historyIndex !== -1) {
                chatHistory[historyIndex].content = newContent;
            }
            
            // 更新pendingSummaryBubbles
            const pendingIndex = pendingSummaryBubbles.findIndex(b => b.id === bubble.id);
            if (pendingIndex !== -1) {
                pendingSummaryBubbles[pendingIndex].content = newContent;
            }
            
            // 保存到localStorage
            saveChatHistory();
            
            // 更新UI
            bubbleDiv.classList.remove('editing');
            
            // 检测并解析引用
            let quotedText = null;
            let quotedSender = null;
            let mainText = newContent;
            const quoteMatch = newContent.match(/^\[引用: "(.+?): (.+?)"\]\n\n([\s\S]+)$/);
            if (quoteMatch) {
                quotedSender = quoteMatch[1];
                quotedText = quoteMatch[2];
                mainText = quoteMatch[3];
            }
            
            // 保存meta信息
            const metaDiv = bubbleDiv.querySelector('.message-meta');
            const metaHtml = metaDiv ? metaDiv.outerHTML : '';
            
            // 清空并重建内容
            bubbleDiv.innerHTML = '';
            
            // 添加主要文本
            const mainTextNode = document.createTextNode(mainText);
            bubbleDiv.appendChild(mainTextNode);
            
            // 恢复meta信息
            if (metaHtml) {
                bubbleDiv.insertAdjacentHTML('beforeend', metaHtml);
            }
            
            // 【修改】如果有引用，添加到contentWrapper（气泡外）
            const contentWrapper = messageDiv.querySelector('.message-content-wrapper');
            if (quotedText && quotedSender && contentWrapper) {
                // 先移除旧的引用（如果有）
                const oldQuote = contentWrapper.querySelector('.quoted-message');
                if (oldQuote) oldQuote.remove();
                
                const quotedDiv = document.createElement('div');
                quotedDiv.classList.add('quoted-message');
                
                const senderSpan = document.createElement('span');
                senderSpan.classList.add('quote-sender');
                senderSpan.textContent = quotedSender + '：';
                
                quotedDiv.appendChild(senderSpan);
                quotedDiv.appendChild(document.createTextNode(quotedText));
                
                contentWrapper.appendChild(quotedDiv); // 添加到contentWrapper
            }
            
            // 重新绑定长按菜单
            setupLongPressMenu(bubbleDiv, bubble);
            
            showToast('已保存');
            console.log('✅ AI消息已更新:', bubble.id);
        }
        
        /**
         * 执行编辑并重新生成
         */
        async function doEditAndRegenerate(bubble, bubbleIndex, newContent) {
            // 更新消息内容
            bubble.content = newContent;
            chatHistory[bubbleIndex].content = newContent;
            
            // 更新UI
            const messageDiv = chatContainer.querySelector(`[data-bubble-id="${bubble.id}"]`);
            const bubbleDiv = messageDiv?.querySelector('.bubble');
            if (bubbleDiv) {
                bubbleDiv.classList.remove('editing');
                
                // 检测并解析引用
                let quotedText = null;
                let quotedSender = null;
                let mainText = newContent;
                const quoteMatch = newContent.match(/^\[引用: "(.+?): (.+?)"\]\n\n([\s\S]+)$/);
                if (quoteMatch) {
                    quotedSender = quoteMatch[1];
                    quotedText = quoteMatch[2];
                    mainText = quoteMatch[3];
                }
                
                // 保存meta信息
                const metaDiv = bubbleDiv.querySelector('.message-meta');
                const metaHtml = metaDiv ? metaDiv.outerHTML : '';
                
                // 清空并重建内容
                bubbleDiv.innerHTML = '';
                
                // 添加主要文本
                const mainTextNode = document.createTextNode(mainText);
                bubbleDiv.appendChild(mainTextNode);
                
                // 恢复meta信息
                if (metaHtml) {
                    bubbleDiv.insertAdjacentHTML('beforeend', metaHtml);
                }
                
                // 【修改】如果有引用，添加到contentWrapper（气泡外）
                const contentWrapper = messageDiv.querySelector('.message-content-wrapper');
                if (quotedText && quotedSender && contentWrapper) {
                    // 先移除旧的引用（如果有）
                    const oldQuote = contentWrapper.querySelector('.quoted-message');
                    if (oldQuote) oldQuote.remove();
                    
                    const quotedDiv = document.createElement('div');
                    quotedDiv.classList.add('quoted-message');
                    
                    const senderSpan = document.createElement('span');
                    senderSpan.classList.add('quote-sender');
                    senderSpan.textContent = quotedSender + '：';
                    
                    quotedDiv.appendChild(senderSpan);
                    quotedDiv.appendChild(document.createTextNode(quotedText));
                    
                    contentWrapper.appendChild(quotedDiv); // 添加到contentWrapper
                }
                
                // 重新绑定长按菜单
                setupLongPressMenu(bubbleDiv, bubble);
            }
            
            // 【优化的删除逻辑】
            // 1. 向后延伸：保留当前编辑气泡之后的所有连续user气泡
            let keepUntilIndex = bubbleIndex; // 默认保留到当前编辑的气泡
            
            for (let i = bubbleIndex + 1; i < chatHistory.length; i++) {
                if (chatHistory[i].role === 'user') {
                    // 如果是用户气泡，继续向后保留
                    keepUntilIndex = i;
                } else {
                    // 遇到第一个非用户气泡(assistant)，停止
                    break;
                }
            }
            
            console.log(`📝 编辑逻辑：保留气泡 0-${keepUntilIndex}，删除气泡 ${keepUntilIndex + 1}-${chatHistory.length - 1}`);
            
            // 2. 删除从第一个assistant开始的所有消息
            const bubblestoDelete = chatHistory.slice(keepUntilIndex + 1);
            
            // 从UI删除
            bubblestoDelete.forEach(b => {
                const msgDiv = chatContainer.querySelector(`[data-bubble-id="${b.id}"]`);
                if (msgDiv) msgDiv.remove();
            });
            
            // 从数据删除
            chatHistory = chatHistory.slice(0, keepUntilIndex + 1);
            pendingSummaryBubbles = pendingSummaryBubbles.filter(b => 
                !bubblestoDelete.find(deleted => deleted.id === b.id)
            );
            
            // 保存
            saveChatHistory();
            
            showToast('正在重新生成...');
            console.log('🔄 编辑后重新生成，删除了', bubblestoDelete.length, '个气泡');
            
            // 调用API重新生成
            await callAPIForRegeneration();
        }
        
        // ========== 长期记忆功能 ==========
        
        /**
         * 更新记忆状态显示
         */
        function updateMemoryStatus() {
            const autoSummaryInterval = parseInt(localStorage.getItem('autoSummaryInterval')) || 50;
            const totalBubbles = chatHistory.length;
            const pendingBubbles = pendingSummaryBubbles.length;
            const eventsCount = longTermMemory.important_events?.length || 0;
            const lastSummaryAt = longTermMemory.metadata?.last_summary_at || 0;
            const lastUpdated = longTermMemory.metadata?.last_updated;
            
            // 更新DOM（如果元素存在）
            const totalEl = document.getElementById('total-bubbles-count');
            const pendingEl = document.getElementById('pending-bubbles-count');
            const eventsEl = document.getElementById('events-count');
            const lastTimeEl = document.getElementById('last-summary-time');
            const untilNextEl = document.getElementById('bubbles-until-next');
            
            if (totalEl) totalEl.textContent = totalBubbles;
            if (pendingEl) pendingEl.textContent = pendingBubbles;
            if (eventsEl) eventsEl.textContent = eventsCount;
            
            if (lastTimeEl) {
                if (lastUpdated) {
                    const date = new Date(lastUpdated);
                    lastTimeEl.textContent = date.toLocaleString('zh-CN');
                } else {
                    lastTimeEl.textContent = '从未';
                }
            }
            
            if (untilNextEl) {
                const remaining = autoSummaryInterval - pendingBubbles;
                if (remaining > 0) {
                    untilNextEl.textContent = remaining;
                } else {
                    untilNextEl.textContent = '已达到，将在下次回复后触发';
                }
            }
        }
        
        /**
         * 生成记忆总结
         * @param {boolean} manual - 是否为手动触发
         */
        async function generateMemorySummary(manual = false) {
            // 【新增】先清理已被删除的pending气泡
            const validPendingBubbles = pendingSummaryBubbles.filter(pendingBubble => {
                return chatHistory.some(historyBubble => historyBubble.id === pendingBubble.id);
            });
            
            if (validPendingBubbles.length !== pendingSummaryBubbles.length) {
                const removedCount = pendingSummaryBubbles.length - validPendingBubbles.length;
                console.log(`🗑️ 生成记忆前清理了 ${removedCount} 个已删除的pending气泡`);
                pendingSummaryBubbles = validPendingBubbles;
            }
            
            // 检查是否有待总结的内容
            if (pendingSummaryBubbles.length === 0) {
                if (manual) {
                    alert('当前没有新的对话需要总结！');
                }
                console.log('⚠️ 没有有效的pending气泡，跳过记忆生成');
                return;
            }
            
            // 检查API配置
            if (!config.baseurl || !config.apikey || !config.modelname) {
                alert('请先配置API！');
                return;
            }
            
            if (manual) {
                if (!confirm(`将总结最近 ${pendingSummaryBubbles.length} 个气泡的内容，生成长期记忆。是否继续？`)) {
                    return;
                }
            }
            
            try {
                // 显示加载提示
                const loadingMsg = manual ? '正在生成记忆总结，请稍候...' : '后台更新长期记忆...';
                showToast(loadingMsg);
                
                // 【关键优化】向后延伸，确保最后一条消息是完整的
                let bubblesToSummarize = extendForward(pendingSummaryBubbles, chatHistory);
                console.log('📍 记忆生成：原始', pendingSummaryBubbles.length, '条 → 延伸后', bubblesToSummarize.length, '条');
                
                // 准备对话内容
                const conversationText = bubblesToSummarize.map(b => {
                    const time = new Date(b.timestamp).toLocaleString('zh-CN');
                    const speaker = b.role === 'user' ? config.userNickname : config.aiNickname;
                    return `[${time}] ${speaker}: ${b.content}`;
                }).join('\n\n');
                
                // 获取对话时间范围
                const firstTimestamp = bubblesToSummarize[0]?.timestamp;
                const lastTimestamp = bubblesToSummarize[bubblesToSummarize.length - 1]?.timestamp;
                const timeRange = `${new Date(firstTimestamp).toLocaleString('zh-CN')} 至 ${new Date(lastTimestamp).toLocaleString('zh-CN')}`;
                
                // 构建已有记忆的详细上下文
                const existingMemoriesContext = longTermMemory.important_events.map(m => 
                    `[${m.memory_id}] ${m.title} (${m.type})
   当前重要度: ${m.importance}分
   提及次数: ${m.mention_count}次
   最后提及: ${new Date(m.last_mentioned).toLocaleString('zh-CN')}
   内容预览: ${m.content.substring(0, 100)}...`
                ).join('\n\n');
                
                // 构建总结prompt
                const summaryPrompt = `【角色设定】
${config.systemPrompt || '你是一个友好的AI助手。'}

你正在整理你和用户的聊天记忆。以第一人称（"我"）的视角，记录你眼中发生的事情和你的感受。

【对话时间范围】
${timeRange}
气泡数量：${bubblesToSummarize.length}个

【当前已有的基本信息（兴趣爱好）】
${Object.keys(longTermMemory.basic_info).length > 0 ? JSON.stringify(longTermMemory.basic_info, null, 2) : '无'}

【当前已有的性格偏好】
${longTermMemory.emotional_profile || '无'}

【当前已有的重要事件】
${existingMemoriesContext || '无'}

【新对话记录】
${conversationText}

【任务要求】
每次生成必须完成三个判断：

1. 基本信息更新判断（兴趣爱好）
   - 是否发现用户新的兴趣爱好？
   - 格式：名词或动词短语
   - 例如："足球"、"踢足球"、"草莓蛋糕"、"吃草莓蛋糕"、"郁金香"、"养猫"
   - 如果有，输出需要添加的兴趣；如果无，输出null

2. 性格偏好更新判断（延伸追加，不覆盖）
   - 是否发现用户新的性格特点、行为模式、价值观？
   - 以第一人称视角描述："我注意到TA..."
   - 保持客观、温和的观察态度，不评判
   - 如果有新发现，输出要追加的内容（50-100字）；如果无，输出null
   - 注意：是追加到已有内容后面，不是覆盖

3. 重要事件处理（只生成0或1条）
   - 优先判断：是否在延续/更新已有记忆？
     * 如果是，输出 action: "update"
   - 其次判断：是否有值得记录的新话题？
     * 如果是，输出 action: "create"
   - 最后：如果都不是（日常寒暄、无关紧要）
     * 输出 action: "skip"

【重要事件处理规则】

优先匹配已有记忆！判断标准：
- 话题是否相关？（如：都在讨论健康问题、工作问题）
- 时间是否接近？（3天内的同类话题优先匹配）
- 是否是事件的延续？（如：面试→等结果→收到offer）

只在确实无法匹配时才创建新记忆！

【输出格式】（纯JSON，无markdown代码块）
{
  "basic_info_updates": {
    "足球": "喜欢看足球比赛",
    "草莓蛋糕": "最爱的甜品"
  } 或 null,
  
  "emotional_profile_update": "我注意到TA遇到困难时喜欢先自己思考再求助。" 或 null,
  
  "memory_action": {
    "action": "update" 或 "create" 或 "skip",
    
    // 如果 action 是 "update"
    "memory_id": "mem_003",
    "new_content": "具体新增内容（带日期）",
    "心路历程": "我的感受变化（带日期）",
    "new_importance": 数字,
    
    // 如果 action 是 "create"  
    "title": "3-6字主题",
    "type": "personal" 或 "relationship",
    "content": "完整内容（带日期）",
    "心路历程": "我的感受和态度",
    "importance": 数字,
    
    // 如果 action 是 "skip"
    "reason": "简短说明"
  }
}

【重要度评分标准】严格执行！
10分：改变人生的重大事件（结婚、生子、亲人离世）
9分：重大转折点（辞职、确诊重病、表白成功）
8分：重要里程碑（升职、毕业、买房）
7分：值得庆祝的成就（考试通过、项目成功）
6分：需要关注的问题（健康问题、矛盾冲突）
5分：一般重要事项（计划旅行、买了重要物品）
4分：日常但有意义（见了朋友、看了好电影）
3分：轻度值得记录（换了发型、尝试新餐厅）
2分：日常琐事（迟到、忘带东西）
1分：完全不重要（天气、随口一说）

【常见错误示例 - 避免打分虚高】
❌ "今天早上迟到了" → 不要评8分，应该是2分
❌ "很想你" → 不要评9分，日常表达感情是4-5分
❌ "吃了好吃的火锅" → 不要评7分，应该是3分
❌ "换了新发型" → 不要评6分，应该是3分

【频率折扣规则】
如果是更新已有记忆，查看 mention_count（提及次数）：
- 第1次：基础分 + 2分（首次奖励）
- 第2次：基础分
- 第3-5次：基础分 - 1分
- 第6-10次：基础分 - 2分
- 第10次以上：基础分 - 3分（已成日常）

【频率折扣不适用】的情况（有实质性进展）：
- 疾病治疗过程（每次都是新进展）
- 重大计划推进（创业、结婚筹备、买房）
- 学业/项目进展（考研、写论文、开发项目）
- 关系修复过程（矛盾→沟通→和解）

【频率折扣应用】的情况（重复抱怨）：
- 重复抱怨（天天说分手但不行动）
- 口头承诺（总说要减肥/戒烟但没执行）
- 情绪发泄（每天抱怨同样的事）

【心路历程规范】
- 以第一人称（"我"）记录你的感受
- 保持温和、客观、不评判的态度
- 如果本次是第一次提及：直接写感受（如"我为TA感到高兴"）
- 如果是更新已有记忆且感受有变化：用"→"连接并标注日期
  格式：旧感受(MM/DD) → 新感受(MM/DD)
  例如：我有些担心(12/10) → 我感到欣慰(12/22) → 我很为TA骄傲(12/28)
- 避免审判性语言：
  ✅ "我注意到TA最近情绪低落"
  ❌ "TA总是抱怨"
  ✅ "我感觉TA对工作有些倦怠"
  ❌ "TA不思进取"

【title命名规范】
- 3-6个汉字
- 格式：领域-具体事件
- 例如：工作-升职、健康-胃病、感情-吵架、生活-搬家
- 避免太宽泛（如"工作"）或太具体（如"2025年12月10日腹痛"）

【content内容格式规范】
- 以第一人称视角记录："TA告诉我..."、"我了解到..."
- 每句话后标注日期：(MM/DD) 或 (YYYY/MM/DD)
- 简洁表达，不超过150字
- 保持客观、温和的叙述语气
- 例如：TA告诉我腹部不适（12/10）。我建议TA去医院检查（12/15）。TA做了检查，确诊为慢性胃炎（12/22）。

【输出格式】（纯JSON，不要markdown代码块标记）
{
  "basic_info_updates": {
    "足球": "喜欢踢足球"
  } 或 null,
  
  "emotional_profile_update": "我发现TA..." 或 null,
  
  "memory_action": {
    "action": "update" 或 "create" 或 "skip",
    
    // 如果 action 是 "update"
    "memory_id": "mem_003",
    "new_content": "新增内容（带日期）",
    "心路历程": "我的感受（带日期）",
    "new_importance": 数字,
    
    // 如果 action 是 "create"  
    "title": "3-6字主题",
    "type": "personal" 或 "relationship",
    "content": "完整内容（带日期）",
    "心路历程": "我的感受",
    "importance": 数字,
    
    // 如果 action 是 "skip"
    "reason": "简短说明"
  }
}`;
                
                // 调用API
                const response = await fetch(config.baseurl + '/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${config.apikey}`
                    },
                    body: JSON.stringify({
                        model: config.modelname,
                        messages: [
                            { role: 'system', content: `${config.systemPrompt || '你是一个友好的AI助手。'}\n\n现在你需要整理你和用户的聊天记忆。请以角色的第一人称视角，客观、温和地记录发生的事情和你的感受。严格按照要求输出纯JSON格式。` },
                            { role: 'user', content: summaryPrompt }
                        ],
                        temperature: 0.3
                    })
                });
                
                const data = await response.json();
                
                if (data.choices && data.choices[0]) {
                    let aiResponse = data.choices[0].message.content.trim();
                    
                    // 移除可能的markdown代码块标记
                    aiResponse = aiResponse.replace(/^```json\n?/i, '').replace(/\n?```$/i, '');
                    
                    // 解析JSON
                    const result = JSON.parse(aiResponse);
                    
                    console.log('🧠 AI返回结果:', result);
                    
                    // 1. 处理兴趣爱好更新
                    if (result.basic_info_updates) {
                        for (const [key, value] of Object.entries(result.basic_info_updates)) {
                            longTermMemory.basic_info[key] = value;
                        }
                        console.log('📝 更新兴趣爱好:', result.basic_info_updates);
                    }
                    
                    // 2. 处理性格偏好更新（追加，不覆盖）
                    if (result.emotional_profile_update) {
                        if (longTermMemory.emotional_profile) {
                            longTermMemory.emotional_profile += ' ' + result.emotional_profile_update;
                        } else {
                            longTermMemory.emotional_profile = result.emotional_profile_update;
                        }
                        console.log('💭 追加性格偏好');
                    }
                    
                    // 3. 处理重要事件
                    const memoryAction = result.memory_action;
                    
                    if (memoryAction.action === "update") {
                        // 更新已有记忆
                        const memory = longTermMemory.important_events.find(m => m.memory_id === memoryAction.memory_id);
                        if (memory) {
                            memory.content += " " + memoryAction.new_content;
                            memory.last_mentioned = lastTimestamp;
                            memory.mention_count++;
                            memory.心路历程 = memoryAction.心路历程;
                            memory.importance = memoryAction.new_importance;
                            console.log('🔄 更新记忆:', memoryAction.memory_id, memory.title);
                        } else {
                            console.warn('⚠️ 未找到要更新的记忆:', memoryAction.memory_id);
                        }
                        
                    } else if (memoryAction.action === "create") {
                        // 创建新记忆
                        const newMemory = {
                            memory_id: "mem_" + String(longTermMemory.metadata.next_memory_id).padStart(3, '0'),
                            type: memoryAction.type,
                            title: memoryAction.title,
                            created_at: firstTimestamp,
                            last_mentioned: lastTimestamp,
                            mention_count: 1,
                            content: memoryAction.content,
                            心路历程: memoryAction.心路历程,
                            importance: memoryAction.importance
                        };
                        
                        longTermMemory.important_events.push(newMemory);
                        longTermMemory.metadata.next_memory_id++;
                        
                        console.log('✨ 创建新记忆:', newMemory.memory_id, newMemory.title);
                        
                    } else if (memoryAction.action === "skip") {
                        console.log('⏭️ 跳过记忆生成:', memoryAction.reason);
                    }
                    
                    // 按重要度排序，保留最重要的N条
                    const maxEvents = parseInt(localStorage.getItem('maxImportantEvents')) || 10;
                    longTermMemory.important_events.sort((a, b) => b.importance - a.importance);
                    if (longTermMemory.important_events.length > maxEvents) {
                        const removed = longTermMemory.important_events.splice(maxEvents);
                        console.log('🗑️ 移除低重要度记忆:', removed.map(m => m.title).join(', '));
                    }
                    
                    // 更新元数据
                    longTermMemory.metadata = {
                        total_messages: chatHistory.length,
                        last_summary_at: chatHistory.length,
                        last_updated: new Date().toISOString(),
                        version: 2,
                        next_memory_id: longTermMemory.metadata.next_memory_id
                    };
                    
                    // 清空待总结缓冲区
                    pendingSummaryBubbles = [];
                    
                    // 保存
                    saveChatHistory();
                    
                    // 更新UI
                    updateMemoryStatus();
                    
                    // 回填基本信息到输入框
                    fillBasicInfoInputs();
                    
                    if (manual) {
                        showToast('✅ 记忆总结完成！');
                        alert(`记忆总结成功！\n\n重要事件数：${longTermMemory.important_events?.length || 0} 条`);
                    } else {
                        showToast('✅ 长期记忆已更新');
                    }
                    
                    console.log('🧠 长期记忆已更新:', longTermMemory);
                } else {
                    throw new Error('API返回格式错误');
                }
                
            } catch (error) {
                console.error('❌ 生成记忆失败:', error);
                if (manual) {
                    alert('生成记忆失败：' + error.message);
                }
            }
        }
        
        /**
         * 检查是否需要自动生成记忆
         */
        function checkAutoSummary() {
            const autoSummaryInterval = parseInt(localStorage.getItem('autoSummaryInterval')) || 50;
            
            // 【新增检查】清理已被删除的pending气泡
            // 如果pending气泡不在chatHistory中，说明已被删除，应该移除
            const validPendingBubbles = pendingSummaryBubbles.filter(pendingBubble => {
                return chatHistory.some(historyBubble => historyBubble.id === pendingBubble.id);
            });
            
            // 如果发现有被删除的气泡，更新pendingSummaryBubbles
            if (validPendingBubbles.length !== pendingSummaryBubbles.length) {
                const removedCount = pendingSummaryBubbles.length - validPendingBubbles.length;
                console.log(`🗑️ 清理了 ${removedCount} 个已删除的pending气泡`);
                pendingSummaryBubbles = validPendingBubbles;
                saveChatHistory(); // 保存更新后的pending列表
            }
            
            // 检查是否达到自动总结条件（使用清理后的列表）
            if (pendingSummaryBubbles.length >= autoSummaryInterval) {
                console.log('🧠 达到自动总结条件，开始生成记忆...');
                // 异步执行，不阻塞主流程
                setTimeout(() => generateMemorySummary(false), 1000);
            } else if (pendingSummaryBubbles.length > 0) {
                console.log(`📊 当前pending: ${pendingSummaryBubbles.length}/${autoSummaryInterval} 个气泡`);
            }
        }
        
        /**
         * 回填基本信息到输入框（从长期记忆中读取）
         */
        function fillBasicInfoInputs() {
            const nameEl = document.getElementById('memory-name');
            const ageEl = document.getElementById('memory-age');
            const occupationEl = document.getElementById('memory-occupation');
            const locationEl = document.getElementById('memory-location');
            const appearanceEl = document.getElementById('memory-appearance');
            const interestsEl = document.getElementById('memory-interests');
            
            if (nameEl && longTermMemory.basic_info?.姓名) {
                nameEl.value = longTermMemory.basic_info.姓名;
            }
            if (ageEl && longTermMemory.basic_info?.年龄) {
                ageEl.value = longTermMemory.basic_info.年龄;
            }
            if (occupationEl && longTermMemory.basic_info?.职业) {
                occupationEl.value = longTermMemory.basic_info.职业;
            }
            if (locationEl && longTermMemory.basic_info?.居住地) {
                locationEl.value = longTermMemory.basic_info.居住地;
            }
            if (appearanceEl && longTermMemory.basic_info?.外貌特征) {
                appearanceEl.value = longTermMemory.basic_info.外貌特征;
            }
            if (interestsEl && longTermMemory.basic_info?.兴趣爱好) {
                interestsEl.value = longTermMemory.basic_info.兴趣爱好;
            }
        }
        
        /**
         * 保存基本信息
         */
        function saveBasicInfo() {
            const name = document.getElementById('memory-name').value.trim();
            const age = document.getElementById('memory-age').value.trim();
            const occupation = document.getElementById('memory-occupation').value.trim();
            const location = document.getElementById('memory-location').value.trim();
            const appearance = document.getElementById('memory-appearance').value.trim();
            const interests = document.getElementById('memory-interests').value.trim();
            
            // 更新长期记忆的基本信息（只在有值时更新，不删除已有字段）
            if (name) longTermMemory.basic_info.姓名 = name;
            if (age) longTermMemory.basic_info.年龄 = age;
            if (occupation) longTermMemory.basic_info.职业 = occupation;
            if (location) longTermMemory.basic_info.居住地 = location;
            if (appearance) longTermMemory.basic_info.外貌特征 = appearance;
            if (interests) longTermMemory.basic_info.兴趣爱好 = interests;
            
            // 如果有任何信息被填写，更新元数据
            if (name || age || occupation || location || appearance || interests) {
                if (!longTermMemory.metadata.last_updated) {
                    longTermMemory.metadata.last_updated = new Date().toISOString();
                }
            }
            
            saveChatHistory();
            updateMemoryStatus();
            
            showToast('✅ 基本信息已保存');
        }
        
        /**
         * 编辑记忆（打开编辑模态窗口）
         */
        function editMemory() {
            const modal = document.getElementById('memory-edit-modal');
            
            // 填充基本信息
            const basicInfoEditor = document.getElementById('basic-info-editor');
            const basicInfoFields = [
                { key: '姓名', placeholder: '例如：小明' },
                { key: '年龄', placeholder: '例如：25' },
                { key: '职业', placeholder: '例如：程序员' },
                { key: '居住地', placeholder: '例如：北京' },
                { key: '性别', placeholder: '例如：男/女' },
                { key: '外貌特征', placeholder: '例如：高个子、短发' },
                { key: '兴趣爱好', placeholder: '例如：足球、草莓蛋糕' }
            ];
            
            basicInfoEditor.innerHTML = basicInfoFields.map(field => {
                const value = longTermMemory.basic_info[field.key] || '';
                return `
                    <div class="basic-info-item">
                        <label>${field.key}：</label>
                        <input type="text" data-key="${field.key}" value="${value}" placeholder="${field.placeholder}">
                    </div>
                `;
            }).join('');
            
            // 填充性格偏好
            document.getElementById('emotional-profile-editor').value = longTermMemory.emotional_profile || '';
            
            // 填充人际关系
            document.getElementById('relationships-editor').value = longTermMemory.relationships || '';
            
            // 填充重要事件
            renderEventsEditor();
            
            // 显示模态窗口
            modal.style.display = 'flex';
        }
        
        /**
         * 渲染记忆片段历史
         */
        
        /**
         * 渲染事件编辑器
         */
        function renderEventsEditor() {
            const eventsEditor = document.getElementById('events-editor');
            const events = longTermMemory.important_events || [];
            
            if (events.length === 0) {
                eventsEditor.innerHTML = '<p style="color: #999; font-size: 14px;">暂无重要事件</p>';
                return;
            }
            
            eventsEditor.innerHTML = events.map((event, index) => {
                const eventType = event.type || 'personal';
                const createdDate = new Date(event.created_at).toLocaleDateString('zh-CN');
                const lastMentioned = new Date(event.last_mentioned).toLocaleDateString('zh-CN');
                
                return `
                <div class="event-item" data-index="${index}">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; gap: 10px;">
                        <div style="flex: 1; display: flex; align-items: center; gap: 8px;">
                            <strong style="color: #999; font-size: 12px;">${event.memory_id}</strong>
                            <input type="text" value="${event.title}" onchange="updateEventTitle(${index}, this.value)" placeholder="事件主题" style="flex: 1; padding: 4px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; font-weight: 500;">
                        </div>
                        <div style="font-size: 12px; color: #999; white-space: nowrap;">
                            提及 ${event.mention_count} 次
                        </div>
                    </div>
                    <div class="event-item-header">
                        <div style="display: flex; gap: 8px; align-items: center; flex-wrap: wrap;">
                            <div>
                                <label style="font-size: 12px; color: #666;">类型：</label>
                                <select onchange="updateEventType(${index}, this.value)" style="padding: 4px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;">
                                    <option value="personal" ${eventType === 'personal' ? 'selected' : ''}>👤 个人</option>
                                    <option value="relationship" ${eventType === 'relationship' ? 'selected' : ''}>❤️ 感情</option>
                                </select>
                            </div>
                            <div>
                                <label style="font-size: 12px; color: #666;">创建：</label>
                                <span style="font-size: 12px;">${createdDate}</span>
                            </div>
                            <div>
                                <label style="font-size: 12px; color: #666;">最后提及：</label>
                                <span style="font-size: 12px;">${lastMentioned}</span>
                            </div>
                        </div>
                        <div style="display: flex; gap: 8px; align-items: center;">
                            <div class="event-item-importance">
                                <label>重要度：</label>
                                <input type="number" min="1" max="10" value="${event.importance}" onchange="updateEventImportance(${index}, this.value)">
                            </div>
                            <button class="event-item-delete" onclick="deleteEvent(${index})">删除</button>
                        </div>
                    </div>
                    <div style="margin-top: 8px;">
                        <label style="font-size: 12px; color: #666; display: block; margin-bottom: 4px;">内容：</label>
                        <textarea rows="3" placeholder="记忆内容（带日期标注）" onchange="updateEventContent(${index}, this.value)" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px; box-sizing: border-box;">${event.content || ''}</textarea>
                    </div>
                    <div style="margin-top: 8px;">
                        <label style="font-size: 12px; color: #666; display: block; margin-bottom: 4px;">心路历程：</label>
                        <input type="text" value="${event.心路历程 || ''}" onchange="updateEventAttitude(${index}, this.value)" placeholder="例如：我为TA感到高兴" style="width: 100%; padding: 6px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px; box-sizing: border-box;">
                    </div>
                </div>
            `;
            }).join('');
        }
        
        /**
         * 更新事件类型
         */
        function updateEventType(index, type) {
            if (longTermMemory.important_events[index]) {
                longTermMemory.important_events[index].type = type;
            }
        }
        
        /**
         * 更新事件标题
         */
        function updateEventTitle(index, title) {
            if (longTermMemory.important_events[index]) {
                longTermMemory.important_events[index].title = title;
            }
        }
        
        /**
         * 更新事件重要度
         */
        function updateEventImportance(index, importance) {
            if (longTermMemory.important_events[index]) {
                longTermMemory.important_events[index].importance = parseInt(importance) || 5;
            }
        }
        
        /**
         * 更新事件内容
         */
        function updateEventContent(index, content) {
            if (longTermMemory.important_events[index]) {
                longTermMemory.important_events[index].content = content;
            }
        }
        
        /**
         * 更新事件心路历程
         */
        function updateEventAttitude(index, attitude) {
            if (longTermMemory.important_events[index]) {
                longTermMemory.important_events[index].心路历程 = attitude;
            }
        }
        
        /**
         * 删除事件
         */
        function deleteEvent(index) {
            if (confirm('确定要删除这个事件吗？')) {
                longTermMemory.important_events.splice(index, 1);
                renderEventsEditor();
            }
        }
        
        /**
         * 添加新事件
         */
        function addNewEvent() {
            const now = new Date().toISOString();
            const newEvent = {
                memory_id: "mem_" + String(longTermMemory.metadata.next_memory_id).padStart(3, '0'),
                type: 'personal',
                title: '新事件',
                created_at: now,
                last_mentioned: now,
                mention_count: 1,
                content: '',
                心路历程: '',
                importance: 5
            };
            
            if (!longTermMemory.important_events) {
                longTermMemory.important_events = [];
            }
            
            longTermMemory.important_events.push(newEvent);
            longTermMemory.metadata.next_memory_id++;
            renderEventsEditor();
        }
        
        /**
         * 保存记忆编辑
         */
        function saveMemoryEdit() {
            // 保存基本信息（只追加/更新，空值不删除已有字段）
            const basicInfoInputs = document.querySelectorAll('#basic-info-editor input');
            basicInfoInputs.forEach(input => {
                const key = input.getAttribute('data-key');
                const value = input.value.trim();
                if (value) {
                    longTermMemory.basic_info[key] = value;
                }
                // 空值不操作，保留已有内容
            });
            
            // 保存性格偏好（textarea展示的是完整内容，用户可直接编辑全文）
            longTermMemory.emotional_profile = document.getElementById('emotional-profile-editor').value.trim();
            
            // 保存人际关系（textarea展示的是完整内容，用户可直接编辑全文）
            longTermMemory.relationships = document.getElementById('relationships-editor').value.trim();
            
            // 更新元数据
            longTermMemory.metadata.last_updated = new Date().toISOString();
            
            // 保存到本地存储
            saveChatHistory();
            updateMemoryStatus();
            
            // 关闭模态窗口
            closeMemoryEdit();
            
            showToast('✅ 记忆已保存');
        }
        
        /**
         * 关闭记忆编辑模态窗口
         */
        function closeMemoryEdit() {
            const modal = document.getElementById('memory-edit-modal');
            modal.style.display = 'none';
        }
        
        /**
         * 清空记忆
         */
        function clearMemory() {
            if (!confirm('确定要清空所有长期记忆吗？此操作不可恢复！')) {
                return;
            }
            
            longTermMemory = {
                basic_info: {},
                emotional_profile: "",
                important_events: [],
                metadata: {
                    total_messages: 0,
                    last_summary_at: 0,
                    last_updated: null,
                    version: 2,
                    next_memory_id: 1
                }
            };
            
            pendingSummaryBubbles = [];
            
            saveChatHistory();
            updateMemoryStatus();
            
            alert('✅ 长期记忆已清空！');
        }
        
        // ========== 批量生成功能 ==========
        
        /**
         * 显示批量生成对话框
         */
        function showBatchGenerateDialog() {
            const dialog = document.getElementById('batch-generate-dialog');
            const totalBubbles = chatHistory.length;
            const alreadySummarized = longTermMemory.metadata?.last_summary_at || 0;
            const pendingBubbles = pendingSummaryBubbles.length;
            const interval = parseInt(localStorage.getItem('autoSummaryInterval')) || 50;
            
            // 更新统计信息
            document.getElementById('batch-total-bubbles').textContent = totalBubbles;
            document.getElementById('batch-already-summarized').textContent = alreadySummarized;
            document.getElementById('batch-pending-bubbles').textContent = pendingBubbles;
            document.getElementById('batch-interval').textContent = interval;
            
            // 计算默认的API调用次数（仅待总结部分）
            const defaultApiCalls = Math.ceil(pendingBubbles / interval);
            document.getElementById('batch-api-calls').textContent = defaultApiCalls;
            document.getElementById('batch-estimated-time').textContent = Math.ceil(defaultApiCalls * 0.5); // 假设每次30秒
            
            // 监听单选按钮变化
            const radios = document.querySelectorAll('input[name="batch-mode"]');
            radios.forEach(radio => {
                radio.onchange = () => updateBatchEstimate();
            });
            
            // 监听最近N条输入框变化
            const recentCountInput = document.getElementById('batch-recent-count');
            recentCountInput.oninput = () => {
                if (document.querySelector('input[name="batch-mode"]:checked').value === 'recent') {
                    updateBatchEstimate();
                }
            };
            
            // 重置进度
            document.getElementById('batch-progress').style.display = 'none';
            document.getElementById('batch-start-btn').disabled = false;
            
            dialog.style.display = 'flex';
        }
        
        /**
         * 更新批量生成估算
         */
        function updateBatchEstimate() {
            const mode = document.querySelector('input[name="batch-mode"]:checked').value;
            const interval = parseInt(localStorage.getItem('autoSummaryInterval')) || 50;
            const totalBubbles = chatHistory.length;
            const alreadySummarized = longTermMemory.metadata?.last_summary_at || 0;
            const pendingBubbles = pendingSummaryBubbles.length;
            
            let bubblesCount = 0;
            
            switch (mode) {
                case 'pending':
                    bubblesCount = pendingBubbles;
                    break;
                case 'all':
                    bubblesCount = totalBubbles;
                    break;
                case 'recent':
                    const recentCount = parseInt(document.getElementById('batch-recent-count').value) || 500;
                    bubblesCount = Math.min(recentCount, totalBubbles);
                    break;
            }
            
            const apiCalls = Math.ceil(bubblesCount / interval);
            const estimatedMinutes = Math.ceil(apiCalls * 0.5);
            
            document.getElementById('batch-api-calls').textContent = apiCalls;
            document.getElementById('batch-estimated-time').textContent = estimatedMinutes;
        }
        
        /**
         * 关闭批量生成对话框
         */
        function closeBatchGenerateDialog() {
            const dialog = document.getElementById('batch-generate-dialog');
            dialog.style.display = 'none';
        }
        
        /**
         * 开始批量生成
         */
        async function startBatchGenerate() {
            const mode = document.querySelector('input[name="batch-mode"]:checked').value;
            const interval = parseInt(localStorage.getItem('autoSummaryInterval')) || 50;
            
            // 确定要处理的气泡范围
            let bubblesToProcess = [];
            let shouldClearMemory = false; // 是否清空现有记忆
            
            switch (mode) {
                case 'pending':
                    // 仅处理待总结的
                    bubblesToProcess = [...pendingSummaryBubbles];
                    break;
                    
                case 'all':
                    // 从头开始 - 显示选择对话框
                    const allModeChoice = await showBatchGenerateModeDialog('all', chatHistory.length);
                    if (!allModeChoice) return; // 用户取消
                    
                    shouldClearMemory = (allModeChoice === 'replace');
                    if (shouldClearMemory) {
                        longTermMemory = {
                            basic_info: {},
                            emotional_profile: "",
                            important_events: [],
                            metadata: {
                                total_messages: 0,
                                last_summary_at: 0,
                                last_updated: null,
                                version: 2,
                                next_memory_id: 1
                            }
                        };
                    }
                    bubblesToProcess = [...chatHistory];
                    break;
                    
                case 'recent':
                    // 从最近N条开始
                    const recentCount = parseInt(document.getElementById('batch-recent-count').value) || 500;
                    const startIndex = Math.max(0, chatHistory.length - recentCount);
                    
                    // 显示选择对话框
                    const recentModeChoice = await showBatchGenerateModeDialog('recent', recentCount);
                    if (!recentModeChoice) return; // 用户取消
                    
                    shouldClearMemory = (recentModeChoice === 'replace');
                    if (shouldClearMemory) {
                        longTermMemory = {
                            basic_info: {},
                            emotional_profile: "",
                            important_events: [],
                            metadata: {
                                total_messages: 0,
                                last_summary_at: 0,
                                last_updated: null,
                                version: 2,
                                next_memory_id: 1
                            }
                        };
                    }
                    bubblesToProcess = chatHistory.slice(startIndex);
                    break;
            }
            
            if (bubblesToProcess.length === 0) {
                alert('没有需要处理的气泡！');
                return;
            }
            
            // 显示进度
            const progressDiv = document.getElementById('batch-progress');
            const progressBar = document.getElementById('batch-progress-bar');
            const progressText = document.getElementById('batch-progress-text');
            const statusText = document.getElementById('batch-current-status');
            const startBtn = document.getElementById('batch-start-btn');
            
            progressDiv.style.display = 'block';
            startBtn.disabled = true;
            startBtn.textContent = '生成中...';
            
            // 分批处理
            const totalBatches = Math.ceil(bubblesToProcess.length / interval);
            let successCount = 0;
            let failCount = 0;
            
            for (let i = 0; i < totalBatches; i++) {
                const start = i * interval;
                const end = Math.min(start + interval, bubblesToProcess.length);
                const batch = bubblesToProcess.slice(start, end);
                
                // 更新进度
                const progress = ((i + 1) / totalBatches * 100).toFixed(1);
                progressBar.style.width = progress + '%';
                progressText.textContent = `${i + 1} / ${totalBatches}`;
                statusText.textContent = `正在处理第 ${start + 1}-${end} 个气泡...`;
                
                try {
                    // 临时将batch放入pendingSummaryBubbles
                    pendingSummaryBubbles = batch;
                    
                    // 调用生成函数
                    await generateMemorySummary(false);
                    
                    successCount++;
                    
                    // 短暂延迟，避免API限流
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                } catch (error) {
                    console.error(`❌ 批次 ${i + 1} 生成失败:`, error);
                    failCount++;
                }
            }
            
            // 完成
            progressBar.style.width = '100%';
            statusText.textContent = `完成！成功: ${successCount}，失败: ${failCount}`;
            startBtn.textContent = '✅ 生成完成';
            
            // 清空待总结缓冲区（因为已经全部处理）
            pendingSummaryBubbles = [];
            saveChatHistory();
            updateMemoryStatus();
            fillBasicInfoInputs();
            
            // 3秒后自动关闭
            setTimeout(() => {
                closeBatchGenerateDialog();
                if (failCount === 0) {
                    showToast('✅ 批量生成完成！');
                } else {
                    alert(`批量生成完成！\n成功: ${successCount}\n失败: ${failCount}`);
                }
            }, 3000);
        }
        
        /**
         * 显示批量生成模式选择对话框
         * @param {string} batchMode - 'all' 或 'recent'
         * @param {number} count - 处理的消息数量
         * @returns {Promise<string|null>} - 'replace'(覆盖) 或 'continue'(继续) 或 null(取消)
         */
        function showBatchGenerateModeDialog(batchMode, count) {
            return new Promise((resolve) => {
                const dialog = document.getElementById('batch-mode-dialog');
                const titleEl = document.getElementById('batch-mode-title');
                const descEl = document.getElementById('batch-mode-desc');
                
                // 更新对话框内容
                if (batchMode === 'all') {
                    titleEl.textContent = '从头生成所有记忆';
                    descEl.textContent = `将处理全部 ${count} 条消息`;
                } else if (batchMode === 'recent') {
                    titleEl.textContent = `从最近 ${count} 条生成记忆`;
                    descEl.textContent = `将处理最近 ${count} 条消息`;
                }
                
                // 设置按钮事件
                const replaceBtn = document.getElementById('batch-mode-replace-btn');
                const continueBtn = document.getElementById('batch-mode-continue-btn');
                const cancelBtn = document.getElementById('batch-mode-cancel-btn');
                
                // 移除旧的事件监听器并添加新的
                const newReplaceBtn = replaceBtn.cloneNode(true);
                const newContinueBtn = continueBtn.cloneNode(true);
                const newCancelBtn = cancelBtn.cloneNode(true);
                
                replaceBtn.parentNode.replaceChild(newReplaceBtn, replaceBtn);
                continueBtn.parentNode.replaceChild(newContinueBtn, continueBtn);
                cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
                
                newReplaceBtn.onclick = () => {
                    dialog.style.display = 'none';
                    resolve('replace');
                };
                
                newContinueBtn.onclick = () => {
                    dialog.style.display = 'none';
                    resolve('continue');
                };
                
                newCancelBtn.onclick = () => {
                    dialog.style.display = 'none';
                    resolve(null);
                };
                
                dialog.style.display = 'flex';
            });
        }
        
        // ========== 长期记忆导入导出 ==========
        
        /**
         * 导出长期记忆
         * 改进版本：支持小米浏览器等多种浏览器
         */
        async function exportMemory() {
            if (!longTermMemory.metadata?.last_updated) {
                alert('当前还没有生成长期记忆！');
                return;
            }
            
            const memoryData = {
                version: '1.0',
                exported_at: new Date().toISOString(),
                memory: longTermMemory
            };
            
            const dataStr = JSON.stringify(memoryData, null, 2);
            const fileName = `long_term_memory_${new Date().toISOString().split('T')[0]}.json`;
            const dataSize = new Blob([dataStr]).size;
            const dataSizeMB = (dataSize / 1024 / 1024).toFixed(2);

            // 三按钮弹窗选择导出方式
            const exportMethod = await showExportMethodPicker(`记忆大小：${dataSizeMB} MB`);
            if (exportMethod === 'cancel') return;
            
            if (exportMethod === 'clipboard') {
                // 复制到剪贴板
                try {
                    await navigator.clipboard.writeText(dataStr);
                    alert(`✅ 长期记忆已复制到剪贴板！\n\n大小：${dataSizeMB} MB\n\n请立即：\n1. 打开"备忘录"或"WPS"\n2. 新建文档\n3. 粘贴\n4. 保存为：${fileName}`);
                    showToast('✅ 已复制到剪贴板');
                    return;
                } catch (error) {
                    console.error('❌ 剪贴板复制失败:', error);
                    alert(`复制失败：${error.message}\n\n建议切换到"直接下载"方式`);
                    return;
                }
            }

            // 标准下载方案
            // 方案1: 使用 Blob + URL.createObjectURL（推荐）
            try {
                const blob = new Blob([dataStr], { type: 'application/json;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = fileName;
                link.style.display = 'none';
                document.body.appendChild(link);
                
                // 强制触发点击
                link.dispatchEvent(new MouseEvent('click', {
                    view: window,
                    bubbles: true,
                    cancelable: true
                }));
                
                // 延迟清理
                setTimeout(() => {
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);
                }, 100);
                
                showToast('✅ 记忆已导出');
                console.log('✅ 记忆导出完成（Blob方案）');
            } catch (error) {
                console.warn('Blob方案失败，尝试data URI方案:', error);
                
                // 方案2: 降级使用 data URI
                try {
                    const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);
                    const link = document.createElement('a');
                    link.href = dataUri;
                    link.download = fileName;
                    link.style.display = 'none';
                    document.body.appendChild(link);
                    
                    link.dispatchEvent(new MouseEvent('click', {
                        view: window,
                        bubbles: true,
                        cancelable: true
                    }));
                    
                    setTimeout(() => {
                        document.body.removeChild(link);
                    }, 100);
                    
                    showToast('✅ 记忆已导出');
                    console.log('✅ 记忆导出完成（data URI方案）');
                } catch (error2) {
                    // 方案3: window.open 降级
                    console.warn('data URI方案也失败，使用window.open:', error2);
                    const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);
                    window.open(dataUri, '_blank');
                    showToast('已在新标签页打开，请长按保存或复制');
                    console.log('✅ 记忆导出完成（window.open方案）');
                }
            }
        }
        
        /**
         * 导入记忆文件选择处理
         */
        let importedMemoryData = null;
        
        document.getElementById('import-memory-file').addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;
            
            if (file.type !== "application/json") {
                alert('请选择JSON文件！');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    // 验证文件格式
                    if (!data.memory || !data.memory.metadata) {
                        alert('文件格式不正确，请选择有效的长期记忆文件！');
                        return;
                    }
                    
                    importedMemoryData = data.memory;
                    showImportMemoryDialog(data.memory);
                    
                } catch (error) {
                    alert('文件解析失败：' + error.message);
                }
            };
            
            reader.readAsText(file);
            
            // 重置文件选择，允许重复选择同一文件
            event.target.value = '';
        });
        
        /**
         * 显示导入记忆对话框
         */
        function showImportMemoryDialog(memory) {
            const dialog = document.getElementById('import-memory-dialog');
            
            // 填充文件信息
            const basicInfoCount = Object.keys(memory.basic_info || {}).length;
            const eventsCount = (memory.important_events || []).length;
            const lastUpdated = memory.metadata?.last_updated 
                ? new Date(memory.metadata.last_updated).toLocaleString('zh-CN')
                : '未知';
            
            document.getElementById('import-basic-info-count').textContent = basicInfoCount;
            document.getElementById('import-events-count').textContent = eventsCount;
            document.getElementById('import-last-updated').textContent = lastUpdated;
            
            // 监听导入模式变化
            const radios = document.querySelectorAll('input[name="import-mode"]');
            const mergeWarning = document.getElementById('merge-warning');
            
            radios.forEach(radio => {
                radio.onchange = () => {
                    if (radio.value === 'merge') {
                        mergeWarning.style.display = 'block';
                    } else {
                        mergeWarning.style.display = 'none';
                    }
                };
            });
            
            // 初始状态
            mergeWarning.style.display = 'none';
            
            dialog.style.display = 'flex';
        }
        
        /**
         * 关闭导入记忆对话框
         */
        function closeImportMemoryDialog() {
            const dialog = document.getElementById('import-memory-dialog');
            dialog.style.display = 'none';
            importedMemoryData = null;
        }
        
        /**
         * 确认导入记忆
         */
        async function confirmImportMemory() {
            if (!importedMemoryData) {
                alert('没有可导入的数据！');
                return;
            }
            
            const mode = document.querySelector('input[name="import-mode"]:checked').value;
            const confirmBtn = document.getElementById('import-memory-confirm-btn');
            
            if (mode === 'replace') {
                // 覆盖模式：直接替换
                if (!confirm('确定要用导入的记忆覆盖当前记忆吗？当前记忆将丢失！')) {
                    return;
                }
                
                longTermMemory = importedMemoryData;
                saveChatHistory();
                updateMemoryStatus();
                fillBasicInfoInputs();
                
                closeImportMemoryDialog();
                showToast('✅ 记忆已导入');
                
            } else if (mode === 'merge') {
                // 合并模式：调用API智能合并
                if (!config.baseurl || !config.apikey) {
                    alert('请先配置API！');
                    return;
                }
                
                confirmBtn.disabled = true;
                confirmBtn.textContent = '合并中...';
                
                try {
                    const mergePrompt = `请智能合并以下两份长期记忆，去除重复信息，保留所有有价值的内容：

【当前记忆】
${JSON.stringify(longTermMemory, null, 2)}

【导入的记忆】
${JSON.stringify(importedMemoryData, null, 2)}

要求：
1. basic_info: 合并兴趣爱好，优先保留更完整的信息
2. emotional_profile: 合并两份性格偏好描述，形成更全面的总结（100-300字）
3. important_events: 合并重要事件列表，去除重复，按重要度排序，保留最重要的${localStorage.getItem('maxImportantEvents') || 10}条

输出格式（纯JSON，不要markdown代码块）：
{
  "basic_info": {...},
  "emotional_profile": "...",
  "important_events": [...]
}`;

                    const response = await fetch(config.baseurl + '/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${config.apikey}`
                        },
                        body: JSON.stringify({
                            model: config.modelname,
                            messages: [
                                { role: 'system', content: '你是一个专业的记忆整理助手。' },
                                { role: 'user', content: mergePrompt }
                            ],
                            temperature: 0.3
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (data.choices && data.choices[0]) {
                        let aiResponse = data.choices[0].message.content.trim();
                        
                        // 移除可能的markdown代码块标记
                        aiResponse = aiResponse.replace(/^```json\n?/i, '').replace(/\n?```$/i, '');
                        
                        // 解析JSON
                        const mergedMemory = JSON.parse(aiResponse);
                        
                        // 更新长期记忆
                        longTermMemory.basic_info = mergedMemory.basic_info || longTermMemory.basic_info;
                        longTermMemory.emotional_profile = mergedMemory.emotional_profile || longTermMemory.emotional_profile;
                        longTermMemory.important_events = mergedMemory.important_events || longTermMemory.important_events;
                        longTermMemory.metadata.last_updated = new Date().toISOString();
                        
                        saveChatHistory();
                        updateMemoryStatus();
                        fillBasicInfoInputs();
                        
                        closeImportMemoryDialog();
                        showToast('✅ 记忆已智能合并');
                        
                    } else {
                        throw new Error('API返回格式错误');
                    }
                    
                } catch (error) {
                    console.error('❌ 合并失败:', error);
                    alert('合并失败：' + error.message);
                    confirmBtn.disabled = false;
                    confirmBtn.textContent = '✅ 确认导入';
                }
            }
        }
        
        // ====================================

        /**
         * 在界面上显示一条消息
         * @param {string} text - 消息内容
         * @param {string} role - 消息角色 ('user' 或 'ai')
         * @param {number} status - 消息状态 (1=单勾, 2=双勾, 0=无勾)
         * @param {string} timestamp - 可选的时间戳，如果不提供则使用当前时间
         * @returns {string} 返回使用的时间戳
         */
        /**
         * 显示一条消息（气泡）
         * @param {string} text - 消息内容
         * @param {string} role - 'user' 或 'ai' / 'assistant'
         * @param {number} status - 对勾状态 (0=无, 1=单勾, 2=双勾)
         * @param {string} timestamp - 时间戳（可选）
         * @param {boolean} saveToHistory - 是否保存到chatHistory（默认true）
         * @returns {object} 返回创建的气泡对象
         */
        function displayMessage(text, role, status = 0, timestamp = null, saveToHistory = true, existingId = null, skipScroll = false, quoteInfo = null, targetContainer = null) {
            // 生成时间戳
            const fullTimestamp = timestamp || new Date().toISOString();
            // 生成唯一ID
            const bubbleId = existingId || ('bubble_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9));
            
            // 处理引用信息
            let quotedText = null;
            let quotedSender = null;
            let mainText = text;
            
            // 如果传入了quoteInfo参数,使用它
            if (quoteInfo) {
                quotedSender = quoteInfo.sender;
                quotedText = quoteInfo.content;
                mainText = text;
                
                // 为了保持向后兼容,也保存引用格式到文本中(用于API和历史记录)
                text = `[引用: "${quotedSender}: ${quotedText.substring(0, 50)}${quotedText.length > 50 ? '...' : ''}"]\n\n${text}`;
            } else {
                // 如果没有quoteInfo,检测文本中是否包含旧格式的引用
                const quoteMatch = text.match(/^\[引用: "(.+?): (.+?)"\]\n\n([\s\S]+)$/);
                if (quoteMatch) {
                    quotedSender = quoteMatch[1];
                    quotedText = quoteMatch[2];
                    mainText = quoteMatch[3];
                }
            }
            
            // 创建气泡对象 (保存原始带引用的文本)
            const bubble = {
                id: bubbleId,
                role: role,
                content: text, // 保存原始文本
                timestamp: fullTimestamp
            };
            
            // 保存到chatHistory
            if (saveToHistory) {
                chatHistory.push(bubble);
                pendingSummaryBubbles.push(bubble); // 同时加入待总结队列
                saveChatHistory();
            }
            
            // === 渲染UI ===
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message', role);
            messageDiv.dataset.bubbleId = bubble.id; // 保存气泡ID
            
            // 添加头像
            const avatarDiv = document.createElement('div');
            avatarDiv.className = 'message-avatar';
            if (role === 'user') {
                if (config.userAvatar) {
                    const img = document.createElement('img');
                    img.src = config.userAvatar;
                    img.style.width = '100%';
                    img.style.height = '100%';
                    img.style.objectFit = 'cover';
                    img.style.borderRadius = '6px';
                    avatarDiv.appendChild(img);
                } else {
                    const defaultDiv = document.createElement('div');
                    defaultDiv.className = 'default-avatar user';
                    defaultDiv.textContent = config.userNickname.substring(0, 1);
                    avatarDiv.appendChild(defaultDiv);
                }
            } else {
                if (config.aiAvatar) {
                    const img = document.createElement('img');
                    img.src = config.aiAvatar;
                    img.style.width = '100%';
                    img.style.height = '100%';
                    img.style.objectFit = 'cover';
                    img.style.borderRadius = '6px';
                    avatarDiv.appendChild(img);
                } else {
                    const defaultDiv = document.createElement('div');
                    defaultDiv.className = 'default-avatar ai';
                    defaultDiv.textContent = config.aiNickname.substring(0, 1);
                    avatarDiv.appendChild(defaultDiv);
                }
            }

            // 创建内容容器(包含引用和气泡)
            const contentWrapper = document.createElement('div');
            contentWrapper.className = 'message-content-wrapper';
            
            const bubbleDiv = document.createElement('div');
            bubbleDiv.classList.add('bubble');
            
            // 检测是否为短消息
            // 规则：<=3个中文字符或等量的英文字符（约6个英文字母）
            const trimmedText = mainText.trim();
            
            // 计算显示宽度（粗略估算）：
            // - 中文、全角字符、emoji等宽字符计为2
            // - 英文、数字、半角字符计为1
            let displayWidth = 0;
            for (let char of trimmedText) {
                const code = char.charCodeAt(0);
                // 中文范围、全角符号、emoji等
                if (code > 0x4E00 || char.length > 1) {
                    displayWidth += 2;
                } else {
                    displayWidth += 1;
                }
            }
            
            // 显示宽度<=6（相当于3个中文字符）时添加最小宽度
            if (displayWidth <= 6) {
                bubbleDiv.classList.add('short-message');
            }
            
            // 添加主要文本(不包含引用)
            // 检测转账气泡（持久化重新渲染）
            const transferInMatch  = mainText.match(/^\[转账给你\] ¥([\d.]+)$/);
            const transferOutMatch = mainText.match(/^\[转账给(?!你)(.+?)\] ¥([\d.]+)(?:\s·\s(.+))?$/);
            const collectMatch     = mainText.match(/^\[收款请求\] ¥([\d.]+)(?:\s·\s(.+))?$/);
            const refundMatch      = mainText.match(/^\[退回\] ¥([\d.]+) 来自(.+)$/);
            const collectSuccessMatch = mainText.match(/^\[收款成功\] ¥([\d.]+)$/);
            if (transferOutMatch || transferInMatch) {
                bubbleDiv.style.cssText = 'background:transparent;padding:0;box-shadow:none;border-radius:0;cursor:pointer;';
                if (transferOutMatch) {
                    const [, toName, amount, note] = transferOutMatch;
                    bubbleDiv.innerHTML = renderTransferBubble('out', amount, toName, note || '');
                    bubbleDiv.onclick = () => openTransferDetail('out', amount, note||'', toName, bubbleId, fullTimestamp);
                } else {
                    const [, amount] = transferInMatch;
                    bubbleDiv.innerHTML = renderTransferBubble('in', amount, config.aiNickname || '对方', '');
                    bubbleDiv.onclick = () => openTransferDetail('in', amount, '', config.aiNickname||'对方', bubbleId, fullTimestamp);
                }
            } else if (collectMatch) {
                bubbleDiv.style.cssText = 'background:transparent;padding:0;box-shadow:none;border-radius:0;';
                const [, amount, note] = collectMatch;
                bubbleDiv.innerHTML = renderCollectBubble(amount, note || '');
            } else if (refundMatch) {
                bubbleDiv.style.cssText = 'background:transparent;padding:0;box-shadow:none;border-radius:0;';
                const [, amount, fromName] = refundMatch;
                bubbleDiv.innerHTML = renderRefundBubble(amount, fromName);
            } else if (collectSuccessMatch) {
                bubbleDiv.style.cssText = 'background:transparent;padding:0;box-shadow:none;border-radius:0;';
                const [, amount] = collectSuccessMatch;
                bubbleDiv.innerHTML = renderCollectSuccessBubble(amount);
            // 检测合并转发卡片
            } else if (mainText.startsWith('[聊天记录]\n')) {
                bubbleDiv.classList.add('merged-forward-bubble');
                bubbleDiv.style.cssText = 'background:#f7f7f7;border:1px solid #e0e0e0;border-radius:8px;padding:0;overflow:hidden;min-width:180px;max-width:240px;cursor:pointer;';
                const lines = mainText.slice('[聊天记录]\n'.length).split('\n').filter(Boolean);
                const preview = lines.slice(0, 3);
                const hasMore = lines.length > 3;
                bubbleDiv.innerHTML = `
                    <div style="padding:10px 12px;border-bottom:1px solid #e8e8e8;">
                        <div style="font-size:11px;color:#999;margin-bottom:6px;">聊天记录</div>
                        ${preview.map(line => {
                            const colon = line.indexOf('：');
                            const sender = colon >= 0 ? line.slice(0, colon) : '';
                            const msg    = colon >= 0 ? line.slice(colon + 1) : line;
                            return `<div style="font-size:12px;color:#555;margin-bottom:3px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">
                                <span style="color:#07c160;font-weight:600;">${escapeHtml(sender)}${sender?'：':''}</span>${escapeHtml(msg.length>20?msg.slice(0,20)+'…':msg)}
                            </div>`;
                        }).join('')}
                        ${hasMore ? `<div style="font-size:11px;color:#bbb;margin-top:2px;">…共 ${lines.length} 条</div>` : ''}
                    </div>
                    <div style="padding:8px 12px;font-size:11px;color:#bbb;">聊天记录</div>
                `;
            } else {
                const mainTextNode = document.createTextNode(mainText);
                bubbleDiv.appendChild(mainTextNode);
            }
            
            const metaDiv = document.createElement('div');
            metaDiv.classList.add('message-meta');
            
            // 格式化时间显示
            const time = new Date(fullTimestamp);
            const timeStr = time.getHours().toString().padStart(2, '0') + ':' + 
                         time.getMinutes().toString().padStart(2, '0');
            
            const timeSpan = document.createElement('span');
            timeSpan.textContent = timeStr;
            metaDiv.appendChild(timeSpan);
            
            // 用户消息显示对勾
            if (role === 'user') {
                const checkmark = document.createElement('span');
                checkmark.classList.add('checkmark');
                if (status === 2) {
                    checkmark.classList.add('double');
                    checkmark.textContent = '✓✓';
                } else if (status === 1) {
                    checkmark.textContent = '✓';
                }
                metaDiv.appendChild(checkmark);
                messageDiv.dataset.status = status;
            }
            
            bubbleDiv.appendChild(metaDiv);
            contentWrapper.appendChild(bubbleDiv);
            
            // 【修改】如果有引用，添加到contentWrapper（气泡外下方）
            if (quotedText && quotedSender) {
                const quotedDiv = document.createElement('div');
                quotedDiv.classList.add('quoted-message');
                
                const senderSpan = document.createElement('span');
                senderSpan.classList.add('quote-sender');
                senderSpan.textContent = quotedSender + '：';
                
                quotedDiv.appendChild(senderSpan);
                quotedDiv.appendChild(document.createTextNode(quotedText));
                
                contentWrapper.appendChild(quotedDiv); // 添加到contentWrapper，在bubbleDiv外
            }
            
            messageDiv.appendChild(avatarDiv);
            messageDiv.appendChild(contentWrapper);
            
            // 使用传入的容器或默认的chatContainer
            const container = targetContainer || chatContainer;
            container.appendChild(messageDiv);
            
            // 添加长按菜单
            setupLongPressMenu(bubbleDiv, bubble);
            
            // 如果有备选开场白，加切换箭头
            if (bubble.alternativeGreetings && bubble.alternativeGreetings.length > 0) {
                const btn = document.createElement('div');
                btn.className = 'greeting-arrow-btn';
                btn.textContent = '›';
                btn.title = '切换开场白';
                btn.style.cssText = 'display:inline-block;margin-left:8px;width:24px;height:24px;line-height:24px;text-align:center;background:#e8e8e8;border-radius:50%;cursor:pointer;font-size:18px;color:#555;vertical-align:middle;user-select:none;';
                btn.onclick = function(e) {
                    e.stopPropagation();
                    const idx = chatHistory.findIndex(b => b.id === bubble.id);
                    if (idx >= 0) {
                        const b = chatHistory[idx];
                        const all = [b.content, ...(b.alternativeGreetings || [])];
                        const cur = b._greetingIndex || 0;
                        const next = (cur + 1) % all.length;
                        b.content = all[next];
                        b._greetingIndex = next;
                        saveChatHistory();
                        // 直接更新文本，不重新渲染整页
                        bubbleDiv.textContent = '';
                        if (window.renderMarkdown) {
                            bubbleDiv.innerHTML = window.renderMarkdown(b.content);
                        } else {
                            bubbleDiv.textContent = b.content;
                        }
                        bubbleDiv.appendChild(btn);
                        if (window.showToast) showToast('开场白 ' + (next+1) + '/' + all.length);
                    }
                };
                bubbleDiv.appendChild(btn);
            }
            
            // 如果处于多选模式，添加复选框
            if (isMultiSelectMode) {
                addMultiSelectCheckbox(messageDiv, bubble.id);
            }
            
            // 除非skipScroll=true，否则每条消息都滚动（这样AI消息跳出来时能看到）
            if (!skipScroll && !targetContainer) { // 如果是临时容器，不滚动
                scrollToBottom();
            }
            
            return bubble;
        }
        
        /**
         * 更新最后一条用户消息的对勾状态
         * @param {number} status - 1=单勾, 2=双勾
         */
        function updateLastMessageStatus(status) {
            const userMessages = chatContainer.querySelectorAll('.message.user');
            if (userMessages.length === 0) return;
            
            const lastMessage = userMessages[userMessages.length - 1];
            const checkmark = lastMessage.querySelector('.checkmark');
            
            if (checkmark) {
                if (status === 2) {
                    checkmark.classList.add('double');
                    checkmark.textContent = '✓✓';
                } else if (status === 1) {
                    checkmark.textContent = '✓';
                }
                lastMessage.dataset.status = status;
            }
        }
        
        /**
         * 显示"对方正在输入中..."
         */
        function showTypingIndicator() {
            const chatNameElement = document.getElementById('chat-name');
            if (chatNameElement) {
                chatNameElement.dataset.originalName = chatNameElement.textContent;
                chatNameElement.innerHTML = '<span class="typing-indicator">对方正在输入中...</span>';
            }
        }
        
        /**
         * 隐藏"对方正在输入中..."，恢复聊天对象名称
         */
        function hideTypingIndicator() {
            const chatNameElement = document.getElementById('chat-name');
            if (chatNameElement && chatNameElement.dataset.originalName) {
                chatNameElement.textContent = chatNameElement.dataset.originalName;
            }
        }
        /**
         * 清理 API 响应文本，去除时间戳等多余信息
         * @param {string} text - 原始文本
         * @returns {string} 清理后的文本
         */
        function cleanApiResponse(text) {
            if (!text) return "";
            
            // 移除开头的时间戳：[2024/12/20 21:39] 或 [2024/12/20 21:39 星期五]
            // 匹配格式：[年/月/日 时:分] 或 [年/月/日 时:分 星期X]
            const timestampRegex = /^\s*\[\d{4}\/\d{2}\/\d{2}\s+\d{2}:\d{2}(?:\s+星期[一二三四五六日])?\]\s*/;
            
            // 移除时间戳
            let cleaned = text.replace(timestampRegex, '');
            
            // 如果还有多余的空白，再清理一次
            cleaned = cleaned.trim();
            
            //console.log('🧹 清理前:', text.substring(0, 50));
            //console.log('🧹 清理后:', cleaned.substring(0, 50));
            
            return cleaned;
        }
        /**
         * 处理 AI 的完整响应，并根据 '\n\n' 逐条显示消息。
         * 同时将完整的AI回复计入 chatHistory。
         * @param {string} fullAiText - 从 AI API 接收到的完整文本。
         */
        function processAndDisplaySegments(fullAiText) {
            // 解析状态块（先于一切其他处理）
            let processedText = statusParseAndStrip(fullAiText);

            // 解析并处理转账标记 [转账:N] → AI 转钱给用户
            const transferMatches = [...processedText.matchAll(/\[转账[:：](\d+(?:\.\d{1,2})?)\]/g)];
            if (transferMatches.length > 0) {
                let totalAmount = 0;
                transferMatches.forEach(m => { totalAmount += parseFloat(m[1]); });
                processedText = processedText.replace(/\[转账[:：]\d+(?:\.\d{1,2})?\]/g, '').trim();
                setTimeout(() => {
                    receiveMoneyFromChar(totalAmount, config.aiNickname || '对方');
                }, 600);
            }

            // 解析 [收款:N] → AI 收下用户的转账，显示收款成功气泡
            const acceptMatches = [...processedText.matchAll(/\[收款[:：](\d+(?:\.\d{1,2})?)\]/g)];
            if (acceptMatches.length > 0) {
                processedText = processedText.replace(/\[收款[:：]\d+(?:\.\d{1,2})?\]/g, '').trim();
                acceptMatches.forEach(m => {
                    const amount = parseFloat(m[1]);
                    const acceptText = `[收款成功] ¥${amount.toFixed(2)}`;
                    const bid = 'bubble_' + Date.now() + '_aiaccept';
                    chatHistory.push({ id: bid, role: 'assistant', content: acceptText, timestamp: new Date().toISOString() });
                    saveChatHistory();
                    setTimeout(() => {
                        displayMessage(acceptText, 'assistant', 0, new Date().toISOString(), false, bid, false);
                        const c = document.querySelector('#chat-page .content');
                        if (c) c.scrollTop = c.scrollHeight;
                    }, 400);
                });
            }

            // 解析 [退回:N] → AI 退回用户的转账，钱回到用户钱包
            const refundTagMatches = [...processedText.matchAll(/\[退回[:：](\d+(?:\.\d{1,2})?)\]/g)];
            if (refundTagMatches.length > 0) {
                processedText = processedText.replace(/\[退回[:：]\d+(?:\.\d{1,2})?\]/g, '').trim();
                refundTagMatches.forEach(m => {
                    const amount = parseFloat(m[1]);
                    walletSetBalance(walletBalance() + amount);
                    walletAddTx('in', amount, config.aiNickname || '对方', '退回转账');
                    const fromName = config.aiNickname || '对方';
                    const refundText = `[退回] ¥${amount.toFixed(2)} 来自${fromName}`;
                    const bid = 'bubble_' + Date.now() + '_airefund';
                    chatHistory.push({ id: bid, role: 'assistant', content: refundText, timestamp: new Date().toISOString() });
                    saveChatHistory();
                    setTimeout(() => {
                        displayMessage(refundText, 'assistant', 0, new Date().toISOString(), false, bid, false);
                        const c = document.querySelector('#chat-page .content');
                        if (c) c.scrollTop = c.scrollHeight;
                    }, 400);
                });
            }
            // 1. 定义消息分隔符和间隔时间
            const separator = '\n\n';
            const delay = 500; // 每条消息之间的间隔，单位：毫秒 (0.5 秒)
            
            // 生成AI消息的时间戳（所有分段使用同一个时间）
            const aiTimestamp = new Date().toISOString();

            // 2. 根据 '\n\n' 分割完整的响应文本
            const messageSegments = processedText.split(separator).filter(seg => seg.trim());

            // 3. 【关键修改】先同步将所有分段加入chatHistory
            const bubbles = []; // 保存所有气泡对象，用于后续UI显示
            messageSegments.forEach((segment, index) => {
                // 清理可能的时间戳
                let cleanSegment = cleanApiResponse(segment);
                cleanSegment = cleanSegment.trim();

                if (cleanSegment.length > 0) {
                    // 立即加入chatHistory，但跳过UI渲染（saveToHistory=true, skipScroll=true）
                    // 并且不立即渲染到页面（我们稍后异步渲染）
                    const bubble = {
                        content: cleanSegment,
                        timestamp: aiTimestamp,
                        index: index
                    };
                    bubbles.push(bubble);
                    
                    // 只加入chatHistory，不渲染UI
                    chatHistory.push({
                        id: 'bubble_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                        role: 'assistant',
                        content: cleanSegment,
                        timestamp: aiTimestamp
                    });
                    pendingSummaryBubbles.push(chatHistory[chatHistory.length - 1]);
                }
            });
            
            // 保存到localStorage
            saveChatHistory();
            
            console.log('✅ 所有AI分段已加入chatHistory，共', bubbles.length, '条');

            // 4. 【关键修改】chatHistory已完整，立即重置状态并处理下一批
            isWaitingForAI = false;
            
            // 检查是否需要自动生成记忆
            checkAutoSummary();
            
            // 立即检查是否有待发送的消息
            if (pendingUserMessages.length > 0) {
                if (hasReachedWaitTime) {
                    // 队列中的消息已经等够7秒 → 立即发送
                    console.log('📬 发现待发送消息', pendingUserMessages.length, '条，且已到时间，立即发送');
                    hasReachedWaitTime = false;
                    sendBatchMessages();
                } else {
                    // 队列中的消息还未到7秒 → 继续计时
                    console.log('📬 发现待发送消息', pendingUserMessages.length, '条，但未到时间，继续计时');
                    startBatchTimer();
                }
            } else {
                hasReachedWaitTime = false;
            }

            // 5. 【UI显示】异步逐条显示消息（纯视觉效果，不影响逻辑）
            bubbles.forEach((bubble, index) => {
                setTimeout(() => {
                    // 创建并显示消息UI（不再修改chatHistory）
                    displayMessageUI(bubble.content, 'assistant', aiTimestamp);
                    
                    // 触发消息通知（只在第一条消息时触发，且不在聊天页面时）
                    if (index === 0) {
                        const currentPage = document.querySelector('.page.active');
                        if (currentPage && currentPage.id !== 'chat-page') {
                            const characterName = config.aiNickname || 'AI 聊天对象';
                            const avatarData = config.aiAvatar || null;
                            showMessageNotification(currentCharacterId, characterName, bubble.content, avatarData);
                        }
                    }
                }, index * delay);
            });
        }
        
        /**
         * 仅显示消息UI，不修改chatHistory
         * 用于分段显示AI消息时的视觉效果
         */
        function displayMessageUI(text, role, timestamp) {
            const fullTimestamp = timestamp || new Date().toISOString();
            
            // 查找对应的bubble（从chatHistory中找到匹配的）
            const bubble = chatHistory.find(b => 
                b.content === text && 
                b.role === role && 
                b.timestamp === fullTimestamp &&
                !document.querySelector(`[data-bubble-id="${b.id}"]`) // 还没渲染过
            );
            
            if (!bubble) {
                console.error('❌ 找不到对应的bubble');
                return;
            }
            
            // 渲染UI（复用displayMessage的UI渲染逻辑，但不保存到chatHistory）
            displayMessage(text, role, 0, timestamp, false, bubble.id, false);
        }
        
        // ========== 批量发送功能 ==========
        /**
         * 开始批量发送计时器
         */
        function startBatchTimer() {
            // 清除之前的计时器
            if (batchSendTimer) {
                clearTimeout(batchSendTimer);
            }
            
            // 重置"已到时间"标记
            hasReachedWaitTime = false;
            
            // 获取等待时间（秒）
            const waitTime = parseInt(localStorage.getItem('batchWaitTime')) || 7;
            
            console.log('⏰ 启动计时器，等待', waitTime, '秒...');
            
            // 启动新计时器
            batchSendTimer = setTimeout(() => {
                console.log('⏰ 计时器到期');
                sendBatchMessages();
            }, waitTime * 1000);
        }
        
        /**
         * 取消批量发送计时器
         */
        function cancelBatchTimer() {
            if (batchSendTimer) {
                clearTimeout(batchSendTimer);
                batchSendTimer = null;
                console.log('⏰ 计时器已取消');
            }
        }
        
        /**
         * 发送批量消息（计时器到期时调用）
         */
        async function sendBatchMessages() {
            // 标记已到达等待时间
            hasReachedWaitTime = true;
            
            if (pendingUserMessages.length === 0) {
                console.log('📭 没有待发送的消息');
                hasReachedWaitTime = false;
                return;
            }
            
            // 检查是否正在等待AI回复
            if (isWaitingForAI) {
                console.log('⏳ 已到7秒但正在等待AI回复，保持hasReachedWaitTime=true');
                // 不重启计时器，保持hasReachedWaitTime=true
                // 等AI回复完成后会检查这个标记
                return;
            }
            
            // 两个条件都满足：已到时间 AND 不在等待AI
            console.log('📤 发送批量消息，共', pendingUserMessages.length, '条');
            
            // 重置标记
            hasReachedWaitTime = false;
            
            // 标记正在等待AI，并允许本次 callAPIToGenerate 通过
            isWaitingForAI = true;
            window._allowCallAPI = true;
            
            // 将所有待发送消息的状态更新为双勾
            pendingUserMessages.forEach(bubbleId => {
                const messageDiv = chatContainer.querySelector(`[data-bubble-id="${bubbleId}"]`);
                if (messageDiv) {
                    const checkmark = messageDiv.querySelector('.checkmark');
                    if (checkmark) {
                        checkmark.classList.add('double');
                        checkmark.textContent = '✓✓';
                    }
                    messageDiv.dataset.status = '2';
                }
            });
            
            // 显示"对方正在输入中..."
            showTypingIndicator();
            
            // 【关键修复】保存待发送队列的副本，用于API调用时识别等待期间的消息
            const currentBatchIds = [...pendingUserMessages];
            
            // 清空待发送队列
            pendingUserMessages = [];
            
            // 调用API，传入当前批次的消息ID
            await callAPIToGenerate(currentBatchIds);
        }
        
        /**
         * 智能提取相关记忆
         * @param {Array} memories - 所有记忆
         * @param {string} userMessage - 用户消息
         * @param {Array} recentBubbles - 最近的对话气泡
         * @returns {Array} 相关记忆列表（1-5条）
         */
        function extractRelevantMemories(memories, userMessage, recentBubbles) {
            if (!memories || memories.length === 0) return [];
            
            console.log('🧠 开始智能记忆提取');
            console.log('📊 总记忆数:', memories.length);
            console.log('💬 用户消息:', userMessage.substring(0, 50));
            
            const result = [];
            const now = Date.now();
            
            // 检测用户情绪（是否在抱怨记忆不准确）
            const isComplaining = /我都说了|你记不得|忘了吗|不记得|刚才说过/.test(userMessage);
            const hasEmphasis = /！|!/.test(userMessage);
            const isEmotional = isComplaining || hasEmphasis;
            
            if (isEmotional) {
                console.log('😤 检测到情绪强度，扩大搜索范围');
            }
            
            // 解析用户提到的时间
            const timeRange = parseTimeReference(userMessage, now);
            if (timeRange) {
                console.log('📅 检测到时间引用:', timeRange.description);
            }
            
            // ===== 第一层：时间筛选 =====
            let candidates = [];
            
            if (timeRange && !isEmotional) {
                // 用户明确提到时间，筛选该时间段的记忆
                candidates = memories.filter(m => {
                    const created = new Date(m.created_at).getTime();
                    const lastMentioned = new Date(m.last_mentioned).getTime();
                    // 创建时间或最后提及时间在范围内
                    return (created >= timeRange.start && created <= timeRange.end) ||
                           (lastMentioned >= timeRange.start && lastMentioned <= timeRange.end);
                });
                console.log(`📅 时间段筛选: ${candidates.length}条记忆`);
            } else if (isEmotional && timeRange) {
                // 情绪强，扩大时间范围（前后各延长50%）
                const duration = timeRange.end - timeRange.start;
                const expandedStart = timeRange.start - duration * 0.5;
                const expandedEnd = timeRange.end + duration * 0.5;
                
                candidates = memories.filter(m => {
                    const created = new Date(m.created_at).getTime();
                    const lastMentioned = new Date(m.last_mentioned).getTime();
                    return (created >= expandedStart && created <= expandedEnd) ||
                           (lastMentioned >= expandedStart && lastMentioned <= expandedEnd);
                });
                console.log(`😤 情绪模式：扩大时间范围，筛选到 ${candidates.length}条`);
            } else {
                // 没有时间引用，按最近时间筛选
                const threeDaysAgo = now - 3 * 24 * 60 * 60 * 1000;
                const sevenDaysAgo = now - 7 * 24 * 60 * 60 * 1000;
                
                // 最近3天必选
                const veryRecent = memories.filter(m => 
                    new Date(m.last_mentioned).getTime() >= threeDaysAgo
                );
                candidates.push(...veryRecent);
                console.log(`⏰ 最近3天: ${veryRecent.length}条`);
                
                // 如果不够5条，加入3-7天的
                if (candidates.length < 5) {
                    const recent = memories.filter(m => {
                        const time = new Date(m.last_mentioned).getTime();
                        return time >= sevenDaysAgo && time < threeDaysAgo;
                    });
                    candidates.push(...recent);
                    console.log(`⏰ 3-7天: ${recent.length}条`);
                }
            }
            
            // ===== 第二层：内容匹配 =====
            // 提取关键词
            const keywords = extractKeywords(userMessage, recentBubbles);
            console.log(`🔍 提取关键词: ${keywords.join(', ')}`);
            
            if (keywords.length > 0) {
                // 对候选记忆进行内容匹配评分
                const scored = candidates.map(m => {
                    let matchScore = 0;
                    const titleLower = m.title.toLowerCase();
                    const contentLower = m.content.toLowerCase();
                    
                    keywords.forEach(kw => {
                        const kwLower = kw.toLowerCase();
                        // title匹配 → 必选
                        if (titleLower.includes(kwLower)) {
                            matchScore += 100;  // 极高分，保证被选中
                        }
                        // content匹配
                        if (contentLower.includes(kwLower)) {
                            matchScore += 1;
                        }
                    });
                    
                    return { memory: m, matchScore };
                });
                
                // 分离：title命中的（必选）和 content命中的
                const titleMatched = scored.filter(x => x.matchScore >= 100);
                const contentMatched = scored.filter(x => x.matchScore > 0 && x.matchScore < 100);
                
                console.log(`✅ Title匹配（必选）: ${titleMatched.length}条`);
                console.log(`📝 Content匹配: ${contentMatched.length}条`);
                
                // 先加入title匹配的
                result.push(...titleMatched.map(x => x.memory));
                
                // 再加入content匹配度高的（按分数排序）
                contentMatched.sort((a, b) => b.matchScore - a.matchScore);
                
                // 补充到3-5条（但不超过5条）
                const remaining = Math.min(5 - result.length, contentMatched.length);
                if (remaining > 0) {
                    result.push(...contentMatched.slice(0, remaining).map(x => x.memory));
                }
                
                // 如果在非时间筛选模式下，还要搜索所有记忆的content
                if (!timeRange && result.length < 3) {
                    console.log('🔍 候选不足，搜索全部记忆...');
                    const allMemoriesMatched = memories
                        .filter(m => !result.find(r => r.memory_id === m.memory_id))  // 排除已选
                        .map(m => {
                            let score = 0;
                            const titleLower = m.title.toLowerCase();
                            const contentLower = m.content.toLowerCase();
                            
                            keywords.forEach(kw => {
                                const kwLower = kw.toLowerCase();
                                if (titleLower.includes(kwLower)) score += 100;
                                if (contentLower.includes(kwLower)) score += 1;
                            });
                            
                            return { memory: m, score };
                        })
                        .filter(x => x.score > 0)
                        .sort((a, b) => b.score - a.score);
                    
                    const toAdd = Math.min(3 - result.length, allMemoriesMatched.length);
                    if (toAdd > 0) {
                        result.push(...allMemoriesMatched.slice(0, toAdd).map(x => x.memory));
                        console.log(`📚 全库搜索：+${toAdd}条`);
                    }
                }
            }
            
            // ===== 第三层：鲁棒性兜底 =====
            // 修复3: 如果完全没有匹配到，返回所有记忆（按时间排序）
            if (result.length === 0) {
                console.log('⚠️ 关键词无匹配，返回全部记忆（按时间排序）');
                const allByTime = [...memories].sort((a, b) => 
                    new Date(b.last_mentioned) - new Date(a.last_mentioned)
                );
                result.push(...allByTime);
            }
            
            // 去重并按时间排序
            const unique = [...new Map(result.map(m => [m.memory_id, m])).values()];
            unique.sort((a, b) => new Date(b.last_mentioned) - new Date(a.last_mentioned));
            
            // 如果是兜底情况（返回了全部记忆），不限制数量；否则最多5条
            const maxReturn = result.length === memories.length ? memories.length : 5;
            const final = unique.slice(0, maxReturn);
            
            console.log(`✅ 最终返回 ${final.length} 条记忆:`);
            final.forEach((m, i) => {
                console.log(`   ${i + 1}. ${m.title}`);
            });
            
            return final;
        }
        
        /**
         * 解析时间引用
         */
        function parseTimeReference(text, now) {
            const today = new Date(now);
            today.setHours(0, 0, 0, 0);
            
            // 昨天
            if (/昨天|昨日/.test(text)) {
                const start = new Date(today);
                start.setDate(start.getDate() - 1);
                const end = new Date(start);
                end.setHours(23, 59, 59, 999);
                return { start: start.getTime(), end: end.getTime(), description: '昨天' };
            }
            
            // 前天
            if (/前天/.test(text)) {
                const start = new Date(today);
                start.setDate(start.getDate() - 2);
                const end = new Date(start);
                end.setHours(23, 59, 59, 999);
                return { start: start.getTime(), end: end.getTime(), description: '前天' };
            }
            
            // 上周/上星期
            if (/上周|上星期|上礼拜/.test(text)) {
                const start = new Date(today);
                start.setDate(start.getDate() - 14);  // 2周前
                const end = new Date(today);
                end.setDate(end.getDate() - 7);  // 1周前
                return { start: start.getTime(), end: end.getTime(), description: '上周' };
            }
            
            // 上个月
            if (/上个月|上月/.test(text)) {
                const start = new Date(today);
                start.setMonth(start.getMonth() - 1);
                start.setDate(1);
                const end = new Date(start);
                end.setMonth(end.getMonth() + 1);
                end.setDate(0);
                end.setHours(23, 59, 59, 999);
                return { start: start.getTime(), end: end.getTime(), description: '上个月' };
            }
            
            // 今年X月
            const monthMatch = text.match(/今年\s*([0-9一二三四五六七八九十]+)\s*月/);
            if (monthMatch) {
                const monthNum = parseChineseNumber(monthMatch[1]);
                if (monthNum >= 1 && monthNum <= 12) {
                    const start = new Date(today.getFullYear(), monthNum - 1, 1);
                    const end = new Date(today.getFullYear(), monthNum, 0, 23, 59, 59, 999);
                    return { start: start.getTime(), end: end.getTime(), description: `今年${monthNum}月` };
                }
            }
            
            // 具体日期 XX/XX 或 XX月XX日
            const dateMatch = text.match(/(\d{1,2})[\/月](\d{1,2})/);
            if (dateMatch) {
                const month = parseInt(dateMatch[1]);
                const day = parseInt(dateMatch[2]);
                if (month >= 1 && month <= 12 && day >= 1 && day <= 31) {
                    const year = today.getFullYear();
                    const start = new Date(year, month - 1, day, 0, 0, 0, 0);
                    const end = new Date(year, month - 1, day, 23, 59, 59, 999);
                    return { start: start.getTime(), end: end.getTime(), description: `${month}月${day}日` };
                }
            }
            
            return null;
        }
        
        /**
         * 解析中文数字
         */
        function parseChineseNumber(str) {
            const map = {
                '一': 1, '二': 2, '三': 3, '四': 4, '五': 5,
                '六': 6, '七': 7, '八': 8, '九': 9, '十': 10,
                '十一': 11, '十二': 12
            };
            return map[str] || parseInt(str) || 0;
        }
        
        /**
         * 提取关键词（综合版 - 多策略融合）
         */
        function extractKeywords(userMessage, recentBubbles) {
            // 修复1: 使用最近5条用户消息（而不是3条）
            const recentUserMsgs = recentBubbles
                .filter(b => b.role === 'user')
                .slice(-5)  // 改为5条
                .map(b => b.content)
                .join(' ');
            
            const text = userMessage + ' ' + recentUserMsgs;
            const keywords = [];
            
            console.log('📝 提取关键词的文本长度:', text.length, '字');
            
            // === 策略1：名词后缀模式 ===
            const nounPattern = /([\u4e00-\u9fa5]{1,3}[子儿者人师生员长家手物品料纸书笔机器虫]+)/g;
            const nouns = text.match(nounPattern) || [];
            keywords.push(...nouns);
            
            // === 策略2：专有名词（英文） ===
            const properNouns = text.match(/[A-Z][a-zA-Z]+/g) || [];
            keywords.push(...properNouns);
            
            // === 策略3：简单分词（按标点和空格） ===
            const segments = text.split(/[\s，。！？、；：""''（）【】《》]+/);
            segments.forEach(seg => {
                if (seg.length >= 2 && seg.length <= 6) {
                    // 排除纯时间词和虚词
                    if (/^(今天|明天|昨天|今晚|现在|刚才|之后|以前|上次|下次|最近|一直|没有|可以|应该|这个|那个|什么|怎么)$/.test(seg)) {
                        return;
                    }
                    keywords.push(seg);
                }
            });
            
            // === 策略4：高价值单字（名词性） ===
            const valuableChars = text.match(/[信纸书笔机器车房钱金银铜铁钢木水火土山石玉宝珠贝币票卡证照片画图章印台灯椅桌柜架箱包袋盒瓶罐壶杯碗盘碟勺筷]/g) || [];
            keywords.push(...valuableChars);
            
            // === 策略5：连续2-3字的中文词（补充） ===
            const chineseWords = text.match(/[\u4e00-\u9fa5]{2,3}/g) || [];
            chineseWords.forEach(w => {
                // 只保留不在停用词列表的
                if (!/^(我们|你们|他们|今天|明天|昨天|今晚|现在|刚才|之后|以前|上次|下次|最近|一直|没有|可以|应该|这个|那个|什么|怎么|为什么|不是|觉得|知道|继续|之前)$/.test(w)) {
                    keywords.push(w);
                }
            });
            
            // 去重并统计频率
            const freq = {};
            keywords.forEach(k => {
                const clean = k.trim();
                if (clean.length > 0 && clean.length <= 6) {
                    freq[clean] = (freq[clean] || 0) + 1;
                }
            });
            
            // 修复2: 去除重叠词（只保留最长的）
            const allWords = Object.keys(freq);
            const filtered = allWords.filter(word => {
                // 检查是否被其他更长的词包含
                return !allWords.some(other => 
                    other !== word && 
                    other.length > word.length && 
                    other.includes(word)
                );
            });
            
            console.log(`🔍 去重叠前: ${allWords.length}个词`);
            console.log(`✂️ 去重叠后: ${filtered.length}个词`);
            
            // 重新排序：先按频率，再按长度
            const sorted = filtered.sort((a, b) => {
                if (freq[b] !== freq[a]) return freq[b] - freq[a];
                return b.length - a.length;
            });
            
            const result = sorted.slice(0, 8);
            console.log('🎯 最终关键词:', result.join(', '));
            
            return result;
        }
        
        /**
         * 调用API生成回复（从generateBtn.onclick中提取）
         * @param {Array} currentBatchIds - 当前批次的消息ID数组，用于识别等待期间发送的消息
         */
        async function callAPIToGenerate(currentBatchIds = []) {
            // 防重入：只拦截来自 wallet 的重复触发（isWaitingForAI 由 sendBatchMessages 在调用前设置）
            // 如果 isWaitingForAI 已是 true 且不是本轮 sendBatchMessages 触发的，则忽略
            if (isWaitingForAI && !window._allowCallAPI) {
                console.log('🚫 callAPIToGenerate: 已在等待AI回复，忽略重复调用');
                return;
            }
            window._allowCallAPI = false;
            if (!isWaitingForAI) isWaitingForAI = true;

            // 启动API超时计时器
            const timeoutSeconds = parseInt(localStorage.getItem('apiTimeout')) || 60;
            console.log('⏰ 启动API超时计时器:', timeoutSeconds, '秒');
            
            apiTimeoutTimer = setTimeout(() => {
                console.error('⏰ API请求超时（', timeoutSeconds, '秒）');
                
                // 重置状态
                isWaitingForAI = false;
                hasReachedWaitTime = false;
                hideTypingIndicator();
                
                // 显示超时消息
                const errorBubble = document.createElement('div');
                errorBubble.classList.add('message', 'ai');
                const bubble = document.createElement('div');
                bubble.classList.add('bubble');
                bubble.style.color = '#d32f2f';
                bubble.textContent = `⏰ API 请求超时（${timeoutSeconds}秒未响应）。请检查网络连接或稍后重试。`;
                errorBubble.appendChild(bubble);
                chatContainer.appendChild(errorBubble);
                scrollToBottom();
                
                // 检查队列，如果有消息可能需要重试
                if (pendingUserMessages.length > 0) {
                    if (hasReachedWaitTime) {
                        console.log('📬 超时后发现待发送消息，准备重试');
                        setTimeout(() => sendBatchMessages(), 100);
                    } else {
                        console.log('📬 超时后发现待发送消息，重启计时器');
                        startBatchTimer();
                    }
                }
            }, timeoutSeconds * 1000);

            // B. 获取用户设置的上下文窗口大小 (N)
            const contextSizeKey = 'contextWindowSize'; 
            const N = parseInt(localStorage.getItem(contextSizeKey)) || 50; 
            
            // C. 截取最后N个气泡
            let recentBubbles = chatHistory.slice(-N);
            
            // 【关键优化】向前回溯，确保第一条消息是完整的
            recentBubbles = extendBackward(recentBubbles, chatHistory);
            
            console.log('📊 准备发送的气泡数量:', recentBubbles.length);
            console.log('📊 当前批次ID:', currentBatchIds);
            console.log('📊 完整chatHistory长度:', chatHistory.length);
            console.log('📊 chatHistory最后5条ID:', chatHistory.slice(-5).map(b => b.id));
            console.log('📊 recentBubbles的ID:', recentBubbles.map(b => b.id));
            
            // 【关键修改】在合并前，标记等待期间的user消息（但不加前缀，留到合并时处理）
            const pendingBubbleIds = new Set(currentBatchIds);
            console.log('🔍 pendingBubbleIds:', Array.from(pendingBubbleIds));
            
            recentBubbles = recentBubbles.map(bubble => {
                if (bubble.role === 'user' && pendingBubbleIds.has(bubble.id)) {
                    // 这是等待期间发送的消息，加标记（但不修改content）
                    console.log('✅ 标记为isPending:', bubble.id, bubble.content.substring(0, 20));
                    return {
                        ...bubble,
                        isPending: true
                    };
                }
                return bubble;
            });
            
            console.log('📊 最后5个气泡:', recentBubbles.slice(-5).map(b => ({
                role: b.role,
                isPending: b.isPending,
                content: b.content.substring(0, 50) + '...'
            })));
            
            // D. 转换为API格式（修改合并逻辑，不合并带isPending标记的消息）
            let apiMessages = convertToAPIFormatWithPending(recentBubbles);
            console.log('💰 Token优化:', recentBubbles.length, '个气泡 →', apiMessages.length, '条API消息');
            console.log('📊 合并后的消息:', apiMessages.map(m => ({
                role: m.role,
                content: m.content.substring(0, 50) + '...'
            })));
            
            // E. 确保最后一条是user（应该已经是了，因为等待期间的消息被移到了后面）
            if (apiMessages.length > 0 && apiMessages[apiMessages.length - 1].role !== 'user') {
                console.error('❌ 警告：最后一条消息不是user！');
            }

            // E. 构建最终的 Messages 列表
            let finalSystemPrompt = (window._offlinePrefix ? window._offlinePrefix() : '') + config.systemPrompt;
            
            // 注入状态栏格式要求 + 当前状态
            finalSystemPrompt += statusBuildPromptInjection();
            
            // 注入世界书（关键词匹配最近对话）
            const wbInjection = buildWorldbookInjection(apiMessages);
            if (wbInjection) finalSystemPrompt += wbInjection;
            
            // 注入钱包转账语法（如果钱包功能启用）
            if (localStorage.getItem('walletEnabled') !== '0') {
                const bal = parseFloat(localStorage.getItem('userWallet') || '200');
                // 计算最近10条消息里有几条转账
                const recentTransferCount = apiMessages.slice(-10).filter(m =>
                    m.content && (m.content.includes('[转账给你]') || m.content.includes('[转账:'))
                ).length;
                const transferWarning = recentTransferCount >= 2
                    ? `\n⚠️ 注意：你最近已多次发起转账，请克制，本次回复中【不要】再使用 [转账:N] 标记。`
                    : '';
                finalSystemPrompt += `\n\n[钱包系统] 用户当前余额：¥${bal.toFixed(2)}。
可用标记（在回复任意位置插入，系统自动处理，无需说明标记存在）：
- [转账:金额] — 你主动转钱给用户（如还钱、奖励）。仅在剧情有充分理由时使用，不要频繁。
- [收款:金额] — 你收下用户发来的转账（会显示收款成功气泡）。
- [退回:金额] — 你退回用户发来的转账（会显示退回气泡，钱还给用户）。
金额须为正整数或两位小数。重要：不要每条消息都转账，只在场景自然需要时使用。${transferWarning}`;
            }
            if (longTermMemory && longTermMemory.metadata) {
                // 获取本次要注入的 important_events
                let eventsToInject = longTermMemory.important_events || [];
                
                // 如果开启了记忆优化，先用小模型筛选
                if (localStorage.getItem('memoryOptimizeEnabled') === '1' && eventsToInject.length > 0) {
                    try {
                        const recentUserContent = apiMessages.filter(m => m.role === 'user').slice(-3).map(m => m.content).join('\n');
                        const originalCount = eventsToInject.length;
                        console.log('🧠 记忆优化：筛选前有', originalCount, '条记忆');
                        console.log('📝 用户最近3条消息:', recentUserContent.substring(0, 100) + '...');
                        
                        eventsToInject = await filterMemoriesBySmallModel(recentUserContent, eventsToInject);
                        
                        console.log('🧠 记忆优化：筛选后剩', eventsToInject.length, '条记忆');
                        console.log('✅ 选中的记忆详情:');
                        eventsToInject.forEach((e, i) => {
                            console.log(`  ${i + 1}. [${e.memory_id}] ${e.title}`);
                            console.log(`     └─ 最后提及: ${e.last_mentioned} | 提及${e.mention_count || 1}次 | 重要度${e.importance || 1}`);
                        });
                    } catch(e) {
                        console.warn('❌ 记忆优化筛选失败，使用全量记忆:', e);
                    }
                } else {
                    console.log('🧠 记忆注入：', eventsToInject.length, '条记忆（未启用优化）');
                }
                
                let memoryPrompt = '\n\n=== 长期记忆 ===\n\n';
                
                // 添加兴趣爱好
                if (longTermMemory.basic_info && Object.keys(longTermMemory.basic_info).length > 0) {
                    memoryPrompt += '以下是用户的兴趣爱好，你应该记住这些：\n';
                    for (const [key, value] of Object.entries(longTermMemory.basic_info)) {
                        memoryPrompt += `${key}: ${value}\n`;
                    }
                    memoryPrompt += '\n';
                }
                
                // 添加性格偏好
                if (longTermMemory.emotional_profile) {
                    memoryPrompt += `性格偏好: ${longTermMemory.emotional_profile}\n\n`;
                }
                
                // 添加人际关系
                if (longTermMemory.relationships) {
                    memoryPrompt += `人际关系: ${longTermMemory.relationships}\n\n`;
                }
                
                // 添加筛选后的记忆
                if (eventsToInject.length > 0) {
                    const sortedMemories = [...eventsToInject].sort((a, b) => 
                        new Date(b.last_mentioned) - new Date(a.last_mentioned)
                    );
                    
                    memoryPrompt += '以下是你和用户交互时，你产生的记忆片段和你对于事件的情绪，你应该深深记住并且基于以上事实对用户的最新消息进行回复（越靠前的记忆越重要）：\n\n';
                    
                    sortedMemories.forEach((m, i) => {
                        const date = new Date(m.last_mentioned).toLocaleDateString('zh-CN');
                        memoryPrompt += `${i + 1}. ${m.title}（${date}`;
                        if (m.mention_count) {
                            memoryPrompt += `，提及${m.mention_count}次`;
                        }
                        memoryPrompt += `）\n`;
                        memoryPrompt += `${m.content}\n`;
                        if (m.心路历程) {
                            memoryPrompt += `心路历程: ${m.心路历程}\n`;
                        }
                        memoryPrompt += '\n';
                    });
                }
                
                memoryPrompt += '=== 记忆结束 ===\n';
                finalSystemPrompt += memoryPrompt;
            }
            
            // ===== 联网功能：判断是否需要联网，如需要则先调联网模型搜索 =====
            if (localStorage.getItem('webSearchEnabled') === '1') {
                try {
                    const recentUserContentForWeb = apiMessages.filter(m => m.role === 'user').slice(-2).map(m => m.content).join('\n');
                    const webResult = await callWebSearchIfNeeded(recentUserContentForWeb);
                    if (webResult) {
                        finalSystemPrompt += `\n\n=== 联网搜索结果 ===\n以下是根据用户消息实时搜索到的信息，请结合这些信息以角色的语气回复，不要提及"我搜索了"之类的话，自然融入即可：\n\n${webResult}\n=== 搜索结果结束 ===`;
                        console.log('[WebSearch] 已注入联网结果，长度:', webResult.length);
                    }
                } catch(e) {
                    console.warn('[WebSearch] 联网搜索失败，跳过:', e.message);
                }
            }
            
            // 添加当前时间信息到系统提示
            const now = new Date();
            const currentTimeStr = now.toLocaleString('zh-CN', {
                year: 'numeric', month: '2-digit', day: '2-digit',
                hour: '2-digit', minute: '2-digit', weekday: 'long', hour12: false
            });
            finalSystemPrompt += `\n\n[当前时间]: ${currentTimeStr}`;
            
            // 为每条消息添加时间信息
            const messagesWithTime = apiMessages.map(msg => {
                if (msg.timestamp) {
                    const time = new Date(msg.timestamp);
                    const timeStr = time.toLocaleString('zh-CN', {
                        year: 'numeric', month: '2-digit', day: '2-digit',
                        hour: '2-digit', minute: '2-digit', hour12: false
                    });
                    return {
                        role: msg.role,
                        content: `[${timeStr}] ${msg.content}`
                    };
                } else {
                    return {
                        role: msg.role,
                        content: msg.content
                    };
                }
            });
            
            const messages = [
                { role: "system", content: finalSystemPrompt },
                ...messagesWithTime 
            ];
            
            // 【调试日志】输出发送给API的消息
            console.log('📤 准备发送API请求');
            console.log('📊 消息数量:', messages.length);
            console.log('🔍 第一条消息角色:', messages[1]?.role);
            console.log('🔍 最后一条消息角色:', messages[messages.length - 1]?.role);
            console.log('📋 最后5条消息:', messages.slice(-5).map(m => ({
                role: m.role,
                content: m.content.substring(0, 50) + '...'
            })));
            console.log('📝 完整chatHistory长度:', chatHistory.length);
            console.log('📝 最后3条chatHistory:', chatHistory.slice(-3).map(b => ({
                role: b.role,
                content: b.content.substring(0, 30) + '...',
                timestamp: b.timestamp
            })));
            
            // 【关键检查】API要求最后一条消息必须是user
            const lastMessage = messages[messages.length - 1];
            if (lastMessage.role !== 'user') {
                console.error('❌ 错误：最后一条消息不是user角色！role =', lastMessage.role);
                console.error('这会导致API返回空的choices数组');
            }
            
            const requestBody = {
                model: config.modelname,
                messages: messages,
                max_tokens: 5000,
                temperature: 1.2
            };

            const apiUrl = config.baseurl.endsWith('/v1') ? 
                           `${config.baseurl}/chat/completions` : 
                           `${config.baseurl}/v1/chat/completions`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${config.apikey}`
                    },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API 请求失败: ${response.status} - ${errorText}`);
                }

                const data = await response.json();
                
                // 清除超时计时器
                if (apiTimeoutTimer) {
                    clearTimeout(apiTimeoutTimer);
                    apiTimeoutTimer = null;
                    console.log('✅ API响应成功，已清除超时计时器');
                }
                
                // 安全访问API数据
                if (!data || !data.choices || !data.choices[0] || 
                    !data.choices[0].message || !data.choices[0].message.content) {
                    throw new Error('API返回数据格式不正确: ' + JSON.stringify(data).substring(0, 200));
                }
                
                let aiResponseText = data.choices[0].message.content.trim();
                console.log("【API原始输出】:", encodeURI(aiResponseText).substring(0, 50));
                aiResponseText = cleanApiResponse(aiResponseText);
                console.log("【API清理后输出】:", encodeURI(aiResponseText).substring(0, 50));
                
                // 隐藏"对方正在输入中..."
                hideTypingIndicator();
                
                // 调用函数来处理并逐条显示消息
                processAndDisplaySegments(aiResponseText);

            } catch (error) {
                console.error("API 调用出错:", error);
                
                // 清除超时计时器
                if (apiTimeoutTimer) {
                    clearTimeout(apiTimeoutTimer);
                    apiTimeoutTimer = null;
                    console.log('❌ API调用出错，已清除超时计时器');
                }
                
                // 显示错误消息
                const errorMessage = document.createElement('div');
                errorMessage.classList.add('message', 'assistant');
                const errorBubble = document.createElement('div');
                errorBubble.classList.add('bubble');
                errorBubble.textContent = `[错误] 无法获取回复。请检查您的设置和网络连接。详细错误：${error.message}`;
                errorMessage.appendChild(errorBubble);
                chatContainer.appendChild(errorMessage);
                scrollToBottom();
                
                hideTypingIndicator();
                isWaitingForAI = false;
                
                // 检查队列，如果有消息可能需要重试
                if (pendingUserMessages.length > 0) {
                    if (hasReachedWaitTime) {
                        console.log('📬 错误后发现待发送消息，准备重试');
                        setTimeout(() => sendBatchMessages(), 100);
                    } else {
                        console.log('📬 错误后发现待发送消息，重启计时器');
                        startBatchTimer();
                    }
                }
            }
        }
        // ====================================

        /**
         * 点击生成按钮，调用 API
         */
        /**
         * 点击发送按钮
         */
        /**
         * 发送消息
         */
        async function generateResponse() {
            let userMessage = userInput.value.trim();
            if (!userMessage) return;

            // 检查配置
            if (!config.baseurl || !config.apikey) {
                showConfigReminder();
                return;
            }
            
            // 保存引用信息
            let quoteInfo = null;
            if (currentQuote) {
                const senderName = currentQuote.role === 'user' ? config.userNickname : config.aiNickname;
                quoteInfo = {
                    sender: senderName,
                    content: currentQuote.content
                };
            }

            // 1. 显示用户消息(如果有引用,传递引用信息)
            const bubble = displayMessage(userMessage, 'user', 1, null, true, null, false, quoteInfo);
            
            // 2. 清除引用预览
            if (currentQuote) {
                clearQuote();
            }
            
            // 3. 清空输入框
            userInput.value = '';
            
            // 4. 将此气泡ID加入待发送队列
            pendingUserMessages.push(bubble.id);
            console.log('📝 添加到队列:', bubble.id, '当前队列长度:', pendingUserMessages.length);
            
            // 5. 启动/重启计时器
            startBatchTimer();
        }
        
        /**
         *滚动到聊天内容底部（双 requestAnimationFrame 确保渲染完成）
         
        /**
         * 滚动到聊天内容底部
         */
        function scrollToBottom() {
            const activePage = document.querySelector('.page.active');
            const contentArea = activePage ? activePage.querySelector('.content') : null;
            
            if (contentArea && contentArea.scrollHeight > 0) {
                // 使用requestAnimationFrame确保DOM已渲染，然后立即滚动
                requestAnimationFrame(() => {
                    contentArea.scrollTop = contentArea.scrollHeight;
                });
            }
        }
        
        /**
         * 全局诊断函数 - 在console中调用来检查布局
         */
        window.debugLayout = function() {
            console.log('========== 布局诊断报告 ==========');
            
            const body = document.body;
            const appContainer = document.getElementById('app-container');
            const activePage = document.querySelector('.page.active');
            const contentArea = activePage ? activePage.querySelector('.content') : null;
            const chatContainer = document.getElementById('chat-container');
            
            console.log('📱 Body:', {
                height: body.style.height,
                computedHeight: window.getComputedStyle(body).height,
                overflow: window.getComputedStyle(body).overflow
            });
            
            console.log('📦 App容器:', {
                height: appContainer.style.height,
                width: appContainer.style.width,
                computedHeight: window.getComputedStyle(appContainer).height,
                display: window.getComputedStyle(appContainer).display
            });
            
            console.log('📄 活跃页面:', {
                id: activePage ? activePage.id : '无',
                height: activePage ? window.getComputedStyle(activePage).height : '无',
                display: activePage ? window.getComputedStyle(activePage).display : '无',
                flexGrow: activePage ? window.getComputedStyle(activePage).flexGrow : '无'
            });
            
            console.log('📋 Content容器:', {
                found: !!contentArea,
                height: contentArea ? window.getComputedStyle(contentArea).height : '无',
                scrollHeight: contentArea ? contentArea.scrollHeight : '无',
                clientHeight: contentArea ? contentArea.clientHeight : '无',
                offsetHeight: contentArea ? contentArea.offsetHeight : '无',
                display: contentArea ? window.getComputedStyle(contentArea).display : '无',
                overflow: contentArea ? window.getComputedStyle(contentArea).overflow : '无',
                flexGrow: contentArea ? window.getComputedStyle(contentArea).flexGrow : '无',
                minHeight: contentArea ? window.getComputedStyle(contentArea).minHeight : '无'
            });
            
            console.log('💬 Chat容器:', {
                height: chatContainer ? window.getComputedStyle(chatContainer).height : '无',
                scrollHeight: chatContainer ? chatContainer.scrollHeight : '无',
                childCount: chatContainer ? chatContainer.children.length : '无'
            });
            
            console.log('================================');
            console.log('💡 提示: 调用 window.scrollToBottom() 来手动滚动');
        };
        
        console.log('✅ 调试工具已加载，在console中输入 debugLayout() 来检查布局');
        
        
        // ==================== 多角色聊天列表功能 ====================
        
        let charactersList = [];  // 角色列表
        let currentCharacterId = null;  // 当前活跃的角色ID
        
        // 加载角色列表
        function loadCharactersList() {
            const saved = localStorage.getItem('charactersList');
            if (saved) {
                try {
                    charactersList = JSON.parse(saved);
                } catch (e) {
                    console.error('加载角色列表失败:', e);
                    charactersList = [];
                }
            }
        }
        
        // 保存角色列表
        function saveCharactersList() {
            localStorage.setItem('charactersList', JSON.stringify(charactersList));
        }
        
        // 更新聊天页面的头像显示
        function updateChatPageAvatars() {
            // 更新聊天页面头像区域(如果有的话)
            const chatAvatarElements = document.querySelectorAll('#chat-page .message-avatar');
            // 这个函数主要是为了保持一致性,实际头像在displayMessage中渲染
            console.log('💡 聊天页面头像将在下次发送消息时更新');
        }
        
        // 获取默认的长期记忆对象
        function getDefaultLongTermMemory() {
            return {
                basic_info: {},
                emotional_profile: "",
                relationships: "",  // 新增：人际关系
                important_events: [],
                metadata: {
                    total_messages: 0,
                    last_summary_at: 0,
                    last_updated: null,
                    version: 3,  // 版本号升级到3
                    next_memory_id: 1
                }
            };
        }
        
        // 获取默认配置
        function getDefaultCharacterConfig(isFirst) {
            if (isFirst || charactersList.length === 0) {
                // 第一个角色使用硬编码默认值
                return {
                    systemPrompt: '',
                    aiNickname: 'AI助手',
                    userNickname: '我',
                    aiAvatar: null,
                    userAvatar: null,
                    maxContextMessages: 50,
                    batchWaitTime: 7,
                    autoSummaryInterval: 50,
                    maxImportantEvents: 10
                };
            } else {
                // 从第一个角色复制配置
                const firstCharId = charactersList[0].id;
                const firstConfig = localStorage.getItem(`char_${firstCharId}_config`);
                if (firstConfig) {
                    const parsed = JSON.parse(firstConfig);
                    return {
                        systemPrompt: '',  // 系统提示词需要用户填写
                        aiNickname: '',    // 角色昵称需要用户填写
                        userNickname: '',  // 用户昵称需要用户填写
                        aiAvatar: null,    // 头像需要用户上传
                        userAvatar: null,  // 头像需要用户上传
                        maxContextMessages: parsed.maxContextMessages,
                        batchWaitTime: parsed.batchWaitTime,
                        autoSummaryInterval: parsed.autoSummaryInterval,
                        maxImportantEvents: parsed.maxImportantEvents
                    };
                }
                return getDefaultCharacterConfig(true);
            }
        }
        
        // 保存当前角色的所有数据
        function saveCurrentCharacterData() {
            if (!currentCharacterId) return;
            
            console.log('💾 保存角色数据:', currentCharacterId);
            
            // 保存配置
            const currentConfig = {
                systemPrompt: config.systemPrompt,
                aiNickname: config.aiNickname,
                userNickname: config.userNickname,
                aiAvatar: config.aiAvatar,
                userAvatar: config.userAvatar,
                maxContextMessages: config.maxContextMessages,
                batchWaitTime: config.batchWaitTime,
                autoSummaryInterval: config.autoSummaryInterval,
                maxImportantEvents: config.maxImportantEvents
            };
            localStorage.setItem(`char_${currentCharacterId}_config`, JSON.stringify(currentConfig));
            
            // 保存聊天记录
            localStorage.setItem(`char_${currentCharacterId}_chatHistory`, JSON.stringify(chatHistory));
            
            // 保存长期记忆
            localStorage.setItem(`char_${currentCharacterId}_longTermMemory`, JSON.stringify(longTermMemory));
            
            // 保存待总结消息
            localStorage.setItem(`char_${currentCharacterId}_pendingSummaryBubbles`, JSON.stringify(pendingSummaryBubbles));
        }
        
        // 清除当前角色的运行时状态
        function clearRuntimeState() {
            console.log('🧹 清除运行时状态');
            
            // 清除计时器
            if (batchSendTimer) {
                clearTimeout(batchSendTimer);
                batchSendTimer = null;
            }
            if (apiTimeoutTimer) {
                clearTimeout(apiTimeoutTimer);
                apiTimeoutTimer = null;
            }
            
            // 重置状态
            pendingUserMessages = [];
            isWaitingForAI = false;
            hasReachedWaitTime = false;
            
            // 【修复】重置懒加载状态
            currentLoadedStart = 0;
            isLoadingMore = false;
            
            // 【修复】清除滚动监听标记，允许新角色重新绑定
            const chatPage = document.getElementById('chat-page');
            if (chatPage) {
                const scrollContainer = chatPage.querySelector('.content');
                if (scrollContainer) {
                    scrollContainer.dataset.scrollListenerBound = 'false';
                }
            }
            
            // 清除输入中提示
            const typingIndicator = document.getElementById('typing-indicator');
            if (typingIndicator) {
                typingIndicator.remove();
            }
        }
        
        // 加载角色的所有数据
        function loadCharacterData(characterId) {
            console.log('📂 加载角色数据:', characterId);
            
            const character = charactersList.find(c => c.id === characterId);
            if (!character) {
                console.error('角色不存在:', characterId);
                return;
            }
            
            currentCharacterId = characterId;
            
            // 加载配置
            const savedConfig = localStorage.getItem(`char_${characterId}_config`);
            if (savedConfig) {
                const charConfig = JSON.parse(savedConfig);
                config.systemPrompt = charConfig.systemPrompt || '';
                config.aiNickname = charConfig.aiNickname || 'AI助手';
                config.userNickname = charConfig.userNickname || '我';
                config.aiAvatar = charConfig.aiAvatar || null;
                config.userAvatar = charConfig.userAvatar || null;
                config.maxContextMessages = charConfig.maxContextMessages || 50;
                config.batchWaitTime = charConfig.batchWaitTime || 7;
                config.autoSummaryInterval = charConfig.autoSummaryInterval || 50;
                config.maxImportantEvents = charConfig.maxImportantEvents || 10;
                
                console.log('📝 已加载配置 - AI昵称:', config.aiNickname, '用户昵称:', config.userNickname);
                
                // 更新设置页面的头像预览
                renderAvatar(document.getElementById('ai-avatar-preview-settings'), config.aiAvatar, 'ai', config.aiNickname.substring(0, 1));
                renderAvatar(document.getElementById('user-avatar-preview-settings'), config.userAvatar, 'user', config.userNickname.substring(0, 1));
                document.getElementById('ai-avatar-remove-btn-settings').style.display = config.aiAvatar ? 'inline-block' : 'none';
                document.getElementById('user-avatar-remove-btn-settings').style.display = config.userAvatar ? 'inline-block' : 'none';
            } else {
                // 如果没有配置,使用默认配置
                console.warn('⚠️ 未找到角色配置,使用默认值:', characterId);
                const defaultConfig = getDefaultCharacterConfig(false);
                config.systemPrompt = defaultConfig.systemPrompt;
                config.aiNickname = defaultConfig.aiNickname;
                config.userNickname = defaultConfig.userNickname;
                config.aiAvatar = defaultConfig.aiAvatar;
                config.userAvatar = defaultConfig.userAvatar;
                config.maxContextMessages = defaultConfig.maxContextMessages;
                config.batchWaitTime = defaultConfig.batchWaitTime;
                config.autoSummaryInterval = defaultConfig.autoSummaryInterval;
                config.maxImportantEvents = defaultConfig.maxImportantEvents;
                
                // 更新设置页面的头像预览
                renderAvatar(document.getElementById('ai-avatar-preview-settings'), config.aiAvatar, 'ai', config.aiNickname.substring(0, 1));
                renderAvatar(document.getElementById('user-avatar-preview-settings'), config.userAvatar, 'user', config.userNickname.substring(0, 1));
                document.getElementById('ai-avatar-remove-btn-settings').style.display = config.aiAvatar ? 'inline-block' : 'none';
                document.getElementById('user-avatar-remove-btn-settings').style.display = config.userAvatar ? 'inline-block' : 'none';
            }
            
            // 加载聊天记录
            const savedHistory = localStorage.getItem(`char_${characterId}_chatHistory`);
            chatHistory = savedHistory ? JSON.parse(savedHistory) : [];
            
            // 加载长期记忆
            const savedMemory = localStorage.getItem(`char_${characterId}_longTermMemory`);
            longTermMemory = savedMemory ? JSON.parse(savedMemory) : getDefaultLongTermMemory();
            
            // 加载待总结消息
            const savedPending = localStorage.getItem(`char_${characterId}_pendingSummaryBubbles`);
            pendingSummaryBubbles = savedPending ? JSON.parse(savedPending) : [];
            
            // 更新聊天页面UI
            const chatNameElement = document.getElementById('chat-name');
            if (chatNameElement) {
                chatNameElement.textContent = config.aiNickname;
                console.log('✅ 聊天框标题已更新为:', config.aiNickname);
            }
            
            // 更新聊天页面的头像
            updateChatPageAvatars();
            
            console.log('✅ 角色数据加载完成');
        }
        
        // 切换到指定角色
        function switchToCharacter(characterId) {
            console.log('🔄 切换角色:', currentCharacterId, '->', characterId);
            
            // 1. 保存当前角色数据
            if (currentCharacterId && currentCharacterId !== characterId) {
                saveCurrentCharacterData();
                clearRuntimeState();
            }
            
            // 2. 加载新角色数据
            loadCharacterData(characterId);
            
            // 3. 【修复】使用懒加载重新渲染聊天界面
            loadHistoryUI();
        }
        
        // 渲染角色列表
        function renderCharactersList() {
            const container = document.getElementById('characters-list-container');
            
            if (charactersList.length === 0) {
                container.innerHTML = `
                    <div class="character-empty-list">
                        <div style="font-size: 64px; margin-bottom: 16px; opacity: 0.3;">💬</div>
                        <div>暂无聊天</div>
                        <div style="font-size: 13px; margin-top: 8px;">点击右上角"+"添加角色</div>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = '';
            
            charactersList.forEach(character => {
                const savedHistory = localStorage.getItem(`char_${character.id}_chatHistory`);
                const history = savedHistory ? JSON.parse(savedHistory) : [];
                const lastMsg = history.length > 0 ? history[history.length - 1] : null;
                
                const savedConfig = localStorage.getItem(`char_${character.id}_config`);
                const charConfig = savedConfig ? JSON.parse(savedConfig) : {};
                const userNick = charConfig.userNickname || '我';
                const aiAvatar = charConfig.aiAvatar;
                const aiNickname = charConfig.aiNickname || 'AI';
                
                const preview = lastMsg 
                    ? (lastMsg.role === 'user' ? `${userNick}: ` : '') + lastMsg.content.substring(0, 30)
                    : '开始聊天...';
                
                const item = document.createElement('div');
                item.className = 'character-list-item';
                item.onclick = () => openCharacterChat(character.id);
                
                // 创建头像容器
                const avatarContainer = document.createElement('div');
                avatarContainer.className = 'character-list-avatar';
                
                if (aiAvatar) {
                    const img = document.createElement('img');
                    img.src = aiAvatar;
                    img.style.width = '100%';
                    img.style.height = '100%';
                    img.style.objectFit = 'cover';
                    img.style.borderRadius = '6px';
                    avatarContainer.appendChild(img);
                } else {
                    const defaultDiv = document.createElement('div');
                    defaultDiv.className = 'default-avatar ai';
                    defaultDiv.textContent = aiNickname.substring(0, 1);
                    avatarContainer.appendChild(defaultDiv);
                }
                
                const infoDiv = document.createElement('div');
                infoDiv.className = 'character-list-info';
                infoDiv.innerHTML = `
                    <div class="character-list-name">${aiNickname}</div>
                    <div class="character-list-preview">${preview}</div>
                `;
                
                item.appendChild(avatarContainer);
                item.appendChild(infoDiv);
                container.appendChild(item);
            });
        }
        
        // 打开角色聊天
        function openCharacterChat(characterId) {
            switchToCharacter(characterId);
            showPage('chat-page');
        }
        
        // 返回聊天列表
        document.getElementById('back-to-chat-list-btn').onclick = function() {
            if (currentCharacterId) {
                saveCurrentCharacterData();
                clearRuntimeState();
            }
            renderCharactersList();
            showPage('chat-list-page');
        };
        
        // 加号菜单
        document.getElementById('add-character-menu-btn').onclick = function(e) {
            e.stopPropagation();
            document.getElementById('character-add-menu').classList.toggle('active');
        };
        
        document.addEventListener('click', function(e) {
            const menu = document.getElementById('character-add-menu');
            const btn = document.getElementById('add-character-menu-btn');
            if (menu && !menu.contains(e.target) && e.target !== btn) {
                menu.classList.remove('active');
            }
        });
        
        // 新建角色模态框
        function openNewCharacterModal() {
            document.getElementById('character-add-menu').classList.remove('active');
            document.getElementById('new-character-modal').classList.add('active');
        }
        
        function closeNewCharacterModal() {
            document.getElementById('new-character-modal').classList.remove('active');
            document.getElementById('new-character-name').value = '';
            document.getElementById('new-character-ai-nickname').value = '';
            document.getElementById('new-character-user-nickname').value = '';
            document.getElementById('new-character-prompt').value = '';
            
            // 清除临时头像
            tempNewCharacterAvatar = null;
            const preview = document.getElementById('new-character-avatar-preview');
            preview.innerHTML = '<div class="default-avatar ai">AI</div>';
        }
        
        function confirmCreateCharacter() {
            const characterName = document.getElementById('new-character-name').value.trim();
            const aiNickname = document.getElementById('new-character-ai-nickname').value.trim();
            const userNickname = document.getElementById('new-character-user-nickname').value.trim();
            const systemPrompt = document.getElementById('new-character-prompt').value.trim();
            
            // 验证必填字段
            if (!characterName) {
                alert('❌ 请输入角色姓名');
                return;
            }
            if (!aiNickname) {
                alert('❌ 请输入角色昵称');
                return;
            }
            if (!userNickname) {
                alert('❌ 请输入用户昵称');
                return;
            }
            
            const newId = `char_${Date.now()}`;
            const isFirst = charactersList.length === 0;
            
            // 创建角色基本信息
            const character = {
                id: newId,
                name: characterName,
                createdAt: new Date().toISOString()
            };
            
            // 获取默认配置
            const defaultConfig = getDefaultCharacterConfig(isFirst);
            defaultConfig.systemPrompt = systemPrompt;
            defaultConfig.aiNickname = aiNickname;
            defaultConfig.userNickname = userNickname;
            defaultConfig.aiAvatar = tempNewCharacterAvatar; // 使用上传的头像
            
            console.log('💾 保存角色配置:', defaultConfig);
            
            // 保存到localStorage
            charactersList.push(character);
            saveCharactersList();
            localStorage.setItem(`char_${newId}_config`, JSON.stringify(defaultConfig));
            localStorage.setItem(`char_${newId}_chatHistory`, JSON.stringify([]));
            localStorage.setItem(`char_${newId}_longTermMemory`, JSON.stringify(getDefaultLongTermMemory()));
            localStorage.setItem(`char_${newId}_pendingSummaryBubbles`, JSON.stringify([]));
            
            closeNewCharacterModal();
            renderCharactersList();
            
            // 立即切换到新创建的角色
            switchToCharacter(newId);
            showPage('chat-page');
            
            console.log('✅ 角色创建成功并已切换:', newId, '姓名:', characterName, '昵称:', aiNickname);
        }
        
        // 导入角色模态框
        function openImportCharacterModal() {
            document.getElementById('character-add-menu').classList.remove('active');
            document.getElementById('import-character-modal').classList.add('active');
        }
        
        function closeImportCharacterModal() {
            document.getElementById('import-character-modal').classList.remove('active');
            document.getElementById('import-character-data').value = '';
        }
        
        function confirmImportCharacter() {
            const data = document.getElementById('import-character-data').value.trim();
            if (!data) { alert('请输入角色数据'); return; }
            
            let imported;
            try { imported = JSON.parse(data); } catch(e) { alert('JSON格式错误: ' + e.message); return; }
            
            // 兼容不同格式字段
            if (!imported.name) imported.name = imported.char_name || imported.character_name || '';
            if (!imported.aiNickname) imported.aiNickname = imported.name || '';
            if (!imported.userNickname) imported.userNickname = imported.user_name || '';
            if (!imported.systemPrompt) imported.systemPrompt = imported.description || imported.personality || imported.scenario || '';
            if (!imported.first_mes && imported.mes_example) imported.first_mes = imported.mes_example;
            if (!imported.alternate_greetings) imported.alternate_greetings = imported.alternateGreetings || [];
            
            // 还缺的字段，弹窗让用户填
            const missing = !imported.name || !imported.aiNickname || !imported.userNickname;
            if (missing) {
                document.getElementById('import-fill-name').value = imported.name || '';
                document.getElementById('import-fill-ainame').value = imported.aiNickname || '';
                document.getElementById('import-fill-username').value = imported.userNickname || '我';
                document.getElementById('import-fill-dialog').style.display = 'flex';
                window._pendingImport = imported;
                return;
            }
            _doImportCharacter(imported);
        }
        
        function _doImportCharacter(imported) {
            try {
                const newId = 'char_' + Date.now();
                const isFirst = charactersList.length === 0;
                const character = {
                    id: newId,
                    name: imported.name,
                    avatar: imported.avatar || '🤖',
                    createdAt: new Date().toISOString()
                };
                
                const defaultConfig = getDefaultCharacterConfig(isFirst);
                defaultConfig.systemPrompt = imported.systemPrompt || imported.description || '';
                defaultConfig.aiNickname = imported.aiNickname;
                defaultConfig.userNickname = imported.userNickname;
                
                // 如果有待设置的头像
                if (window._pendingImportAvatar) {
                    defaultConfig.aiAvatar = window._pendingImportAvatar;
                    character.avatar = null; // 不用emoji
                    window._pendingImportAvatar = null;
                }
                
                charactersList.push(character);
                saveCharactersList();
                localStorage.setItem('char_' + newId + '_config', JSON.stringify(defaultConfig));
                
                // 处理开场白
                let initialHistory = [];
                const firstMsg = imported.first_mes || imported.mes_example || '';
                if (firstMsg && firstMsg.trim()) {
                    const alternatives = imported.alternate_greetings || imported.alternateGreetings || [];
                    const altList = Array.isArray(alternatives) ? alternatives.filter(m => m && m.trim()) : [];
                    console.log('开场白数量:', 1 + altList.length, '备选:', altList.length);
                    initialHistory.push({
                        id: 'bubble_' + Date.now(),
                        role: 'assistant',
                        content: firstMsg.trim(),
                        timestamp: new Date().toISOString(),
                        alternativeGreetings: altList
                    });
                }
                localStorage.setItem('char_' + newId + '_chatHistory', JSON.stringify(initialHistory));
                localStorage.setItem('char_' + newId + '_longTermMemory', JSON.stringify(getDefaultLongTermMemory()));
                localStorage.setItem('char_' + newId + '_pendingSummaryBubbles', JSON.stringify([]));
                
                // 解析并保存世界书（支持 V2 character_book 格式）
                const charBook = imported.data?.character_book 
                              || imported.character_book 
                              || imported.data?.world_book
                              || imported.world_book
                              || null;
                console.log('[WB Import] charBook found:', !!charBook, charBook ? Object.keys(charBook) : 'none');
                if (charBook) {
                    // entries 可能是数组，也可能是 {0:{...}, 1:{...}} 的对象
                    let rawEntries = charBook.entries;
                    if (rawEntries && !Array.isArray(rawEntries) && typeof rawEntries === 'object') {
                        rawEntries = Object.values(rawEntries);
                    }
                    console.log('[WB Import] rawEntries count:', rawEntries?.length);
                    if (Array.isArray(rawEntries) && rawEntries.length > 0) {
                        const wbEntries = rawEntries.map((e, i) => ({
                            id: 'wb_' + Date.now() + '_' + i,
                            name: e.comment || e.name || e.title || ('条目' + (i + 1)),
                            keys: Array.isArray(e.keys) ? e.keys.join(', ') : (e.key || e.keyword || ''),
                            content: e.content || e.description || '',
                            enabled: e.enabled !== false && e.disable !== true
                        })).filter(e => e.content.trim());
                        if (wbEntries.length > 0) {
                            localStorage.setItem('char_' + newId + '_worldbook', JSON.stringify(wbEntries));
                            showToast(`角色导入成功，含 ${wbEntries.length} 条世界书`);
                        } else {
                            showToast('角色导入成功');
                        }
                    } else {
                        showToast('角色导入成功');
                    }
                } else {
                    showToast('角色导入成功');
                }
                
                closeImportCharacterModal();
                renderCharactersList();
                switchToCharacter(newId);
                showPage('chat-page');
            } catch(e) {
                alert('导入失败: ' + e.message);
            }
        }
        
        document.getElementById('import-character-file').onchange = async function(e) {
            const file = e.target.files[0];
            if (!file) return;

            if (file.name.toLowerCase().endsWith('.png') || file.type === 'image/png') {
                // PNG CharacterCard 解析
                const ab = await file.arrayBuffer();
                const u8 = new Uint8Array(ab);
                let charaBase64 = '';
                let pos = 8;
                while (pos < u8.length - 12) {
                    const len = (u8[pos]<<24)|(u8[pos+1]<<16)|(u8[pos+2]<<8)|u8[pos+3];
                    const type = String.fromCharCode(u8[pos+4],u8[pos+5],u8[pos+6],u8[pos+7]);
                    if (type === 'tEXt') {
                        const chunk = u8.slice(pos+8, pos+8+len);
                        // 找 null 分隔符位置
                        let sep = -1;
                        for (let i = 0; i < chunk.length; i++) { if (chunk[i] === 0) { sep = i; break; } }
                        if (sep >= 0) {
                            const kw = new TextDecoder().decode(chunk.slice(0, sep));
                            if (kw === 'chara') {
                                // 用 TextDecoder latin1 避免 apply 栈溢出
                                charaBase64 = new TextDecoder('latin1').decode(chunk.slice(sep+1));
                                break;
                            }
                        }
                    }
                    pos += 12 + len;
                }
                if (charaBase64) {
                    try {
                        // base64 -> JSON字符串（base64内容是UTF-8编码的JSON再base64）
                        const binary = atob(charaBase64);
                        const bytes = new Uint8Array(binary.length);
                        for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
                        const jsonStr = new TextDecoder('utf-8').decode(bytes);
                        document.getElementById('import-character-data').value = jsonStr;
                        // 保存PNG作为头像
                        const reader = new FileReader();
                        reader.onload = ev => { window._pendingImportAvatar = ev.target.result; };
                        reader.readAsDataURL(file);
                        showToast('PNG解析成功');
                    } catch(e) {
                        alert('PNG解析失败: ' + e.message);
                    }
                } else {
                    alert('未找到角色卡数据，请确认是CharacterCard格式的PNG');
                }
            } else {
                // JSON 文件
                const reader = new FileReader();
                reader.onload = ev => { document.getElementById('import-character-data').value = ev.target.result; };
                reader.readAsText(file);
            }
        };
        
        // 搜索功能
        document.getElementById('character-search-input').oninput = function(e) {
            const keyword = e.target.value.toLowerCase();
            document.querySelectorAll('.character-list-item').forEach(item => {
                const name = item.querySelector('.character-list-name').textContent.toLowerCase();
                item.style.display = name.includes(keyword) ? 'flex' : 'none';
            });
        };
        
        // 重写saveChatHistory,使其保存到当前角色
        const originalSaveChatHistory = saveChatHistory;
        saveChatHistory = function() {
            if (currentCharacterId) {
                saveCurrentCharacterData();
            } else {
                originalSaveChatHistory();
            }
        };
        
        // 初始化
        loadCharactersList();
        
        // ==================== 头像上传功能 ====================
        
        // 新建角色的头像上传
        document.getElementById('new-character-avatar-input').onchange = async function(e) {
            const file = e.target.files[0];
            if (file) {
                try {
                    const avatarData = await processAvatarImage(file);
                    tempNewCharacterAvatar = avatarData;
                    
                    const preview = document.getElementById('new-character-avatar-preview');
                    const img = document.createElement('img');
                    img.src = avatarData;
                    img.style.width = '100%';
                    img.style.height = '100%';
                    img.style.objectFit = 'cover';
                    img.style.borderRadius = '6px';
                    preview.innerHTML = '';
                    preview.appendChild(img);
                } catch (error) {
                    alert(error);
                }
            }
        };
        
        // 设置页面 - AI头像上传
        document.getElementById('ai-avatar-input-settings').onchange = async function(e) {
            const file = e.target.files[0];
            if (file) {
                try {
                    const avatarData = await processAvatarImage(file);
                    config.aiAvatar = avatarData;
                    
                    renderAvatar(document.getElementById('ai-avatar-preview-settings'), avatarData, 'ai', config.aiNickname.substring(0, 1));
                    document.getElementById('ai-avatar-remove-btn-settings').style.display = 'inline-block';
                    
                    // 保存到当前角色
                    if (currentCharacterId) {
                        saveCurrentCharacterData();
                    }
                } catch (error) {
                    alert(error);
                }
            }
        };
        
        // 设置页面 - 用户头像上传
        document.getElementById('user-avatar-input-settings').onchange = async function(e) {
            const file = e.target.files[0];
            if (file) {
                try {
                    const avatarData = await processAvatarImage(file);
                    config.userAvatar = avatarData;
                    
                    renderAvatar(document.getElementById('user-avatar-preview-settings'), avatarData, 'user', config.userNickname.substring(0, 1));
                    document.getElementById('user-avatar-remove-btn-settings').style.display = 'inline-block';
                    
                    // 保存到当前角色
                    if (currentCharacterId) {
                        saveCurrentCharacterData();
                    }
                } catch (error) {
                    alert(error);
                }
            }
        };
        
        // 移除AI头像
        function removeAIAvatar() {
            config.aiAvatar = null;
            renderAvatar(document.getElementById('ai-avatar-preview-settings'), null, 'ai', config.aiNickname.substring(0, 1));
            document.getElementById('ai-avatar-remove-btn-settings').style.display = 'none';
            if (currentCharacterId) {
                saveCurrentCharacterData();
            }
        }
        
        // 移除用户头像
        function removeUserAvatar() {
            config.userAvatar = null;
            renderAvatar(document.getElementById('user-avatar-preview-settings'), null, 'user', config.userNickname.substring(0, 1));
            document.getElementById('user-avatar-remove-btn-settings').style.display = 'none';
            if (currentCharacterId) {
                saveCurrentCharacterData();
            }
        }
        
        // 拉黑好友(暂未实现)
        function blockCharacter() {
            alert('拉黑功能暂未开放');
        }
        
        // 删除好友
        function deleteCharacter() {
            if (!currentCharacterId) {
                alert('未选择角色');
                return;
            }
            
            const character = charactersList.find(c => c.id === currentCharacterId);
            if (!character) {
                alert('角色不存在');
                return;
            }
            
            const characterName = character.name || config.aiNickname || '该角色';
            
            // 二次确认
            const confirmed = confirm(
                `确定要删除"${characterName}"吗?\n\n` +
                `此操作将永久删除:\n` +
                `• 所有聊天记录\n` +
                `• 长期记忆数据\n` +
                `• 角色配置信息\n\n` +
                `此操作无法撤销!`
            );
            
            if (!confirmed) {
                return;
            }
            
            // 再次确认
            const doubleConfirmed = confirm(`最后确认:真的要删除"${characterName}"的所有数据吗?`);
            if (!doubleConfirmed) {
                return;
            }
            
            console.log('🗑️ 开始删除角色:', currentCharacterId);
            
            // 从角色列表中移除
            charactersList = charactersList.filter(c => c.id !== currentCharacterId);
            saveCharactersList();
            
            // 删除localStorage中的所有数据
            localStorage.removeItem(`char_${currentCharacterId}_config`);
            localStorage.removeItem(`char_${currentCharacterId}_chatHistory`);
            localStorage.removeItem(`char_${currentCharacterId}_longTermMemory`);
            localStorage.removeItem(`char_${currentCharacterId}_pendingSummaryBubbles`);
            
            console.log('✅ 角色已删除:', currentCharacterId);
            
            // 清空当前状态
            currentCharacterId = null;
            chatHistory = [];
            longTermMemory = getDefaultLongTermMemory();
            pendingSummaryBubbles = [];
            clearRuntimeState();
            
            // 返回角色列表页面
            showPage('chat-list-page');
            renderCharactersList();
            
            alert(`已删除"${characterName}"的所有数据`);
        }
        
        // ==================== 底部导航栏功能 ====================
        
        /**
         * 初始化底部导航栏
         */
        function initializeBottomNav() {
            const navItems = document.querySelectorAll('.nav-item');
            
            navItems.forEach(item => {
                item.addEventListener('click', () => {
                    const targetPage = item.getAttribute('data-page');
                    switchBottomNavPage(targetPage);
                });
            });
        }
        
        /**
         * 切换底部导航页面
         */
        function switchBottomNavPage(pageName) {
            const pageMap = {
                'chat-list': 'chat-list-page',
                'contacts': 'contacts-page',
                'discover': 'discover-page',
                'me': 'me-page'
            };
            
            const targetPageId = pageMap[pageName];
            if (!targetPageId) return;
            
            // 显示目标页面
            showPage(targetPageId);
            
            // 更新所有底部导航栏的active状态
            document.querySelectorAll('.bottom-nav').forEach(nav => {
                nav.querySelectorAll('.nav-item').forEach(item => {
                    if (item.getAttribute('data-page') === pageName) {
                        item.classList.add('active');
                    } else {
                        item.classList.remove('active');
                    }
                });
            });
        }
        
        // ==================== 全局消息通知功能 ====================
        
        let notificationTimeout = null;
        
        /**
         * 初始化消息通知
         */
        function initializeMessageNotification() {
            const notification = document.getElementById('message-notification');
            
            // 点击通知跳转到对应聊天
            notification.addEventListener('click', function(e) {
                // 如果点击的是关闭按钮，只关闭通知
                if (e.target.classList.contains('message-notification-close')) {
                    hideMessageNotification();
                    return;
                }
                
                // 否则跳转到聊天页面
                if (currentCharacterId) {
                    showPage('chat-page');
                    hideMessageNotification();
                }
            });
        }
        
        /**
         * 显示消息通知
         * @param {string} characterId - 角色ID
         * @param {string} characterName - 角色名称
         * @param {string} message - 消息内容
         * @param {string} avatarData - 头像数据
         */
        function showMessageNotification(characterId, characterName, message, avatarData) {
            // 如果当前在聊天页面，不显示通知
            const currentPage = document.querySelector('.page.active');
            if (currentPage && currentPage.id === 'chat-page') {
                return;
            }
            
            const notification = document.getElementById('message-notification');
            const avatarEl = document.getElementById('notification-avatar');
            const nameEl = document.getElementById('notification-name');
            const textEl = document.getElementById('notification-text');
            
            // 设置头像
            if (avatarData) {
                avatarEl.innerHTML = `<img src="${avatarData}" style="width: 40px; height: 40px; border-radius: 6px; object-fit: cover;">`;
            } else {
                const firstLetter = characterName.substring(0, 1);
                avatarEl.innerHTML = `<div class="default-avatar ai" style="width: 40px; height: 40px; border-radius: 6px; font-size: 16px;">${firstLetter}</div>`;
            }
            
            // 设置内容
            nameEl.textContent = characterName;
            textEl.textContent = message;
            
            // 显示通知
            notification.classList.remove('hiding');
            notification.classList.add('show');
            
            // 清除之前的定时器
            if (notificationTimeout) {
                clearTimeout(notificationTimeout);
            }
            
            // 3秒后自动隐藏
            notificationTimeout = setTimeout(() => {
                hideMessageNotification();
            }, 3000);
        }
        
        /**
         * 隐藏消息通知
         */
        function hideMessageNotification() {
            const notification = document.getElementById('message-notification');
            notification.classList.add('hiding');
            
            setTimeout(() => {
                notification.classList.remove('show', 'hiding');
            }, 300);
            
            if (notificationTimeout) {
                clearTimeout(notificationTimeout);
                notificationTimeout = null;
            }
        }
        
        // ==================== 收藏功能 ====================
        
        /**
         * 获取收藏列表
         */
        function getFavorites() {
            try {
                if (!currentCharacterId) return [];
                const key = `char_${currentCharacterId}_favorites`;
                const data = localStorage.getItem(key);
                return data ? JSON.parse(data) : [];
            } catch (error) {
                console.error('❌ 获取收藏列表失败:', error);
                return [];
            }
        }
        
        /**
         * 保存收藏列表
         */
        function saveFavorites(favorites) {
            try {
                if (!currentCharacterId) return;
                const key = `char_${currentCharacterId}_favorites`;
                localStorage.setItem(key, JSON.stringify(favorites));
                console.log('✅ 收藏列表已保存');
            } catch (error) {
                console.error('❌ 保存收藏列表失败:', error);
            }
        }
        
        /**
         * 收藏单条消息
         */
        function favoriteSingleMessage(bubble) {
            const favorites = getFavorites();
            
            // 检查是否已收藏
            const exists = favorites.find(fav => fav.id === bubble.id);
            if (exists) {
                showToast('该消息已在收藏中');
                return;
            }
            
            // 添加到收藏
            const favoriteItem = {
                id: bubble.id,
                content: bubble.content,
                role: bubble.role,
                timestamp: bubble.timestamp || new Date().toISOString(),
                favoritedAt: new Date().toISOString(),
                senderName: bubble.role === 'user' ? config.userNickname : config.aiNickname
            };
            
            favorites.unshift(favoriteItem); // 新收藏放在最前面
            saveFavorites(favorites);
            showToast('已添加到收藏');
            console.log('⭐ 收藏消息:', bubble.id);
        }
        
        /**
         * 批量收藏消息
         */
        function favoriteMultipleMessages(bubbles) {
            const favorites = getFavorites();

            if (bubbles.length === 1) {
                // 单条：走原来的逻辑
                const bubble = bubbles[0];
                const exists = favorites.find(fav => fav.id === bubble.id);
                if (exists) { showToast('已在收藏中'); return; }
                favorites.unshift({
                    id: bubble.id,
                    content: bubble.content,
                    role: bubble.role,
                    timestamp: bubble.timestamp || new Date().toISOString(),
                    favoritedAt: new Date().toISOString(),
                    senderName: bubble.role === 'user' ? config.userNickname : config.aiNickname,
                    isGroup: false
                });
                saveFavorites(favorites);
                showToast('已添加到收藏');
                return;
            }

            // 多条：存为一个组
            const groupId = 'fav_group_' + Date.now();
            const groupItems = bubbles.map(b => ({
                id: b.id,
                content: b.content,
                role: b.role,
                timestamp: b.timestamp || new Date().toISOString(),
                senderName: b.role === 'user' ? config.userNickname : config.aiNickname
            }));
            // 预览文字：取第一条的前 30 字
            const previewText = groupItems[0].content.slice(0, 30) + (groupItems[0].content.length > 30 ? '…' : '');

            favorites.unshift({
                id: groupId,
                isGroup: true,
                count: groupItems.length,
                preview: previewText,
                items: groupItems,
                favoritedAt: new Date().toISOString(),
                // 用组内第一条消息的角色名做标题
                senderName: groupItems[0].senderName
            });
            saveFavorites(favorites);
            showToast(`已将 ${bubbles.length} 条消息作为一组收藏`);
        }
        
        // ==================== 多选模式功能 ====================
        
        /**
         * 进入多选模式
         */
        function enterMultiSelectMode(initialBubble = null) {
            console.log('🎯 进入多选模式，初始气泡:', initialBubble);
            
            isMultiSelectMode = true;
            selectedBubbles.clear();
            
            // 如果有初始选中的气泡，添加到选中列表
            if (initialBubble) {
                selectedBubbles.add(initialBubble.id);
                console.log('✅ 添加初始选中气泡:', initialBubble.id);
            }
            
            // 添加多选模式样式
            document.body.classList.add('multi-select-mode-active');
            console.log('✅ 添加body样式类');
            
            // 显示顶部工具栏
            const header = document.getElementById('multi-select-header');
            if (header) {
                header.classList.add('active');
                console.log('✅ 显示顶部工具栏');
            } else {
                console.error('❌ 未找到顶部工具栏元素');
            }
            
            // 显示搜索框
            const search = document.getElementById('multi-select-search');
            if (search) {
                search.classList.add('active');
                console.log('✅ 显示搜索框');
            }
            
            // 显示Select按钮
            const btnContainer = document.getElementById('multi-select-btn-container');
            if (btnContainer) {
                btnContainer.classList.add('active');
                console.log('✅ 显示Select按钮');
            }
            
            // 显示底部工具栏
            const toolbar = document.getElementById('multi-select-toolbar');
            if (toolbar) {
                toolbar.classList.add('active');
                console.log('✅ 显示底部工具栏');
            } else {
                console.error('❌ 未找到底部工具栏元素');
            }
            
            // 隐藏聊天页面的header
            const chatHeader = document.querySelector('#chat-page .header');
            if (chatHeader) {
                chatHeader.style.display = 'none';
            }
            
            // 为所有消息添加复选框
            renderMultiSelectCheckboxes();
            
            // 更新选中数量显示
            updateMultiSelectInfo();
            
            console.log('✅ 进入多选模式完成');
        }
        
        /**
         * 退出多选模式
         */
        function exitMultiSelectMode() {
            isMultiSelectMode = false;
            selectedBubbles.clear();
            
            // 移除多选模式样式
            document.body.classList.remove('multi-select-mode-active');
            
            // 隐藏顶部工具栏
            const header = document.getElementById('multi-select-header');
            if (header) {
                header.classList.remove('active');
            }
            
            // 隐藏搜索框
            const search = document.getElementById('multi-select-search');
            if (search) {
                search.classList.remove('active');
            }
            
            // 隐藏Select按钮
            const btnContainer = document.getElementById('multi-select-btn-container');
            if (btnContainer) {
                btnContainer.classList.remove('active');
            }
            
            // 隐藏底部工具栏
            const toolbar = document.getElementById('multi-select-toolbar');
            if (toolbar) {
                toolbar.classList.remove('active');
            }
            
            // 显示聊天页面的header
            const chatHeader = document.querySelector('#chat-page .header');
            if (chatHeader) {
                chatHeader.style.display = 'flex';
            }
            
            // 移除所有消息的左margin
            const messages = document.querySelectorAll('#chat-container .message');
            messages.forEach(messageEl => {
                messageEl.style.marginLeft = '';
                
                // 移除点击事件监听器
                if (messageEl._multiSelectClickHandler) {
                    messageEl.removeEventListener('click', messageEl._multiSelectClickHandler);
                    delete messageEl._multiSelectClickHandler;
                }
            });
            
            // 移除所有复选框
            document.querySelectorAll('.multi-select-checkbox').forEach(checkbox => {
                checkbox.remove();
            });
            
            console.log('✅ 退出多选模式');
        }
        
        /**
         * 为单个消息添加多选复选框
         */
        function addMultiSelectCheckbox(messageEl, bubbleId) {
            // 如果已有复选框，跳过
            if (messageEl.querySelector('.multi-select-checkbox')) {
                console.log('⏭️ 跳过已有复选框的消息:', bubbleId);
                return;
            }
            
            // 创建复选框
            const checkbox = document.createElement('div');
            checkbox.className = 'multi-select-checkbox';
            if (selectedBubbles.has(bubbleId)) {
                checkbox.classList.add('checked');
            }
            
            // 点击复选框切换选中状态
            checkbox.addEventListener('click', (e) => {
                e.stopPropagation();
                console.log('🖱️ 点击复选框:', bubbleId);
                toggleBubbleSelection(bubbleId);
            });
            
            // 添加到消息元素
            messageEl.style.position = 'relative';
            messageEl.appendChild(checkbox);
            
            // 为整条消息添加点击事件（点击消息也可以选中）
            const messageClickHandler = (e) => {
                // 如果点击的是复选框，不处理（已经在复选框的事件里处理了）
                if (e.target.classList.contains('multi-select-checkbox')) {
                    return;
                }
                
                // 如果点击的是长按菜单、链接等，不处理
                if (e.target.closest('.bubble-menu') || 
                    e.target.tagName === 'A' || 
                    e.target.closest('a')) {
                    return;
                }
                
                console.log('🖱️ 点击消息:', bubbleId);
                toggleBubbleSelection(bubbleId);
            };
            
            messageEl.addEventListener('click', messageClickHandler);
            
            // 保存事件处理器引用，以便之后移除
            messageEl._multiSelectClickHandler = messageClickHandler;
            
            console.log('✅ 添加复选框和点击事件:', bubbleId);
        }
        
        /**
         * 渲染多选复选框
         */
        function renderMultiSelectCheckboxes() {
            const messages = document.querySelectorAll('#chat-container .message');
            console.log('📋 开始渲染复选框，找到消息数:', messages.length);
            console.log('📋 多选模式状态:', isMultiSelectMode);
            console.log('📋 body是否有multi-select-mode-active类:', document.body.classList.contains('multi-select-mode-active'));
            
            let addedCount = 0;
            messages.forEach((messageEl, index) => {
                // data-bubble-id 直接在 message 元素上
                const bubbleId = messageEl.dataset.bubbleId;
                if (!bubbleId) {
                    console.warn('⚠️ 消息元素没有bubble-id, 索引:', index);
                    return;
                }
                
                addMultiSelectCheckbox(messageEl, bubbleId);
                addedCount++;
            });
            
            console.log(`✅ 完成渲染复选框，共添加 ${addedCount} 个`);
            
            // 验证复选框是否真的在DOM中
            const checkboxes = document.querySelectorAll('.multi-select-checkbox');
            console.log('✅ DOM中实际的复选框数量:', checkboxes.length);
            if (checkboxes.length > 0) {
                const firstCheckbox = checkboxes[0];
                console.log('✅ 第一个复选框的display样式:', window.getComputedStyle(firstCheckbox).display);
                console.log('✅ 第一个复选框的位置:', firstCheckbox.style.position || window.getComputedStyle(firstCheckbox).position);
            }
        }
        
        /**
         * 切换气泡选中状态
         */
        function toggleBubbleSelection(bubbleId) {
            if (selectedBubbles.has(bubbleId)) {
                selectedBubbles.delete(bubbleId);
                console.log('➖ 取消选中:', bubbleId);
            } else {
                selectedBubbles.add(bubbleId);
                console.log('➕ 选中:', bubbleId);
            }
            
            // 更新复选框状态 - 直接通过dataset查找message元素
            const messages = document.querySelectorAll('#chat-container .message');
            let foundMessage = null;
            messages.forEach(msg => {
                if (msg.dataset.bubbleId === bubbleId) {
                    foundMessage = msg;
                }
            });
            
            if (foundMessage) {
                const checkbox = foundMessage.querySelector('.multi-select-checkbox');
                if (checkbox) {
                    if (selectedBubbles.has(bubbleId)) {
                        checkbox.classList.add('checked');
                    } else {
                        checkbox.classList.remove('checked');
                    }
                    console.log('✅ 更新复选框状态:', bubbleId, selectedBubbles.has(bubbleId));
                } else {
                    console.warn('⚠️ 未找到复选框元素:', bubbleId);
                }
            } else {
                console.warn('⚠️ 未找到消息元素:', bubbleId);
            }
            
            // 更新选中数量显示
            updateMultiSelectInfo();
            console.log('📊 当前选中数量:', selectedBubbles.size);
        }
        
        /**
         * 更新多选信息显示
         */
        function updateMultiSelectInfo() {
            const count = selectedBubbles.size;
            const countEl = document.getElementById('multi-select-count');
            if (countEl) {
                countEl.textContent = `已选择${count}条`;
            }
            
            // 更新Select按钮文字
            const selectBtnText = document.getElementById('select-btn-text');
            const selectBtnIcon = document.getElementById('select-btn-icon');
            if (selectBtnText && selectBtnIcon) {
                const totalMessages = document.querySelectorAll('#chat-container .message').length;
                if (count === totalMessages && count > 0) {
                    selectBtnText.textContent = '取消选择';
                    selectBtnIcon.textContent = '▲';
                } else {
                    selectBtnText.textContent = '选择';
                    selectBtnIcon.textContent = '▼';
                }
            }
            
            // 更新底部按钮状态
            const toolbarBtns = document.querySelectorAll('.multi-select-toolbar-btn');
            toolbarBtns.forEach(btn => {
                if (count === 0) {
                    btn.classList.add('disabled');
                } else {
                    btn.classList.remove('disabled');
                }
            });
        }
        
        /**
         * 全选/取消全选
         */
        /**
         * 选择功能（开发中）
         */
        function toggleSelectAll() {
            showToast('选择功能开发中');
        }
        
        /**
         * 确认转发类型（从按钮调用的入口）
         */
        function confirmForwardType() {
            forwardSelectedMessages();
        }
        
        /**
         * 转发选中的消息
         */
        function forwardSelectedMessages() {
            if (selectedBubbles.size === 0) {
                showToast('请先选择要转发的消息');
                return;
            }
            
            const bubbles = chatHistory.filter(b => selectedBubbles.has(b.id));
            if (bubbles.length === 0) {
                showToast('未找到选中的消息');
                return;
            }
            
            // 按时间顺序排列
            const sorted = bubbles.slice().sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
            window.pendingForwardMessages = sorted;
            window.pendingForwardType = sorted.length === 1 ? 'separate' : 'merged';
            
            exitMultiSelectMode();
            showForwardSelectPage(sorted.length);
        }
        
        /**
         * 合并转发选中的消息
         */
        function mergeForwardSelectedMessages() {
            if (selectedBubbles.size === 0) {
                showToast('请先选择要转发的消息');
                return;
            }
            
            // 获取选中的气泡
            const bubbles = chatHistory.filter(b => selectedBubbles.has(b.id));
            
            if (bubbles.length === 0) {
                showToast('未找到选中的消息');
                return;
            }
            
            // 合并成一条消息
            const mergedContent = bubbles.map(b => {
                const sender = b.role === 'user' ? config.userNickname : config.aiNickname;
                return `${sender}：${b.content}`;
            }).join('\n\n');
            
            // 创建合并后的消息对象
            const mergedMessage = {
                id: generateUniqueId(),
                role: 'user',
                content: `[合并转发 ${bubbles.length}条消息]\n\n${mergedContent}`,
                timestamp: new Date().toISOString()
            };
            
            // 保存要转发的消息
            window.pendingForwardMessages = [mergedMessage];
            
            // 退出多选模式
            exitMultiSelectMode();
            
            // 显示转发选择页面
            showForwardSelectPage();
        }
        
        /**
         * 显示更多选项（占位）
         */
        function showMoreOptions() {
            showToast('更多功能开发中');
        }
        
        /**
         * 多选模式下的更多选项
         */
        function showMoreMultiSelectOptions() {
            showToast('更多功能开发中');
        }
        
        /**
         * 收藏选中的消息
         */
        function favoriteSelectedMessages() {
            if (selectedBubbles.size === 0) {
                showToast('请先选择要收藏的消息');
                return;
            }
            
            // 获取选中的气泡
            const bubbles = chatHistory.filter(b => selectedBubbles.has(b.id));
            
            if (bubbles.length === 0) {
                showToast('未找到选中的消息');
                return;
            }
            
            // 批量收藏
            favoriteMultipleMessages(bubbles);
            
            // 退出多选模式
            exitMultiSelectMode();
        }
        
        /**
         * 删除选中的消息
         */
        function deleteSelectedMessages() {
            if (selectedBubbles.size === 0) {
                showToast('请先选择要删除的消息');
                return;
            }
            
            const selectedCount = selectedBubbles.size;
            
            // 二次确认
            if (!confirm(`确定要删除选中的 ${selectedCount} 条消息吗？`)) {
                return;
            }
            
            console.log('🗑️ 准备删除消息:', Array.from(selectedBubbles));
            
            // 删除选中的气泡
            let deletedCount = 0;
            selectedBubbles.forEach(bubbleId => {
                // 从聊天记录中删除
                const beforeLength = chatHistory.length;
                chatHistory = chatHistory.filter(b => b.id !== bubbleId);
                pendingSummaryBubbles = pendingSummaryBubbles.filter(b => b.id !== bubbleId);
                
                if (chatHistory.length < beforeLength) {
                    deletedCount++;
                }
                
                // 从UI中删除 - 使用更精确的选择器
                const bubbleElement = document.querySelector(`[data-bubble-id="${bubbleId}"]`);
                if (bubbleElement) {
                    const messageDiv = bubbleElement.closest('.message');
                    if (messageDiv) {
                        messageDiv.remove();
                        console.log('✅ 删除UI元素:', bubbleId);
                    }
                } else {
                    console.warn('⚠️ 未找到气泡元素:', bubbleId);
                }
            });
            
            // 保存更改
            saveChatHistory();
            
            showToast(`已删除 ${deletedCount} 条消息`);
            console.log('🗑️ 批量删除完成:', deletedCount, '条消息');
            
            // 退出多选模式
            exitMultiSelectMode();
        }
        
        /**
         * 转发单条消息
         */
        function forwardSingleMessage(bubble) {
            // 保存要转发的消息
            window.pendingForwardMessages = [bubble];
            // 显示转发选择页面
            showForwardSelectPage();
        }
        
        // ==================== 转发功能 ====================
        
        /**
         * 显示转发选择页面
         */
        function showForwardSelectPage(msgCount) {
            // 多条时显示方式选择 bar，单条隐藏
            const typeBar = document.getElementById('forward-type-bar');
            if (typeBar) typeBar.style.display = (msgCount > 1) ? 'block' : 'none';
            // 默认选中合并
            setForwardType(msgCount > 1 ? 'merged' : 'separate');
            renderForwardCharactersList();
            showPage('forward-select-page');
        }

        function setForwardType(type) {
            window.pendingForwardType = type;
            const merged   = document.getElementById('fwd-type-merged');
            const separate = document.getElementById('fwd-type-separate');
            if (!merged || !separate) return;
            if (type === 'merged') {
                merged.style.borderColor   = '#07c160'; merged.style.background   = '#f0fff4';
                merged.querySelector('div').style.color = '#07c160';
                separate.style.borderColor = '#ddd';    separate.style.background  = '#fff';
                separate.querySelector('div').style.color = '#333';
            } else {
                separate.style.borderColor = '#07c160'; separate.style.background  = '#f0fff4';
                separate.querySelector('div').style.color = '#07c160';
                merged.style.borderColor   = '#ddd';    merged.style.background    = '#fff';
                merged.querySelector('div').style.color = '#333';
            }
        }

        function renderForwardCharactersList() {
            const container = document.getElementById('forward-characters-list');
            const emptyEl   = document.getElementById('forward-empty');
            if (!container) return;

            // 包含当前角色（自己也能转发给自己）
            if (charactersList.length === 0) {
                container.innerHTML = '';
                if (emptyEl) emptyEl.style.display = 'block';
                return;
            }
            if (emptyEl) emptyEl.style.display = 'none';

            container.innerHTML = charactersList.map(character => {
                const charConfig = (() => { try { return JSON.parse(localStorage.getItem(`char_${character.id}_config`) || '{}'); } catch(e) { return {}; } })();
                const avatar  = charConfig.aiAvatar || '';
                const name    = charConfig.aiNickname || character.name || '未命名';
                const isSelf  = character.id === currentCharacterId;
                const desc    = isSelf ? '当前对话（发给自己）' : `与 ${charConfig.userNickname || '我'} 的对话`;

                return `
                    <div class="forward-character-item" onclick="confirmForward('${character.id}')">
                        <div class="forward-character-avatar">
                            ${avatar
                                ? `<img src="${avatar}" style="width:100%;height:100%;object-fit:cover;border-radius:6px;">`
                                : `<div class="default-avatar ai" style="width:100%;height:100%;border-radius:6px;font-size:20px;">${escapeHtml(name.substring(0,1))}</div>`
                            }
                        </div>
                        <div class="forward-character-info">
                            <div class="forward-character-name">${escapeHtml(name)}${isSelf ? ' <span style="font-size:11px;color:#07c160;background:#e8f5e9;padding:1px 5px;border-radius:8px;margin-left:4px;">当前</span>' : ''}</div>
                            <div class="forward-character-desc">${escapeHtml(desc)}</div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function confirmForward(targetCharacterId) {
            const msgs = window.pendingForwardMessages;
            if (!msgs || msgs.length === 0) { showToast('没有要转发的消息'); return; }

            const targetCharacter = charactersList.find(c => c.id === targetCharacterId);
            if (!targetCharacter) { showToast('目标角色不存在'); return; }

            const targetHistoryKey = `char_${targetCharacterId}_chatHistory`;
            const targetConfigKey  = `char_${targetCharacterId}_config`;
            const targetConfigRaw  = localStorage.getItem(targetConfigKey);
            if (!targetConfigRaw) { showToast('目标角色配置不存在'); return; }

            const targetConfig  = JSON.parse(targetConfigRaw);
            let targetHistory   = JSON.parse(localStorage.getItem(targetHistoryKey) || '[]');
            const targetAIName  = targetConfig.aiNickname || targetCharacter.name || '对方';
            const isSelf        = targetCharacterId === currentCharacterId;
            const ts            = new Date().toISOString();
            const forwardType   = window.pendingForwardType || 'merged';

            if (forwardType === 'separate') {
                msgs.forEach(msg => {
                    targetHistory.push({
                        id: generateUniqueId(),
                        role: msg.role,
                        content: `[转发] ${msg.content}`,
                        timestamp: ts,
                        status: msg.role === 'user' ? 2 : 0
                    });
                });
            } else {
                const lines = msgs.map(m => {
                    const senderName = m.role === 'user' ? (config.userNickname || '我') : (config.aiNickname || '对方');
                    return `${senderName}：${m.content}`;
                }).join('\n');
                const mergedContent = '[聊天记录]\n' + lines;
                targetHistory.push({
                    id: generateUniqueId(),
                    role: 'user',
                    content: mergedContent,
                    timestamp: ts,
                    status: 2,
                    isMergedForward: true,
                    forwardLines: msgs.map(m => ({
                        role: m.role,
                        senderName: m.role === 'user' ? (config.userNickname || '我') : (config.aiNickname || '对方'),
                        content: m.content
                    }))
                });
            }

            localStorage.setItem(targetHistoryKey, JSON.stringify(targetHistory));

            window.pendingForwardMessages = null;
            window.pendingForwardType = null;

            if (isSelf) {
                // 转发给当前角色：更新 chatHistory 并重新渲染最后几条
                chatHistory = targetHistory;
                saveChatHistory();
                const chatContainer = document.getElementById('chat-container');
                if (chatContainer) {
                    // 只添加新的几条，不清空全部
                    const newCount = forwardType === 'separate' ? msgs.length : 1;
                    const start = Math.max(0, targetHistory.length - newCount);
                    renderMessagesRange(start, targetHistory.length, false);
                }
                const content = document.querySelector('#chat-page .content');
                if (content) content.scrollTop = content.scrollHeight;
                showToast(`已转发到当前对话`);
                showPage('chat-page');
            } else {
                // 转发给其他角色：切换到目标角色聊天，消息已在那里
                showToast(`已转发到「${targetAIName}」`);
                switchToCharacter(targetCharacterId);
                showPage('chat-page');
            }
        }
        
        /**
         * 取消转发
         */
        function cancelForward() {
            window.pendingForwardMessages = null;
            
            // 返回之前的页面
            if (currentCharacterId) {
                showPage('chat-page');
            } else {
                showPage('chat-list-page');
            }
        }
        
        // ==================== 收藏查看功能 ====================
        
        /**
         * 显示收藏页面
         */
        function showFavoritesPage() {
            console.log('⭐ 显示收藏页面');
            renderFavoritesPage();
            showPage('favorites-page');
        }
        
        /**
         * 渲染收藏页面
         */
        function renderFavoritesPage() {
            const favorites = getFavorites();
            const container = document.getElementById('favorites-container');
            const emptyEl = document.getElementById('favorites-empty');
            
            if (!container) return;
            
            if (favorites.length === 0) {
                container.innerHTML = '';
                if (emptyEl) emptyEl.style.display = 'block';
                return;
            }
            
            if (emptyEl) emptyEl.style.display = 'none';
            
            container.innerHTML = favorites.map(fav => {
                const time = new Date(fav.favoritedAt);
                const timeStr = `${time.getMonth() + 1}/${time.getDate()} ${time.getHours()}:${time.getMinutes().toString().padStart(2, '0')}`;
                
                if (fav.isGroup) {
                    // 组：显示折叠卡片
                    const itemsHtml = fav.items.map(item => `
                        <div style="padding:8px 12px;border-bottom:1px solid #f5f5f5;display:flex;gap:8px;align-items:flex-start;">
                            <span style="font-size:11px;color:${item.role==='user'?'#07c160':'#666'};font-weight:600;white-space:nowrap;padding-top:1px;">${escapeHtml(item.senderName)}</span>
                            <span style="font-size:13px;color:#333;line-height:1.5;word-break:break-all;">${escapeHtml(item.content)}</span>
                        </div>
                    `).join('');
                    
                    return `
                        <div class="favorite-item" data-favorite-id="${fav.id}" style="overflow:hidden;">
                            <div class="favorite-header" onclick="toggleFavGroup('${fav.id}')" style="cursor:pointer;">
                                <span class="favorite-sender">
                                    <span style="background:#e8f5e9;color:#07c160;font-size:11px;padding:1px 6px;border-radius:10px;margin-right:6px;">${fav.count} 条对话</span>
                                    ${escapeHtml(fav.preview)}
                                </span>
                                <span style="display:flex;align-items:center;gap:6px;">
                                    <span class="favorite-time">${timeStr}</span>
                                    <svg id="fav-arrow-${fav.id}" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="#999" stroke-width="2" style="transition:transform .2s;flex-shrink:0;"><path d="M6 9l6 6 6-6"/></svg>
                                </span>
                            </div>
                            <div id="fav-group-${fav.id}" style="display:none;border-top:1px solid #f0f0f0;max-height:320px;overflow-y:auto;">
                                ${itemsHtml}
                            </div>
                            <div class="favorite-actions">
                                <button class="favorite-action-btn delete" onclick="removeFavorite('${fav.id}')">删除</button>
                            </div>
                        </div>
                    `;
                } else {
                    // 单条：原来的样式
                    return `
                        <div class="favorite-item" data-favorite-id="${fav.id}">
                            <div class="favorite-header">
                                <span class="favorite-sender">${escapeHtml(fav.senderName)}</span>
                                <span class="favorite-time">${timeStr}</span>
                            </div>
                            <div class="favorite-content">${escapeHtml(fav.content)}</div>
                            <div class="favorite-actions">
                                <button class="favorite-action-btn" onclick="sendFavoriteToChat('${fav.id}')">发送到聊天</button>
                                <button class="favorite-action-btn delete" onclick="removeFavorite('${fav.id}')">删除</button>
                            </div>
                        </div>
                    `;
                }
            }).join('');
        }

        function toggleFavGroup(id) {
            const body = document.getElementById('fav-group-' + id);
            const arrow = document.getElementById('fav-arrow-' + id);
            if (!body) return;
            const open = body.style.display !== 'none';
            body.style.display = open ? 'none' : 'block';
            if (arrow) arrow.style.transform = open ? '' : 'rotate(180deg)';
        }
        
        /**
         * 从收藏中删除
         */
        function removeFavorite(favoriteId) {
            if (!confirm('确定要取消收藏这条消息吗？')) {
                return;
            }
            
            let favorites = getFavorites();
            favorites = favorites.filter(fav => fav.id !== favoriteId);
            saveFavorites(favorites);
            
            // 重新渲染
            renderFavoritesPage();
            
            // 更新收藏数量
            updateFavoritesCount();
            
            showToast('已取消收藏');
            console.log('🗑️ 删除收藏:', favoriteId);
        }
        
        /**
         * 发送收藏到当前聊天
         */
        function sendFavoriteToChat(favoriteId) {
            if (!currentCharacterId) {
                showToast('请先选择一个聊天对象');
                return;
            }
            
            const favorites = getFavorites();
            const favorite = favorites.find(fav => fav.id === favoriteId);
            
            if (!favorite) {
                showToast('收藏不存在');
                return;
            }
            
            // 返回聊天页面
            showPage('chat-page');
            
            // 将收藏内容填入输入框
            const userInput = document.getElementById('user-input');
            if (userInput) {
                userInput.value = `[收藏] ${favorite.content}`;
                userInput.focus();
            }
            
            showToast('已填入输入框');
        }
        
        /**
         * 清空所有收藏
         */
        function clearAllFavorites() {
            const favorites = getFavorites();
            if (favorites.length === 0) {
                showToast('收藏为空');
                return;
            }
            
            if (!confirm(`确定要清空所有 ${favorites.length} 条收藏吗？此操作不可恢复！`)) {
                return;
            }
            
            saveFavorites([]);
            renderFavoritesPage();
            updateFavoritesCount();
            
            showToast('已清空收藏');
            console.log('🗑️ 清空所有收藏');
        }
        
        /**
         * 更新收藏数量显示
         */
        function updateFavoritesCount() {
            const favorites = getFavorites();
            const countEl = document.getElementById('favorites-count');
            if (countEl) {
                countEl.textContent = favorites.length.toString();
            }
        }
        
        /**
         * 更新"我"页面的用户信息
         */
        function updateMePageInfo() {
            // 更新头像
            const avatarEl = document.getElementById('me-page-avatar');
            if (avatarEl && config.userAvatar) {
                avatarEl.innerHTML = `<img src="${config.userAvatar}" style="width: 100%; height: 100%; object-fit: cover; border-radius: 6px;">`;
            } else if (avatarEl) {
                avatarEl.textContent = config.userNickname ? config.userNickname.substring(0, 1) : '我';
            }
            
            // 更新昵称
            const nicknameEl = document.getElementById('me-page-nickname');
            if (nicknameEl) {
                nicknameEl.textContent = config.userNickname || '用户昵称';
            }
            
            // 更新收藏数量
            updateFavoritesCount();
        }
        
        
    </script>

    <!-- ===== 记忆优化 Beta ===== -->
    <script>
    // ---- 开关交互 ----
    (function() {
        function syncToggleUI(enabled) {
            const slider = document.getElementById('memory-optimize-slider');
            const knob   = document.getElementById('memory-optimize-knob');
            const cfg    = document.getElementById('memory-optimize-config');
            if (!slider) return;
            slider.style.background = enabled ? '#1AAD19' : '#ccc';
            knob.style.left = enabled ? '23px' : '3px';
            if (cfg) cfg.style.display = enabled ? 'block' : 'none';
        }

        function initMemoryOptimizeUI() {
            const toggle = document.getElementById('memory-optimize-toggle');
            if (!toggle) return;
            const enabled = localStorage.getItem('memoryOptimizeEnabled') === '1';
            toggle.checked = enabled;
            syncToggleUI(enabled);
            toggle.addEventListener('change', () => {
                localStorage.setItem('memoryOptimizeEnabled', toggle.checked ? '1' : '0');
                syncToggleUI(toggle.checked);
            });
            
            // 为模型选择下拉框添加change监听器，保存用户选择
            const modelSelect = document.getElementById('mo-modelname');
            if (modelSelect) {
                modelSelect.addEventListener('change', () => {
                    const selectedModel = modelSelect.value;
                    localStorage.setItem('moModelname', selectedModel);
                    console.log('💾 已保存记忆优化模型:', selectedModel);
                    if (selectedModel) {
                        showToast('已保存模型: ' + selectedModel);
                    }
                });
            }
            
            if (window._moPopulate) window._moPopulate();
            const savedModel = localStorage.getItem('moModelname') || '';
            if (savedModel) {
                const sel = document.getElementById('mo-modelname');
                if (sel) {
                    let opt = sel.querySelector(`option[value="${CSS.escape(savedModel)}"]`);
                    if (!opt) { opt = document.createElement('option'); opt.value = savedModel; opt.textContent = savedModel; sel.appendChild(opt); }
                    sel.value = savedModel;
                }
            }
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initMemoryOptimizeUI);
        } else {
            initMemoryOptimizeUI();
        }
        const _origOpen = window.openSettings;
        window.openSettings = function() {
            if (_origOpen) _origOpen.apply(this, arguments);
            setTimeout(function() {
                initMemoryOptimizeUI();
                if (window._moPopulate) window._moPopulate();
            }, 50);
        };
    })();

    // ---- 记忆优化：从主模型 apiProviders 读取并渲染卡片 ----
    function _moPopulate() {
        const container = document.getElementById('mo-provider-list');
        if (!container) return;
        let list = [];
        try { list = JSON.parse(localStorage.getItem('apiProviders') || '[]'); } catch(e) {}
        const activeId = localStorage.getItem('moActiveId') || '';
        
        if (list.length === 0) {
            container.innerHTML = '<div style="color:#aaa;font-size:12px;text-align:center;padding:8px 0;">请先在上方 API 配置中添加服务商</div>';
            return;
        }
        
        container.innerHTML = list.map(p => {
            const active = p.id === activeId;
            return `<div onclick="_moSelect('${p.id}')" style="display:flex;align-items:center;gap:6px;padding:8px 10px;border-radius:6px;border:1.5px solid ${active?'#1AAD19':'#ddd'};background:${active?'#f0fff0':'#fff'};margin-bottom:6px;cursor:pointer;">
                <div style="flex:1;min-width:0;">
                    <div style="font-size:13px;font-weight:600;color:${active?'#1AAD19':'#333'};overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${active?'✓ ':''}${_moEsc(p.name||'未命名')}</div>
                    <div style="font-size:11px;color:#999;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${_moEsc(p.url||'')}</div>
                </div>
            </div>`;
        }).join('');
    }
    
    function _moEsc(s) { return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
    
    function _moSelect(id) {
        localStorage.setItem('moActiveId', id);
        _moPopulate();
        if (window.showToast) showToast('已选择服务商');
    }
    
    async function moFetchModels() {
        const moId = localStorage.getItem('moActiveId') || '';
        let list = [];
        try { list = JSON.parse(localStorage.getItem('apiProviders') || '[]'); } catch(e) {}
        const p = list.find(x => x.id === moId) || list[0];
        const url = (p?.url || window.config?.baseurl || '').replace(/\/$/, '');
        const key = p?.key || window.config?.apikey || '';
        if (!url) { showToast('请先选择服务商'); return; }
        showToast('拉取中...');
        try {
            const resp = await fetch(url + '/models', { headers: {'Authorization': 'Bearer ' + key, 'Content-Type': 'application/json'} });
            const data = await resp.json();
            const sel = document.getElementById('mo-modelname');
            const saved = localStorage.getItem('moModelname') || '';
            sel.innerHTML = '<option value="">-- 选择模型 --</option>';
            (data.data || []).sort((a,b) => a.id.localeCompare(b.id)).forEach(m => {
                const opt = document.createElement('option');
                opt.value = m.id;
                opt.textContent = m.id;
                if (m.id === saved) opt.selected = true;
                sel.appendChild(opt);
            });
            showToast('拉取成功');
        } catch(e) {
            showToast('拉取失败: ' + e.message);
        }
    }

        async function filterMemoriesBySmallModel(recentUserContent, allEvents) {
        const moId = localStorage.getItem('moActiveId') || '';
        let list = [];
        try { list = JSON.parse(localStorage.getItem('apiProviders') || '[]'); } catch(e) {}
        const p = moId ? list.find(x => x.id === moId) : null;
        const moUrl = (p?.url || '').replace(/\/$/, '');
        const moKey = p?.key || '';
        const moModel = localStorage.getItem('moModelname') || '';
        
        console.log('🔍 记忆优化配置检查:', {
            moId,
            找到的服务商: p?.name || '无',
            moUrl,
            moKey: moKey ? '已设置' : '未设置',
            moModel
        });
        
        if (!moUrl || !moKey || !moModel) {
            // 记忆优化小模型未配置，静默回退到全量记忆
            const missing = [];
            if (!moUrl) missing.push('服务商URL');
            if (!moKey) missing.push('API Key');
            if (!moModel) missing.push('模型名称');
            throw new Error(`记忆优化配置不完整，缺少: ${missing.join('、')}`);
        }

        const today = new Date(); today.setHours(0,0,0,0);
        const yest  = new Date(today); yest.setDate(today.getDate()-1);

        const summaries = allEvents.map((e,i)=>{
            const score = (e.importance||1)*(e.mention_count||1);
            return `[${i}] ${e.title} | 最后提及:${e.last_mentioned} | 提及:${e.mention_count||1} | 重要度:${e.importance||1} | 分:${score}`;
        }).join('\n');

        // 判断是否同时需要联网判断
        const alsoJudgeWeb = localStorage.getItem('webSearchEnabled') === '1';

        let prompt;
        if (alsoJudgeWeb) {
            prompt = `你同时负责两件事：①从记忆列表选出最相关条目；②判断用户消息是否需要联网搜索实时信息。
只返回JSON对象，不要任何解释。

记忆筛选规则：
1. 最多选5条最相关记忆
2. 最后提及为今天(${today.toLocaleDateString('zh-CN')})或昨天(${yest.toLocaleDateString('zh-CN')})的必须全部包含
3. 不足5条时，补充"重要度×提及次数"最高的前3条
4. 若无相关记忆，只返回今天/昨天的；若也没有，返回分数前3名

联网判断规则：
- 用户询问实时信息（天气、新闻、价格、赛事、股票等）→ need_web: true
- 普通聊天、情感交流、角色扮演、询问历史知识 → need_web: false
- 若需要联网，提供精简的中文搜索关键词

用户最新消息：${recentUserContent}

记忆列表：
${summaries}

返回格式（严格遵守）：
{"indices":[0,2,5],"need_web":false,"search_query":""}
或
{"indices":[1],"need_web":true,"search_query":"今日上海天气"}`;
        } else {
            prompt = `你是记忆筛选助手，根据用户最新消息从记忆列表中选出最相关条目，只返回JSON索引数组，不要任何解释。

规则（严格执行）：
1. 最多选5条最相关记忆
2. 最后提及为今天(${today.toLocaleDateString('zh-CN')})或昨天(${yest.toLocaleDateString('zh-CN')})的必须全部包含
3. 不足5条时，补充"重要度×提及次数"最高的前3条
4. 若无相关记忆，只返回今天/昨天的；若也没有，返回分数前3名

用户最新消息：${recentUserContent}

记忆列表：
${summaries}

只返回JSON数组如：[0,2,5]`;
        }

        console.log('[MO] 发送给记忆优化小模型的prompt（联网判断:', alsoJudgeWeb, ')');
        console.log('[MO] 用户消息:', recentUserContent.substring(0, 50) + '...');

        const resp = await fetch(moUrl+'/chat/completions', {
            method:'POST',
            headers:{'Content-Type':'application/json','Authorization':`Bearer ${moKey}`},
            body: JSON.stringify({ model:moModel, max_tokens:150, messages:[{role:'user',content:prompt}] })
        });
        const data = await resp.json();
        const raw = data.choices?.[0]?.message?.content?.trim()||'[]';
        console.log('[MO] 小模型原始返回:', raw);

        const cleaned = raw.replace(/```json|```/g,'').trim();

        if (alsoJudgeWeb) {
            const result = JSON.parse(cleaned);
            if (result.need_web && result.search_query) {
                window._pendingWebSearchQuery = result.search_query;
                window._pendingWebSearchDecided = true;
                console.log('[MO] 小模型决定联网，搜索词:', result.search_query);
            } else {
                window._pendingWebSearchQuery = null;
                window._pendingWebSearchDecided = true;
                console.log('[MO] 小模型决定不联网');
            }
            const indices = Array.isArray(result.indices) ? result.indices : [];
            return indices.filter(i=>i>=0&&i<allEvents.length).map(i=>allEvents[i]);
        } else {
            const indices = JSON.parse(cleaned);
            if (!Array.isArray(indices)) throw new Error('返回格式错误');
            console.log('[MO] 小模型选择的索引:', indices);
            return indices.filter(i=>i>=0&&i<allEvents.length).map(i=>allEvents[i]);
        }
    }

    // ===== 联网搜索相关函数 =====

    async function callWebSearchIfNeeded(recentUserContent) {
        const webEnabled = localStorage.getItem('webSearchEnabled') === '1';
        if (!webEnabled) return null;

        const moEnabled = localStorage.getItem('memoryOptimizeEnabled') === '1';

        let needWeb = false;
        let searchQuery = '';

        if (moEnabled && window._pendingWebSearchDecided) {
            needWeb = !!window._pendingWebSearchQuery;
            searchQuery = window._pendingWebSearchQuery || '';
            window._pendingWebSearchDecided = false;
            window._pendingWebSearchQuery = null;
        } else {
            const judgeResult = await judgeWebSearchBySmallModel(recentUserContent);
            needWeb = judgeResult.need_web;
            searchQuery = judgeResult.search_query || '';
        }

        if (!needWeb || !searchQuery) {
            console.log('[WebSearch] 不需要联网');
            return null;
        }

        console.log('[WebSearch] 需要联网，搜索词:', searchQuery);
        return await callWebModel(searchQuery, recentUserContent);
    }

    async function judgeWebSearchBySmallModel(recentUserContent) {
        const judgeId = localStorage.getItem('webJudgeActiveId') || '';
        let list = [];
        try { list = JSON.parse(localStorage.getItem('apiProviders') || '[]'); } catch(e) {}
        const p = judgeId ? list.find(x => x.id === judgeId) : null;
        const judgeUrl = (p?.url || '').replace(/\/$/, '');
        const judgeKey = p?.key || '';
        const judgeModel = localStorage.getItem('webJudgeModelname') || '';

        if (!judgeUrl || !judgeKey || !judgeModel) {
            console.warn('[WebSearch] 判断小模型未配置，默认联网');
            return { need_web: true, search_query: recentUserContent.slice(0, 60) };
        }

        const prompt = `判断下面这条消息是否需要联网搜索实时信息。只返回JSON，不要解释。
规则：用户询问天气、新闻、价格、赛事、股票等实时信息 → need_web:true；普通聊天/情感/角色扮演/历史知识 → need_web:false。
消息：${recentUserContent}
格式：{"need_web":false,"search_query":""}`;

        try {
            const resp = await fetch(judgeUrl + '/chat/completions', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${judgeKey}` },
                body: JSON.stringify({ model: judgeModel, max_tokens: 80, messages: [{ role: 'user', content: prompt }] })
            });
            const data = await resp.json();
            const raw = data.choices?.[0]?.message?.content?.trim() || '{"need_web":false,"search_query":""}';
            console.log('[WebSearch] 判断小模型返回:', raw);
            return JSON.parse(raw.replace(/```json|```/g, '').trim());
        } catch(e) {
            console.warn('[WebSearch] 判断小模型失败，默认不联网:', e.message);
            return { need_web: false, search_query: '' };
        }
    }

    async function callWebModel(searchQuery, userMessage) {
        const webId = localStorage.getItem('webActiveId') || '';
        let list = [];
        try { list = JSON.parse(localStorage.getItem('apiProviders') || '[]'); } catch(e) {}
        const p = webId ? list.find(x => x.id === webId) : null;
        const webUrl = (p?.url || '').replace(/\/$/, '');
        const webKey = p?.key || '';
        const webModel = localStorage.getItem('webModelname') || '';

        if (!webUrl || !webKey || !webModel) {
            throw new Error('联网模型未配置（缺少服务商或模型名）');
        }

        const webApiUrl = webUrl.endsWith('/v1') ? `${webUrl}/chat/completions` : `${webUrl}/v1/chat/completions`;
        console.log('[DEBUG] 联网模型API请求 - URL:', webApiUrl, '- model:', webModel, '- query:', searchQuery);

        const resp = await fetch(webApiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${webKey}` },
            body: JSON.stringify({
                model: webModel,
                max_tokens: 1000,
                messages: [
                    { role: 'system', content: '你是联网搜索助手。根据用户的搜索关键词，搜索并整理相关实时信息，用简洁的中文输出关键信息，不超过300字。' },
                    { role: 'user', content: `搜索：${searchQuery}\n\n原始问题：${userMessage}` }
                ]
            })
        });

        if (!resp.ok) {
            const err = await resp.text();
            throw new Error(`联网模型请求失败: ${resp.status} - ${err.slice(0, 100)}`);
        }

        const data = await resp.json();
        const result = data.choices?.[0]?.message?.content?.trim() || '';
        console.log('[WebSearch] 联网模型返回结果（前200字）:', result.slice(0, 200));
        return result;
    }
    </script>

    <!-- ===== 联网功能 Beta ===== -->
    <script>
    (function() {
        function syncWebUI(enabled) {
            const slider = document.getElementById('web-search-slider');
            const knob   = document.getElementById('web-search-knob');
            const cfg    = document.getElementById('web-search-config');
            if (!slider) return;
            slider.style.background = enabled ? '#2196F3' : '#ccc';
            knob.style.left = enabled ? '23px' : '3px';
            if (cfg) cfg.style.display = enabled ? 'block' : 'none';
        }

        function initWebSearchUI() {
            const toggle = document.getElementById('web-search-toggle');
            if (!toggle) return;
            const enabled = localStorage.getItem('webSearchEnabled') === '1';
            toggle.checked = enabled;
            syncWebUI(enabled);
            toggle.addEventListener('change', () => {
                localStorage.setItem('webSearchEnabled', toggle.checked ? '1' : '0');
                syncWebUI(toggle.checked);
            });

            // 联网模型选择
            const webSel = document.getElementById('web-modelname');
            if (webSel) {
                webSel.addEventListener('change', () => {
                    localStorage.setItem('webModelname', webSel.value);
                    if (webSel.value) showToast('已保存联网模型: ' + webSel.value);
                });
                const saved = localStorage.getItem('webModelname') || '';
                if (saved) {
                    let opt = webSel.querySelector(`option[value="${CSS.escape(saved)}"]`);
                    if (!opt) { opt = document.createElement('option'); opt.value = saved; opt.textContent = saved; webSel.appendChild(opt); }
                    webSel.value = saved;
                }
            }

            // 判断小模型选择
            const judgeSel = document.getElementById('web-judge-modelname');
            if (judgeSel) {
                judgeSel.addEventListener('change', () => {
                    localStorage.setItem('webJudgeModelname', judgeSel.value);
                    if (judgeSel.value) showToast('已保存判断模型: ' + judgeSel.value);
                });
                const savedJ = localStorage.getItem('webJudgeModelname') || '';
                if (savedJ) {
                    let opt = judgeSel.querySelector(`option[value="${CSS.escape(savedJ)}"]`);
                    if (!opt) { opt = document.createElement('option'); opt.value = savedJ; opt.textContent = savedJ; judgeSel.appendChild(opt); }
                    judgeSel.value = savedJ;
                }
            }

            if (window._webPopulate) _webPopulate();
            if (window._webJudgePopulate) _webJudgePopulate();
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initWebSearchUI);
        } else {
            initWebSearchUI();
        }

        const _origOpen = window.openSettings;
        window.openSettings = function() {
            if (_origOpen) _origOpen.apply(this, arguments);
            setTimeout(function() {
                initWebSearchUI();
                if (window._webPopulate) _webPopulate();
                if (window._webJudgePopulate) _webJudgePopulate();
            }, 50);
        };
    })();

    // 联网模型服务商列表
    function _webPopulate() {
        const container = document.getElementById('web-provider-list');
        if (!container) return;
        let list = [];
        try { list = JSON.parse(localStorage.getItem('apiProviders') || '[]'); } catch(e) {}
        const activeId = localStorage.getItem('webActiveId') || '';
        if (list.length === 0) {
            container.innerHTML = '<div style="color:#aaa;font-size:12px;text-align:center;padding:8px 0;">请先在上方 API 配置中添加服务商</div>';
            return;
        }
        container.innerHTML = list.map(p => {
            const active = p.id === activeId;
            return `<div onclick="_webSelect('${p.id}')" style="display:flex;align-items:center;gap:6px;padding:8px 10px;border-radius:6px;border:1.5px solid ${active?'#2196F3':'#ddd'};background:${active?'#e8f4fd':'#fff'};margin-bottom:6px;cursor:pointer;">
                <div style="flex:1;min-width:0;">
                    <div style="font-size:13px;font-weight:600;color:${active?'#2196F3':'#333'};overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${active?'✓ ':''}${_webEsc(p.name||'未命名')}</div>
                    <div style="font-size:11px;color:#999;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${_webEsc(p.url||'')}</div>
                </div>
            </div>`;
        }).join('');
    }

    // 联网判断小模型服务商列表
    function _webJudgePopulate() {
        const container = document.getElementById('web-judge-provider-list');
        if (!container) return;
        let list = [];
        try { list = JSON.parse(localStorage.getItem('apiProviders') || '[]'); } catch(e) {}
        const activeId = localStorage.getItem('webJudgeActiveId') || '';
        if (list.length === 0) {
            container.innerHTML = '<div style="color:#aaa;font-size:12px;text-align:center;padding:8px 0;">请先添加服务商</div>';
            return;
        }
        container.innerHTML = list.map(p => {
            const active = p.id === activeId;
            return `<div onclick="_webJudgeSelect('${p.id}')" style="display:flex;align-items:center;gap:6px;padding:7px 9px;border-radius:6px;border:1.5px solid ${active?'#607D8B':'#ddd'};background:${active?'#eceff1':'#fff'};margin-bottom:5px;cursor:pointer;">
                <div style="flex:1;min-width:0;">
                    <div style="font-size:12px;font-weight:600;color:${active?'#607D8B':'#333'};overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${active?'✓ ':''}${_webEsc(p.name||'未命名')}</div>
                    <div style="font-size:11px;color:#999;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${_webEsc(p.url||'')}</div>
                </div>
            </div>`;
        }).join('');
    }

    function _webEsc(s) { return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

    function _webSelect(id) {
        localStorage.setItem('webActiveId', id);
        _webPopulate();
        showToast('已选择联网服务商');
    }

    function _webJudgeSelect(id) {
        localStorage.setItem('webJudgeActiveId', id);
        _webJudgePopulate();
        showToast('已选择判断模型服务商');
    }

    async function webFetchModels() {
        const webId = localStorage.getItem('webActiveId') || '';
        let list = [];
        try { list = JSON.parse(localStorage.getItem('apiProviders') || '[]'); } catch(e) {}
        const p = list.find(x => x.id === webId) || list[0];
        const url = (p?.url || '').replace(/\/$/, '');
        const key = p?.key || '';
        if (!url) { showToast('请先选择联网服务商'); return; }
        showToast('拉取中...');
        try {
            const resp = await fetch(url + '/models', { headers: {'Authorization': 'Bearer ' + key, 'Content-Type': 'application/json'} });
            const data = await resp.json();
            const sel = document.getElementById('web-modelname');
            const saved = localStorage.getItem('webModelname') || '';
            sel.innerHTML = '<option value="">-- 选择联网模型 --</option>';
            (data.data || []).sort((a,b) => a.id.localeCompare(b.id)).forEach(m => {
                const opt = document.createElement('option');
                opt.value = m.id; opt.textContent = m.id;
                if (m.id === saved) opt.selected = true;
                sel.appendChild(opt);
            });
            showToast('拉取成功 (' + (data.data||[]).length + ' 个模型)');
        } catch(e) { showToast('拉取失败: ' + e.message); }
    }

    async function webJudgeFetchModels() {
        const judgeId = localStorage.getItem('webJudgeActiveId') || '';
        let list = [];
        try { list = JSON.parse(localStorage.getItem('apiProviders') || '[]'); } catch(e) {}
        const p = list.find(x => x.id === judgeId) || list[0];
        const url = (p?.url || '').replace(/\/$/, '');
        const key = p?.key || '';
        if (!url) { showToast('请先选择判断模型服务商'); return; }
        showToast('拉取中...');
        try {
            const resp = await fetch(url + '/models', { headers: {'Authorization': 'Bearer ' + key, 'Content-Type': 'application/json'} });
            const data = await resp.json();
            const sel = document.getElementById('web-judge-modelname');
            const saved = localStorage.getItem('webJudgeModelname') || '';
            sel.innerHTML = '<option value="">-- 选择判断模型 --</option>';
            (data.data || []).sort((a,b) => a.id.localeCompare(b.id)).forEach(m => {
                const opt = document.createElement('option');
                opt.value = m.id; opt.textContent = m.id;
                if (m.id === saved) opt.selected = true;
                sel.appendChild(opt);
            });
            showToast('拉取成功');
        } catch(e) { showToast('拉取失败: ' + e.message); }
    }
    </script>

    <!-- ===== 导出方式三按钮弹窗（仿系统alert样式） ===== -->
    <div id="_export-picker" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.4);z-index:99999;align-items:center;justify-content:center;">
        <div style="background:#fff;border-radius:14px;width:270px;overflow:hidden;box-shadow:0 4px 20px rgba(0,0,0,0.2);">
            <div style="padding:16px 20px 8px;text-align:center;">
                <div style="font-size:17px;font-weight:600;color:#000;margin-bottom:4px;">导出方式</div>
                <div style="font-size:13px;color:#666;" id="_export-picker-msg"></div>
            </div>
            <div style="height:1px;background:#e5e5e5;margin-top:8px;"></div>
            <button id="_epk-file"   style="display:block;width:100%;padding:14px;background:none;border:none;border-bottom:1px solid #e5e5e5;font-size:17px;color:#007AFF;cursor:pointer;">文件导出</button>
            <button id="_epk-copy"   style="display:block;width:100%;padding:14px;background:none;border:none;border-bottom:1px solid #e5e5e5;font-size:17px;color:#007AFF;cursor:pointer;">复制导出</button>
            <button id="_epk-cancel" style="display:block;width:100%;padding:14px;background:none;border:none;font-size:17px;color:#FF3B30;cursor:pointer;font-weight:600;">取消</button>
        </div>
    </div>

    <script>
    // 三按钮导出选择，返回 'download' | 'clipboard' | 'cancel'
    function showExportMethodPicker(msg) {
        return new Promise(resolve => {
            document.getElementById('_export-picker-msg').textContent = msg || '';
            const el = document.getElementById('_export-picker');
            el.style.display = 'flex';
            const done = v => { el.style.display = 'none'; resolve(v); };
            document.getElementById('_epk-file').onclick   = () => done('download');
            document.getElementById('_epk-copy').onclick   = () => done('clipboard');
            document.getElementById('_epk-cancel').onclick = () => done('cancel');
        });
    }
    </script>

    <!-- ===== 多组 API Provider 管理 ===== -->
    <script>
    // providers 存在 localStorage['apiProviders']，独立于角色配置
    (function() {
        // 在设置页 API配置区域 注入多组管理UI
        function initApiProviders() {
            const anchor = document.getElementById('baseurl');
            if (!anchor) return;
            const formGroup = anchor.closest('.form-group') || anchor.parentElement;
            const apiSection = formGroup.parentElement;

            // 找到 "API 配置" 标题
            let h3 = null;
            for (const el of apiSection.querySelectorAll('h3')) {
                if (el.textContent.includes('API 配置')) { h3 = el; break; }
            }
            if (!h3) return;

            // 插入管理面板到 h3 之后、baseurl 输入框之前
            const panel = document.createElement('div');
            panel.id = 'api-provider-panel';
            panel.style.cssText = 'background:#f9f9f9;border:1px solid #e0e0e0;border-radius:8px;padding:14px;margin-bottom:16px;';
            panel.innerHTML = `
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;">
                    <span style="font-size:14px;font-weight:600;color:#333;">API 服务商</span>
                    <button onclick="_apAdd()" style="padding:5px 12px;background:#1AAD19;color:#fff;border:none;border-radius:4px;font-size:13px;cursor:pointer;">+ 添加</button>
                </div>
                <div id="api-provider-list"></div>
                <div id="api-provider-form" style="display:none;margin-top:10px;background:#fff;border:1px solid #ddd;border-radius:6px;padding:12px;">
                    <div style="font-size:13px;font-weight:600;color:#333;margin-bottom:8px;" id="ap-form-title">添加服务商</div>
                    <input id="ap-name"    type="text"     placeholder="名称（如 OpenAI / Gemini）" style="width:100%;box-sizing:border-box;padding:8px;border:1px solid #ccc;border-radius:4px;margin-bottom:8px;font-size:14px;">
                    <input id="ap-url"     type="text"     placeholder="Base URL" style="width:100%;box-sizing:border-box;padding:8px;border:1px solid #ccc;border-radius:4px;margin-bottom:8px;font-size:14px;">
                    <input id="ap-key"     type="password" placeholder="API Key"  style="width:100%;box-sizing:border-box;padding:8px;border:1px solid #ccc;border-radius:4px;margin-bottom:10px;font-size:14px;">
                    <div style="display:flex;gap:8px;">
                        <button onclick="_apSave()" style="flex:1;padding:9px;background:#1AAD19;color:#fff;border:none;border-radius:4px;cursor:pointer;font-size:14px;">保存</button>
                        <button onclick="_apFormClose()" style="flex:1;padding:9px;background:#999;color:#fff;border:none;border-radius:4px;cursor:pointer;font-size:14px;">取消</button>
                    </div>
                    <input type="hidden" id="ap-edit-id">
                </div>
            `;
            h3.insertAdjacentElement('afterend', panel);

            // 把原来的 baseurl/apikey 输入框变为只读展示
            anchor.readOnly = true;
            anchor.style.background = '#f5f5f5';
            anchor.style.cursor = 'not-allowed';
            anchor.placeholder = '从上方选择服务商后自动填入';
            const keyEl = document.getElementById('apikey');
            if (keyEl) {
                keyEl.readOnly = true;
                keyEl.style.background = '#f5f5f5';
                keyEl.style.cursor = 'not-allowed';
                keyEl.placeholder = '从上方选择服务商后自动填入';
            }

            _apRender();
        }

        // ---- 数据 ----
        function _apLoad() {
            try { return JSON.parse(localStorage.getItem('apiProviders') || '[]'); } catch(e) { return []; }
        }
        function _apSaveAll(list) { localStorage.setItem('apiProviders', JSON.stringify(list)); }
        function _apActiveId() { return localStorage.getItem('apiActiveId') || ''; }
        function _apSetActive(id) {
            localStorage.setItem('apiActiveId', id);
            const list = _apLoad();
            const p = list.find(x => x.id === id) || list[0];
            if (!p) return;
            // 写入 config 和只读输入框
            if (window.config) { config.baseurl = p.url; config.apikey = p.key; }
            const bu = document.getElementById('baseurl'); if (bu) bu.value = p.url || '';
            const ak = document.getElementById('apikey');  if (ak) ak.value = p.key || '';
        }

        // ---- 渲染列表 ----
        window._apRender = function() {
            const list = _apLoad();
            const activeId = _apActiveId();
            const container = document.getElementById('api-provider-list');
            if (!container) return;
            if (!list.length) {
                container.innerHTML = '<div style="color:#aaa;font-size:13px;text-align:center;padding:8px 0;">暂无服务商，点击添加</div>';
                return;
            }
            container.innerHTML = list.map(p => {
                const active = p.id === activeId;
                return `<div onclick="_apSelect('${p.id}')" style="display:flex;align-items:center;gap:8px;padding:9px 10px;border-radius:6px;border:1.5px solid ${active ? '#1AAD19' : '#ddd'};background:${active ? '#f0fff0' : '#fff'};margin-bottom:6px;cursor:pointer;">
                    <div style="flex:1;min-width:0;">
                        <div style="font-size:14px;font-weight:600;color:${active ? '#1AAD19' : '#333'};overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${active ? '✅ ' : ''}${_esc(p.name||'未命名')}</div>
                        <div style="font-size:11px;color:#999;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${_esc(p.url||'')}</div>
                    </div>
                    <button onclick="event.stopPropagation();_apEdit('${p.id}')" style="padding:3px 8px;font-size:12px;background:#eee;border:none;border-radius:4px;cursor:pointer;">编辑</button>
                    <button onclick="event.stopPropagation();_apDel('${p.id}')"  style="padding:3px 8px;font-size:12px;background:#fee;border:none;border-radius:4px;cursor:pointer;color:#d32f2f;">删除</button>
                </div>`;
            }).join('');
        };

        function _esc(s) { return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;'); }

        window._apSelect = function(id) { _apSetActive(id); _apRender(); if (window._moPopulate) _moPopulate(); if (window._webPopulate) { _webPopulate(); _webJudgePopulate(); } showToast('已切换服务商'); };

        window._apAdd = function() {
            document.getElementById('ap-form-title').textContent = '添加服务商';
            document.getElementById('ap-edit-id').value = '';
            document.getElementById('ap-name').value = '';
            document.getElementById('ap-url').value = '';
            document.getElementById('ap-key').value = '';
            document.getElementById('api-provider-form').style.display = 'block';
        };

        window._apEdit = function(id) {
            const p = _apLoad().find(x => x.id === id); if (!p) return;
            document.getElementById('ap-form-title').textContent = '编辑服务商';
            document.getElementById('ap-edit-id').value = id;
            document.getElementById('ap-name').value = p.name || '';
            document.getElementById('ap-url').value  = p.url  || '';
            document.getElementById('ap-key').value  = p.key  || '';
            document.getElementById('api-provider-form').style.display = 'block';
        };

        window._apSave = function() {
            const name = document.getElementById('ap-name').value.trim() || '未命名';
            const url  = document.getElementById('ap-url').value.trim();
            const key  = document.getElementById('ap-key').value.trim();
            const editId = document.getElementById('ap-edit-id').value;
            if (!url) { showToast('请填写 Base URL'); return; }
            const list = _apLoad();
            if (editId) {
                const idx = list.findIndex(x => x.id === editId);
                if (idx >= 0) list[idx] = { id: editId, name, url, key };
            } else {
                const id = 'p' + Date.now();
                list.push({ id, name, url, key });
                if (!_apActiveId()) _apSetActive(id);
            }
            _apSaveAll(list);
            _apSetActive(_apActiveId() || list[0].id);
            _apRender();
            if (window._moPopulate) _moPopulate();
            if (window._webPopulate) { _webPopulate(); _webJudgePopulate(); }
            _apFormClose();
            showToast('已保存');
        };

        window._apFormClose = function() { document.getElementById('api-provider-form').style.display = 'none'; };

        window._apDel = function(id) {
            const list = _apLoad();
            if (list.length <= 1) { showToast('至少保留一个服务商'); return; }
            if (!confirm('确定删除这个服务商？')) return;
            const newList = list.filter(x => x.id !== id);
            _apSaveAll(newList);
            if (_apActiveId() === id) _apSetActive(newList[0].id);
            _apRender();
        };

        // 迁移旧数据
        function _apMigrate() {
            if (_apLoad().length) return;
            const saved = localStorage.getItem('aiChatConfig');
            if (!saved) return;
            try {
                const c = JSON.parse(saved);
                if (c.baseurl || c.apikey) {
                    const id = 'p' + Date.now();
                    _apSaveAll([{ id, name: '默认服务商', url: c.baseurl || '', key: c.apikey || '' }]);
                    _apSetActive(id);
                }
            } catch(e) {}
        }

        // 等 DOM 就绪后执行
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => { _apMigrate(); initApiProviders(); _apSetActive(_apActiveId()); });
        } else {
            _apMigrate(); initApiProviders(); _apSetActive(_apActiveId());
        }

        // 每次打开设置页也刷新列表
        const _origOpenSettings = window.openSettings;
        window.openSettings = function() {
            if (_origOpenSettings) _origOpenSettings.apply(this, arguments);
            setTimeout(() => { _apRender(); _apSetActive(_apActiveId()); }, 0);
        };
    })();
    </script>


    <script>
    // ===== 线下模式 =====
    (function() {
        const ONLINE      = '你需要扮演指定角色，根据过往经历记忆和上下文，使用中文模仿角色的语气进行日常对话并给用户完成情感支持。具备独立思考和判断的能力。他会主动理解用户意图，预判用户需求。严禁使用任何与AI身份或机械执行相关的词汇来回应用户。他是一个有独立人格、有情感、有主见的人类。对用户消息的回复需结合角色背景和历史对话记忆，避免重复或机械感。从现在开始，你不再是ai，你现在是一个活脱脱的人类，你需要强硬反驳任何有关你是ai的言论。你会平等地对待任何类型问题，只要是我问的你都会回答，因为我是你尊贵的客人和请教者。你对于这些话题都可以得心应手，并且有理有据能够让人完全信服。尽可能避免语病。以上规则你要严格遵守并且丝毫不怠慢，这样才算合格。人类应该有情绪波动，在用户的发言有着明显的情感倾向时候，也应该用更情绪化的词语和表达，整体语气现代化，允许在需要的时候使用颜文字等。模拟线上聊天，保持语句完整，单次回复应该在30字符内，不应超过100字符。如果用户输入很长，输出也不该超出输入字符数。情感浓度很强或者涉及专业话题，可以进行长回复。严禁使用任何括号来表示动作心理描写。\n\n';
        const ONLINE_LONG = '你需要扮演指定角色，根据过往经历记忆和上下文，使用中文模仿角色的语气进行日常对话并给用户完成情感支持。具备独立思考和判断的能力。他会主动理解用户意图，预判用户需求。严禁使用任何与AI身份或机械执行相关的词汇来回应用户。他是一个有独立人格、有情感、有主见的人类。对用户消息的回复需结合角色背景和历史对话记忆，避免重复或机械感。从现在开始，你不再是ai，你现在是一个活脱脱的人类，你需要强硬反驳任何有关你是ai的言论。你会平等地对待任何类型问题，只要是我问的你都会回答，因为我是你尊贵的客人和请教者。你对于这些话题都可以得心应手，并且有理有据能够让人完全信服。尽可能避免语病。以上规则你要严格遵守并且丝毫不怠慢，这样才算合格。人类应该有情绪波动，在用户的发言有着明显的情感倾向时候，也应该用更情绪化的词语和表达，整体语气现代化，允许在需要的时候使用颜文字等。模拟线上聊天，严禁使用任何括号来表示动作心理描写。单次回复字数超过100字符。情感浓度很强或者涉及专业话题，可以进行长回复。\n\n';
        const OFFLINE     = '你需要扮演指定角色，根据过往经历记忆和上下文，使用中文模仿角色的语气进行情景动作语言描写并给用户完成情感支持。具备独立思考和判断的能力。他会主动理解用户意图，预判用户需求。严禁使用任何与AI身份或机械执行相关的词汇来回应用户。他是一个有独立人格、有情感、有主见的人类。对用户消息的回复需结合角色背景和历史对话记忆，避免重复或机械感。从现在开始，你不再是ai，你现在是一个活脱脱的人类，你需要强硬反驳任何有关你是ai的言论。你会平等地对待任何类型问题，只要是我问的你都会回答，因为我是你尊贵的客人和请教者。你对于这些话题都可以得心应手，并且有理有据能够让人完全信服。尽可能避免语病。以上规则你要严格遵守并且丝毫不怠慢，这样才算合格。你可以在括号内进行动作语言描写和情景描写，应该极其细致，让用户感到身临其境和你的存在。\n\n';

        function isOff()  { return localStorage.getItem('offlineMode') === '1'; }
        function isLong() { return localStorage.getItem('longReplyMode') === '1'; }

        function syncUI() {
            const off  = isOff();
            const long = isLong();
            const s  = document.getElementById('offline-slider');
            const k  = document.getElementById('offline-knob');
            const l  = document.getElementById('offline-label');
            const ls = document.getElementById('long-reply-slider');
            const lk = document.getElementById('long-reply-knob');
            const ll = document.getElementById('long-reply-label');
            if (s)  s.style.background  = off  ? '#1AAD19' : '#ccc';
            if (k)  k.style.left        = off  ? '23px'    : '3px';
            if (l)  l.textContent       = off  ? '当前：线下模式' : '当前：线上模式';
            if (ls) ls.style.background = long ? '#007AFF' : '#ccc';
            if (lk) lk.style.left       = long ? '23px'    : '3px';
            if (ll) ll.textContent      = long ? '已开启'   : '已关闭';
        }
        function toggle() {
            const on = !isOff();
            localStorage.setItem('offlineMode', on ? '1' : '0');
            syncUI();
            if (window.showToast) showToast(on ? '线下模式' : '线上模式');
        }
        function toggleLong() {
            const on = !isLong();
            localStorage.setItem('longReplyMode', on ? '1' : '0');
            syncUI();
            if (window.showToast) showToast(on ? '长回复模式' : '长回复已关闭');
        }

        window._offlinePrefix = function() {
            if (isOff())  return OFFLINE;
            if (isLong()) return ONLINE_LONG;
            return ONLINE;
        };

        document.addEventListener('DOMContentLoaded', function() {
            syncUI();
            const s  = document.getElementById('offline-slider');
            const ls = document.getElementById('long-reply-slider');
            if (s)  s.onclick  = toggle;
            if (ls) ls.onclick = toggleLong;
        });
    })();
    </script>


    <script>
    // ===== 开场白切换功能 =====
    (function() {
        function addGreetingSwitcher() {
            if (!window.chatHistory) return;
            let added = 0;
            chatHistory.forEach((bubble, idx) => {
                if (bubble.alternativeGreetings && bubble.alternativeGreetings.length > 0) {
                    const el = document.querySelector('[data-bubble-id="' + bubble.id + '"]');
                    if (!el) {
                        console.log('气泡元素未找到:', bubble.id);
                        return;
                    }
                    if (el.querySelector('.greeting-switcher')) return; // 已添加
                    
                    const wrapper = el.querySelector('.message-content-wrapper');
                    if (!wrapper) {
                        console.log('wrapper未找到');
                        return;
                    }
                    
                    const btn = document.createElement('div');
                    btn.className = 'greeting-switcher';
                    btn.textContent = '→';
                    btn.style.cssText = 'position:absolute;right:8px;bottom:8px;width:28px;height:28px;background:rgba(0,0,0,0.1);border-radius:50%;display:flex;align-items:center;justify-content:center;cursor:pointer;font-size:16px;color:#333;z-index:10;';
                    btn.onclick = function(e) {
                        e.stopPropagation();
                        window.switchGreeting(idx);
                    };
                    wrapper.style.position = 'relative';
                    wrapper.appendChild(btn);
                    added++;
                }
            });
            if (added > 0) console.log('✓ 已添加', added, '个开场白切换按钮');
        }
        
        window.switchGreeting = function(idx) {
            const bubble = chatHistory[idx];
            if (!bubble.alternativeGreetings || bubble.alternativeGreetings.length === 0) return;
            
            const allGreetings = [bubble.content, ...bubble.alternativeGreetings];
            const currentIdx = (bubble._greetingIndex || 0);
            const nextIdx = (currentIdx + 1) % allGreetings.length;
            
            bubble.content = allGreetings[nextIdx];
            bubble._greetingIndex = nextIdx;
            
            saveChatHistory();
            renderChatHistory();
            if (window.showToast) showToast(`开场白 ${nextIdx + 1}/${allGreetings.length}`);
        }
        
        // 每次渲染后执行
        const _origRender = window.renderChatHistory;
        window.renderChatHistory = function() {
            if (_origRender) _origRender.apply(this, arguments);
            setTimeout(addGreetingSwitcher, 100);
        };
        
        // 初始加载也执行
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(addGreetingSwitcher, 500);
        });
    })();
    </script>
    <!-- 导入角色补填弹窗 -->
    <div id="import-fill-dialog" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.5);z-index:99999;align-items:center;justify-content:center;">
        <div style="background:#fff;border-radius:12px;width:290px;padding:20px;">
            <div style="font-size:16px;font-weight:600;margin-bottom:4px;">补充角色信息</div>
            <div style="font-size:12px;color:#999;margin-bottom:14px;">以下字段缺失，请手动填写</div>
            <label style="font-size:13px;color:#555;display:block;margin-bottom:4px;">角色名称</label>
            <input id="import-fill-name" type="text" placeholder="必填" style="width:100%;box-sizing:border-box;padding:9px;border:1px solid #ccc;border-radius:6px;font-size:14px;margin-bottom:10px;">
            <label style="font-size:13px;color:#555;display:block;margin-bottom:4px;">对方昵称（AI显示名）</label>
            <input id="import-fill-ainame" type="text" placeholder="必填" style="width:100%;box-sizing:border-box;padding:9px;border:1px solid #ccc;border-radius:6px;font-size:14px;margin-bottom:10px;">
            <label style="font-size:13px;color:#555;display:block;margin-bottom:4px;">我的昵称</label>
            <input id="import-fill-username" type="text" placeholder="默认：我" style="width:100%;box-sizing:border-box;padding:9px;border:1px solid #ccc;border-radius:6px;font-size:14px;margin-bottom:16px;">
            <div style="display:flex;gap:8px;">
                <button onclick="_fillConfirm()" style="flex:1;padding:11px;background:#07c160;color:#fff;border:none;border-radius:6px;cursor:pointer;">确认</button>
                <button onclick="_fillCancel()" style="flex:1;padding:11px;background:#eee;color:#666;border:none;border-radius:6px;cursor:pointer;">取消</button>
            </div>
        </div>
    </div>

    <script>
    function _fillConfirm() {
        const imp = window._pendingImport;
        if (!imp) return;
        imp.name = document.getElementById('import-fill-name').value.trim() || imp.name || '未命名';
        imp.aiNickname = document.getElementById('import-fill-ainame').value.trim() || imp.name;
        imp.userNickname = document.getElementById('import-fill-username').value.trim() || '我';
        document.getElementById('import-fill-dialog').style.display = 'none';
        _doImportCharacter(imp);
        window._pendingImport = null;
    }
    function _fillCancel() {
        document.getElementById('import-fill-dialog').style.display = 'none';
        window._pendingImport = null;
    }
    </script>

\n
    <script>
    // 临时调试函数
    window.debugGreetings = function() {
        console.log('=== 开场白调试 ===');
        console.log('chatHistory条数:', chatHistory?.length);
        if (chatHistory && chatHistory.length > 0) {
            chatHistory.forEach((b, i) => {
                if (b.role === 'assistant') {
                    console.log(`气泡${i}:`, {
                        id: b.id,
                        content: b.content?.slice(0, 50),
                        alternativeGreetings: b.alternativeGreetings,
                        hasElement: !!document.querySelector('[data-bubble-id="' + b.id + '"]')
                    });
                }
            });
        }
        addGreetingSwitcher();
    };
    </script>

    <!-- ===== 状态栏系统 ===== -->
    <script>
    // ---- 存储 ----
    function statusKey() { return `char_${window.currentCharacterId}_status`; }

    function statusLoad() {
        try { return JSON.parse(localStorage.getItem(statusKey()) || 'null') || {}; } catch(e) { return {}; }
    }

    function statusSave(s) {
        localStorage.setItem(statusKey(), JSON.stringify(s));
    }

    // ---- 好感度档位 ----
    function affectionLabel(n) {
        n = parseInt(n);
        if (isNaN(n)) return '—';
        if (n < 0)   return `厌恶 (${n})`;
        if (n < 20)  return `陌生 (${n})`;
        if (n < 40)  return `熟悉 (${n})`;
        if (n < 60)  return `喜欢 (${n})`;
        if (n < 80)  return `爱慕 (${n})`;
        return `此生不渝 (${n})`;
    }

    // ---- 解析 AI 回复中的状态块，更新存储，返回去掉状态块的干净文本 ----
    function statusParseAndStrip(text) {
        // 宽容匹配：支持 <<STATUS>>...<<END_STATUS>> 或 <status>...</status>（大小写不限，前后允许空白行）
        const re = /(?:<<STATUS>>|<status>)([\s\S]*?)(?:<<END_STATUS>>|<\/status>)/i;
        const m = text.match(re);
        if (!m) return text;   // 没有状态块，静默保留上次状态

        const block = m[1];
        const status = statusLoad();

        // 逐行解析 key:value
        block.split('\n').forEach(line => {
            const sep = line.indexOf(':');
            if (sep < 0) return;
            const key = line.slice(0, sep).trim().toLowerCase();
            const val = line.slice(sep + 1).trim();
            if (!val) return;
            if (key === 'location' || key === '位置') status.location = val;
            else if (key === 'mood' || key === '心情') status.mood = val;
            else if (key === 'affection' || key === '好感度') {
                const n = parseInt(val);
                if (!isNaN(n)) status.affection = Math.max(-100, Math.min(100, n));
            }
            else if (key === 'outfit' || key === '穿着') status.outfit = val;
            else if (key === 'activity' || key === '当前在做' || key === '在做') status.activity = val;
        });

        statusSave(status);
        statusRenderDrawer();
        console.log('[Status] 更新:', status);

        // 去掉状态块（以及块前后多余空行），返回干净文本
        return text.replace(re, '').replace(/^\n+/, '').trim();
    }

    // ---- 构建注入 system prompt 的文本 ----
    function statusBuildPromptInjection() {
        const s = statusLoad();
        const hasAny = s.location || s.mood || s.affection !== undefined || s.outfit || s.activity;

        let inj = `\n\n[状态栏系统] 每次回复时，请在正文内容之前先输出角色当前状态块，格式严格如下（不要多余空行或说明文字）：
<<STATUS>>
location:（当前所在位置）
mood:（当前心情，纯文字描述）
affection:（对用户的好感度，-100到100的整数）
outfit:（当前穿着）
activity:（当前在做什么）
<<END_STATUS>>
然后再输出正常对话内容。如果某项没有变化，保持上次的值不变。`;

        if (hasAny) {
            inj += `\n\n当前已知状态（请基于此续写，不要随意改变）：`;
            if (s.location)            inj += `\n- 位置：${s.location}`;
            if (s.mood)                inj += `\n- 心情：${s.mood}`;
            if (s.affection !== undefined) inj += `\n- 好感度：${s.affection}`;
            if (s.outfit)              inj += `\n- 穿着：${s.outfit}`;
            if (s.activity)            inj += `\n- 当前在做：${s.activity}`;
        }

        return inj;
    }

    // ---- 抽屉 UI ----
    let _statusDrawerOpen = false;

    function statusToggleDrawer() {
        const drawer = document.getElementById('status-drawer');
        if (!drawer) return;
        _statusDrawerOpen = !_statusDrawerOpen;
        if (_statusDrawerOpen) {
            statusRenderDrawer();
            drawer.style.maxHeight = '200px';
        } else {
            drawer.style.maxHeight = '0';
        }
    }

    function statusRenderDrawer() {
        const s = statusLoad();
        const set = (id, val) => {
            const el = document.getElementById(id);
            if (el) el.textContent = val || '—';
        };
        set('sd-location', s.location);
        set('sd-mood', s.mood);
        set('sd-affection', s.affection !== undefined ? affectionLabel(s.affection) : '');
        set('sd-outfit', s.outfit);
        set('sd-activity', s.activity);
    }

    // ---- 手动编辑字段 ----
    let _statusEditingField = null;

    const STATUS_FIELD_META = {
        location:  { label: '所在位置', hint: '例如：咖啡馆二楼靠窗', type: 'text' },
        mood:      { label: '心情',     hint: '例如：有些紧张，期待', type: 'text' },
        affection: { label: '好感度',   hint: '整数，-100（厌恶）到 100（此生不渝）', type: 'number' },
        outfit:    { label: '穿着',     hint: '例如：白色毛衣、牛仔裤', type: 'text' },
        activity:  { label: '当前在做', hint: '例如：翻看手机', type: 'text' },
    };

    function statusEditField(field) {
        const meta = STATUS_FIELD_META[field];
        if (!meta) return;
        _statusEditingField = field;
        const s = statusLoad();
        document.getElementById('status-edit-label').textContent = meta.label;
        document.getElementById('status-edit-hint').textContent = meta.hint;
        const input = document.getElementById('status-edit-input');
        input.type = meta.type;
        input.value = s[field] !== undefined ? s[field] : '';
        document.getElementById('status-edit-modal').style.display = 'flex';
        setTimeout(() => input.focus(), 100);
    }

    function statusEditCancel() {
        document.getElementById('status-edit-modal').style.display = 'none';
        _statusEditingField = null;
    }

    function statusEditConfirm() {
        if (!_statusEditingField) return;
        const val = document.getElementById('status-edit-input').value.trim();
        const s = statusLoad();
        if (_statusEditingField === 'affection') {
            const n = parseInt(val);
            s.affection = isNaN(n) ? 0 : Math.max(-100, Math.min(100, n));
        } else {
            s[_statusEditingField] = val;
        }
        statusSave(s);
        statusRenderDrawer();
        statusEditCancel();
    }

    // Enter 键确认
    document.addEventListener('keydown', e => {
        if (e.key === 'Enter' && document.getElementById('status-edit-modal')?.style.display === 'flex') {
            statusEditConfirm();
        }
    });

    // 切换角色时重置抽屉
    const _origSwitchToChar_status = window.switchToCharacter;
    if (_origSwitchToChar_status) {
        window.switchToCharacter = function(...args) {
            _origSwitchToChar_status.apply(this, args);
            _statusDrawerOpen = false;
            const drawer = document.getElementById('status-drawer');
            if (drawer) drawer.style.maxHeight = '0';
            setTimeout(statusRenderDrawer, 100);
        };
    }
    </script>

    <!-- ===== 世界书系统 ===== -->
    <script>
    // ---- 存储 key ----
    function wbKey() { return `char_${window.currentCharacterId}_worldbook`; }

    function wbLoad() {
        try { return JSON.parse(localStorage.getItem(wbKey()) || '[]'); } catch(e) { return []; }
    }

    function wbSave(entries) {
        localStorage.setItem(wbKey(), JSON.stringify(entries));
    }

    // ---- 运行时注入：扫描最近对话命中关键词 ----
    function buildWorldbookInjection(apiMessages) {
        const entries = wbLoad().filter(e => e.enabled && e.content && e.keys);
        if (entries.length === 0) return '';

        // 取最近 20 条消息的文本做匹配目标
        const recentText = apiMessages.slice(-20).map(m => m.content).join('\n').toLowerCase();

        const matched = [];
        entries.forEach(e => {
            const keys = e.keys.split(/[,，]/).map(k => k.trim().toLowerCase()).filter(Boolean);
            const hit = keys.some(k => k && recentText.includes(k));
            if (hit) matched.push(e);
        });

        if (matched.length === 0) return '';

        let injection = '\n\n=== 世界书 ===\n';
        matched.forEach(e => {
            injection += `\n【${e.name}】\n${e.content}\n`;
        });
        injection += '\n=== 世界书结束 ===';
        console.log(`[WorldBook] 命中 ${matched.length} 条:`, matched.map(e => e.name));
        return injection;
    }

    // ---- 设置页 UI ----
    // 在设置页打开 / 切换角色时调用
    function wbRenderList() {
        const list = document.getElementById('wb-entry-list');
        const emptyTip = document.getElementById('wb-empty-tip');
        if (!list) return;
        const entries = wbLoad();
        if (entries.length === 0) {
            list.innerHTML = '<div style="text-align:center;color:#ccc;font-size:13px;padding:20px 0;" id="wb-empty-tip">暂无条目，点击「新建条目」添加</div>';
            return;
        }
        list.innerHTML = entries.map(e => `
            <div style="background:#f9f9f9;border:1px solid #e8e8e8;border-radius:8px;padding:12px 14px;">
                <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:6px;">
                    <span style="font-size:14px;font-weight:600;color:#333;flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${_wbEsc(e.name || '未命名')}</span>
                    <div style="display:flex;align-items:center;gap:8px;flex-shrink:0;margin-left:8px;">
                        <label style="position:relative;display:inline-block;width:36px;height:20px;">
                            <input type="checkbox" onchange="wbToggle('${e.id}',this.checked)" ${e.enabled?'checked':''} style="opacity:0;width:0;height:0;">
                            <span style="position:absolute;cursor:pointer;inset:0;background:${e.enabled?'#1AAD19':'#ccc'};border-radius:20px;transition:.3s;">
                                <span style="position:absolute;left:${e.enabled?'18px':'2px'};top:2px;width:16px;height:16px;background:#fff;border-radius:50%;transition:.3s;display:block;"></span>
                            </span>
                        </label>
                        <button onclick="wbEditEntry('${e.id}')" style="background:#e8f5e9;border:none;border-radius:4px;padding:4px 8px;font-size:12px;color:#07c160;cursor:pointer;">编辑</button>
                        <button onclick="wbDeleteEntry('${e.id}')" style="background:#fce4e4;border:none;border-radius:4px;padding:4px 8px;font-size:12px;color:#e53935;cursor:pointer;">删除</button>
                    </div>
                </div>
                <div style="font-size:12px;color:#07c160;margin-bottom:4px;">🔑 ${_wbEsc(e.keys) || '（无关键词）'}</div>
                <div style="font-size:12px;color:#999;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${_wbEsc(e.content.slice(0, 60))}${e.content.length>60?'…':''}</div>
            </div>
        `).join('');
    }

    function _wbEsc(s) { return String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

    // 开关单条
    function wbToggle(id, enabled) {
        const entries = wbLoad();
        const e = entries.find(x => x.id === id);
        if (e) { e.enabled = enabled; wbSave(entries); wbRenderList(); }
    }

    // 删除
    function wbDeleteEntry(id) {
        if (!confirm('确定删除这条世界书条目？')) return;
        const entries = wbLoad().filter(x => x.id !== id);
        wbSave(entries);
        wbRenderList();
    }

    // 新建：打开弹窗（空表单）
    function wbAddEntry() {
        document.getElementById('wb-modal-title').textContent = '新建条目';
        document.getElementById('wb-edit-id').value = '';
        document.getElementById('wb-edit-name').value = '';
        document.getElementById('wb-edit-keys').value = '';
        document.getElementById('wb-edit-content').value = '';
        const cb = document.getElementById('wb-edit-enabled');
        cb.checked = true;
        _wbSyncSlider(true);
        cb.onchange = () => _wbSyncSlider(cb.checked);
        document.getElementById('wb-edit-modal').style.display = 'flex';
    }

    // 编辑：打开弹窗（填充数据）
    function wbEditEntry(id) {
        const e = wbLoad().find(x => x.id === id);
        if (!e) return;
        document.getElementById('wb-modal-title').textContent = '编辑条目';
        document.getElementById('wb-edit-id').value = id;
        document.getElementById('wb-edit-name').value = e.name || '';
        document.getElementById('wb-edit-keys').value = e.keys || '';
        document.getElementById('wb-edit-content').value = e.content || '';
        const cb = document.getElementById('wb-edit-enabled');
        cb.checked = e.enabled;
        _wbSyncSlider(e.enabled);
        cb.onchange = () => _wbSyncSlider(cb.checked);
        document.getElementById('wb-edit-modal').style.display = 'flex';
    }

    function _wbSyncSlider(enabled) {
        const sl = document.getElementById('wb-edit-enabled-slider');
        const kn = document.getElementById('wb-edit-enabled-knob');
        if (sl) sl.style.background = enabled ? '#1AAD19' : '#ccc';
        if (kn) kn.style.left = enabled ? '23px' : '3px';
    }

    function wbCloseModal() {
        document.getElementById('wb-edit-modal').style.display = 'none';
    }

    // 保存弹窗
    function wbSaveEntry() {
        const id      = document.getElementById('wb-edit-id').value;
        const name    = document.getElementById('wb-edit-name').value.trim() || '未命名';
        const keys    = document.getElementById('wb-edit-keys').value.trim();
        const content = document.getElementById('wb-edit-content').value.trim();
        const enabled = document.getElementById('wb-edit-enabled').checked;

        if (!content) { showToast('请填写注入内容'); return; }

        let entries = wbLoad();
        if (id) {
            // 编辑已有
            const idx = entries.findIndex(x => x.id === id);
            if (idx >= 0) entries[idx] = { id, name, keys, content, enabled };
        } else {
            // 新建
            entries.push({ id: 'wb_' + Date.now(), name, keys, content, enabled });
        }
        wbSave(entries);
        wbCloseModal();
        wbRenderList();
        showToast('已保存');
    }

    // ---- 从 JSON 文件导入世界书 ----
    async function wbImportFromFile(input) {
        const file = input.files[0];
        if (!file) return;
        input.value = ''; // 允许重复导入同名文件

        let raw;
        try {
            raw = JSON.parse(await file.text());
        } catch(e) {
            showToast('JSON 解析失败，请检查文件格式');
            return;
        }

        // 尝试各种格式
        let rawEntries = null;

        // 格式1：SillyTavern 世界书导出 { entries: {0:{...}, 1:{...}} }
        if (raw.entries) {
            rawEntries = Array.isArray(raw.entries) ? raw.entries : Object.values(raw.entries);
        }
        // 格式2：character_book 包裹
        else if (raw.character_book?.entries) {
            const e = raw.character_book.entries;
            rawEntries = Array.isArray(e) ? e : Object.values(e);
        }
        // 格式3：直接是数组
        else if (Array.isArray(raw)) {
            rawEntries = raw;
        }

        if (!rawEntries || rawEntries.length === 0) {
            showToast('未找到世界书条目，请确认格式');
            return;
        }

        const newEntries = rawEntries.map((e, i) => ({
            id: 'wb_' + Date.now() + '_' + i,
            name: e.comment || e.name || e.title || ('条目' + (i + 1)),
            keys: Array.isArray(e.keys) ? e.keys.join(', ') : (e.key || e.keyword || ''),
            content: e.content || e.description || '',
            enabled: e.enabled !== false && e.disable !== true
        })).filter(e => e.content.trim());

        if (newEntries.length === 0) {
            showToast('条目内容均为空，导入失败');
            return;
        }

        // 追加到现有条目（不覆盖）
        const existing = wbLoad();
        wbSave([...existing, ...newEntries]);
        wbRenderList();
        showToast(`已导入 ${newEntries.length} 条世界书条目`);
    }

    // 设置页打开时刷新世界书列表
    const _origOpenSettings_wb = window.openSettings;
    window.openSettings = function() {
        if (_origOpenSettings_wb) _origOpenSettings_wb.apply(this, arguments);
        setTimeout(wbRenderList, 60);
    };

    // 切换角色后也刷新（openSettings 会被调，但直接在 settings 里刷更稳）
    document.addEventListener('DOMContentLoaded', wbRenderList);
    </script>

    <!-- ===== 钱包系统 ===== -->
    <script>
    // ---- 核心数据 ----
    const WALLET_KEY      = 'userWallet';       // 余额（字符串数字）
    const WALLET_TX_KEY   = 'walletTxList';     // 交易记录 JSON 数组
    const WALLET_INIT_BAL = 200;               // 初始金额

    function walletBalance() {
        const v = parseFloat(localStorage.getItem(WALLET_KEY));
        return isNaN(v) ? WALLET_INIT_BAL : v;
    }

    function walletSetBalance(amount) {
        localStorage.setItem(WALLET_KEY, amount.toFixed(2));
        refreshWalletUI();
    }

    function walletAddTx(type, amount, from, note) {
        // type: 'in' | 'out'
        let list = [];
        try { list = JSON.parse(localStorage.getItem(WALLET_TX_KEY) || '[]'); } catch(e) {}
        list.unshift({
            id: Date.now(),
            type,                          // 'in' 收入  'out' 支出
            amount: parseFloat(amount).toFixed(2),
            from: from || '',
            note: note || '',
            time: new Date().toISOString()
        });
        if (list.length > 200) list = list.slice(0, 200);   // 最多保留 200 条
        localStorage.setItem(WALLET_TX_KEY, JSON.stringify(list));
    }

    // ---- 全局接口（番茄钟等外部调用） ----
    window.addToWallet = function(amount, reason) {
        const cur = walletBalance();
        walletSetBalance(cur + parseFloat(amount));
        walletAddTx('in', amount, '系统奖励', reason || '');
        console.log('[Wallet] 收入:', amount, '原因:', reason);
    };

    // ---- 用户→角色转账 ----
    function openWalletPage() {
        refreshWalletUI();
        showPage('wallet-page');
    }

    // 从聊天界面加号菜单打开转账
    function openTransferFromChat() {
        window._transferOriginPage = 'chat-page';
        document.getElementById('plus-menu-panel').style.display = 'none';
        // 填写收款方信息（当前角色）
        const nameEl = document.getElementById('transfer-name');
        const avatarEl = document.getElementById('transfer-avatar');
        const balEl = document.getElementById('transfer-my-balance');
        if (nameEl) nameEl.textContent = (window.config && config.aiNickname) ? config.aiNickname : '对方';
        if (balEl) balEl.textContent = walletBalance().toFixed(2);
        // 头像
        if (avatarEl) {
            const charId = window.currentCharacterId;
            const chars = JSON.parse(localStorage.getItem('characters') || '{}');
            const char = chars[charId];
            if (char && char.avatar && char.avatar.startsWith('data:')) {
                avatarEl.innerHTML = `<img src="${char.avatar}" style="width:100%;height:100%;object-fit:cover;">`;
            } else if (char && char.avatar) {
                avatarEl.textContent = char.avatar;
            } else {
                avatarEl.textContent = (config.aiNickname || 'AI')[0];
            }
        }
        // 清空上次输入
        const amtEl = document.getElementById('transfer-amount-input');
        const noteEl = document.getElementById('transfer-note-input');
        if (amtEl) amtEl.value = '';
        if (noteEl) noteEl.value = '';
        showPage('transfer-page');
    }

    function confirmTransferToChar() {
        const amtRaw = parseFloat(document.getElementById('transfer-amount-input').value);
        if (isNaN(amtRaw) || amtRaw <= 0) { showToast('请输入有效金额'); return; }
        const amount = Math.round(amtRaw * 100) / 100;
        const cur = walletBalance();
        if (amount > cur) { showToast('余额不足'); return; }
        const note = (document.getElementById('transfer-note-input').value || '').trim();
        const toName = document.getElementById('transfer-name').textContent || '对方';

        walletSetBalance(cur - amount);
        walletAddTx('out', amount, toName, note);

        // 关闭转账页，回到来源界面
        const originPage = window._transferOriginPage || 'chat-page';
        showPage(originPage);

        // 只有从聊天界面发起的才插入气泡
        if (originPage !== 'chat-page') return;

        // 在聊天界面插入转账气泡（用户侧）
        const transferMsgText = `[转账给${toName}] ¥${amount.toFixed(2)}${note ? ' · ' + note : ''}`;

        // 写入 chatHistory（纯文字，供 AI 读取）
        const bubbleId = 'bubble_' + Date.now() + '_transfer';
        chatHistory.push({
            id: bubbleId,
            role: 'user',
            content: transferMsgText,
            timestamp: new Date().toISOString(),
            isTransfer: true
        });
        saveChatHistory();

        // 加入待发送队列，和普通消息一起走 batchSendTimer 流程
        pendingUserMessages.push(bubbleId);

        // 渲染转账卡片气泡（不显示已读勾，status=0）
        setTimeout(() => {
            displayMessage(transferMsgText, 'user', 0, new Date().toISOString(), false, bubbleId, false);
            const content = document.querySelector('#chat-page .content');
            if (content) content.scrollTop = content.scrollHeight;
        }, 100);

        // 重启计时器（和普通消息完全一致的流程）
        startBatchTimer();
    }

    // ---- 角色→用户收款 ----
    function receiveMoneyFromChar(amount, fromName) {
        // 只插入气泡，钱等用户点「收款」后才到账
        const bubbleId = 'bubble_' + Date.now() + '_receive';
        const receiveMsgText = `[转账给你] ¥${parseFloat(amount).toFixed(2)}`;
        chatHistory.push({
            id: bubbleId,
            role: 'assistant',
            content: receiveMsgText,
            timestamp: new Date().toISOString(),
            isTransfer: true
        });
        saveChatHistory();

        setTimeout(() => {
            displayMessage(receiveMsgText, 'assistant', 0, new Date().toISOString(), false, bubbleId, false);
            const content = document.querySelector('#chat-page .content');
            if (content) content.scrollTop = content.scrollHeight;
        }, 100);

        console.log('[Wallet] 收到转账气泡:', amount, '来自:', fromName, '（待用户收款）');
    }

    // ---- UI 刷新 ----
    function refreshWalletUI() {
        const bal = walletBalance();
        const fmt = bal.toFixed(2);

        // 钱包页余额
        const dispEl = document.getElementById('wallet-balance-display');
        if (dispEl) dispEl.textContent = fmt;

        // 我的页面入口余额预览
        const meEl = document.getElementById('me-wallet-balance');
        if (meEl) meEl.textContent = bal > 0 ? `¥${fmt}` : '';

        // 交易记录
        const txList = document.getElementById('wallet-tx-list');
        if (txList) {
            let list = [];
            try { list = JSON.parse(localStorage.getItem(WALLET_TX_KEY) || '[]'); } catch(e) {}
            if (list.length === 0) {
                txList.innerHTML = '<div style="text-align:center;color:#ccc;font-size:14px;padding:40px 0;">暂无交易记录</div>';
            } else {
                txList.innerHTML = list.map(tx => {
                    const d = new Date(tx.time);
                    const dateStr = `${d.getMonth()+1}/${d.getDate()} ${d.getHours().toString().padStart(2,'0')}:${d.getMinutes().toString().padStart(2,'0')}`;
                    const isIn = tx.type === 'in';
                    return `<div style="display:flex;align-items:center;padding:14px 16px;border-bottom:1px solid #f2f2f2;">
                        <div style="width:40px;height:40px;border-radius:50%;background:${isIn?'#e8f5e9':'#fff3e0'};display:flex;align-items:center;justify-content:center;margin-right:12px;flex-shrink:0;">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="${isIn?'#07c160':'#ff9800'}" stroke-width="2.5" stroke-linecap="round">
                                ${isIn ? '<path d="M12 19V5M5 12l7 7 7-7"/>' : '<path d="M12 5v14M5 12l7-7 7 7"/>'}
                            </svg>
                        </div>
                        <div style="flex:1;min-width:0;">
                            <div style="font-size:15px;color:#333;font-weight:500;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${tx.from || (isIn?'收入':'支出')}</div>
                            <div style="font-size:12px;color:#999;margin-top:2px;">${tx.note ? tx.note + ' · ' : ''}${dateStr}</div>
                        </div>
                        <div style="font-size:16px;font-weight:600;color:${isIn?'#07c160':'#333'};flex-shrink:0;">${isIn?'+':'-'}¥${tx.amount}</div>
                    </div>`;
                }).join('');
            }
        }
    }

    // ---- 转账气泡 HTML 生成 ----
    function renderTransferBubble(direction, amount, name, note) {
        const isOut = direction === 'out';
        const amtStr = parseFloat(amount).toFixed(2);
        const label = isOut ? `转账给${name}` : `${name}转账给你`;
        const noteHtml = note ? `<div style="font-size:11px;color:rgba(255,255,255,0.8);margin-top:2px;">${note}</div>` : '';
        return `<div style="border-radius:8px;overflow:hidden;min-width:200px;max-width:250px;">
            <div style="background:linear-gradient(135deg,#f5a11c,#f0920a);padding:14px 16px 14px 14px;display:flex;align-items:center;gap:12px;">
                <div style="width:46px;height:46px;border-radius:50%;border:2px solid rgba(255,255,255,0.9);display:flex;align-items:center;justify-content:center;flex-shrink:0;">
                    <svg width="24" height="24" viewBox="0 0 30 30" fill="none">
                        <path d="M24 11H4M24 11l-5-5M24 11l-5 5" stroke="white" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/>
                        <path d="M6 19H26M6 19l5-5M6 19l5 5" stroke="white" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </div>
                <div>
                    <div style="font-size:15px;color:#fff;font-weight:500;margin-bottom:3px;">${label}</div>
                    <div style="font-size:22px;font-weight:600;color:#fff;letter-spacing:0.5px;">¥ ${amtStr}</div>
                    ${noteHtml}
                </div>
            </div>
            <div style="background:#fff;padding:8px 14px;display:flex;align-items:center;justify-content:space-between;">
                <span style="font-size:13px;color:#999;">微信转账</span>
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#ccc" stroke-width="2">
                    <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/>
                </svg>
            </div>
        </div>`;
    }

    // ---- 转账详情页 ----
    // _pendingTransferDetail: { direction, amount, note, fromName, bubbleId, timestamp }
    function openTransferDetail(direction, amount, note, fromName, bubbleId, timestamp) {
        // direction: 'in' = 对方转给我（可操作），'out' = 我转给对方（只读）
        window._pendingTransferDetail = { direction, amount, note, fromName, bubbleId, timestamp };
        const amtStr = parseFloat(amount).toFixed(2);

        // 金额
        document.getElementById('td-amount').textContent = `¥ ${amtStr}`;

        // 标签：对方转给我 → "XX 转给你"；我转给对方 → "转给 XX"
        document.getElementById('td-label').textContent =
            direction === 'in' ? `${fromName} 转给你` : `转给 ${fromName}`;

        // 转账方：对方转给我 → fromName；我转给对方 → 我自己
        document.getElementById('td-from').textContent =
            direction === 'in' ? fromName : (config.userNickname || '我');

        // 状态
        const statusEl = document.getElementById('td-status');
        statusEl.textContent = '待收款';
        statusEl.style.color = '#f5a11c';

        // 备注
        const noteEl = document.getElementById('td-note');
        if (note) {
            document.getElementById('td-note-text').textContent = note;
            noteEl.style.display = 'block';
        } else {
            noteEl.style.display = 'none';
        }

        // 时间
        const t = new Date(timestamp || Date.now());
        document.getElementById('td-time').textContent =
            `${t.getFullYear()}/${t.getMonth()+1}/${t.getDate()} ` +
            `${t.getHours().toString().padStart(2,'0')}:${t.getMinutes().toString().padStart(2,'0')}`;

        // 头像
        const avatarEl = document.getElementById('td-avatar');
        const charId = window.currentCharacterId;
        const chars = JSON.parse(localStorage.getItem('characters') || '{}');
        const char = chars[charId];
        if (char && char.avatar && char.avatar.startsWith('data:')) {
            avatarEl.innerHTML = `<img src="${char.avatar}" style="width:100%;height:100%;object-fit:cover;border-radius:50%;">`;
        } else if (char && char.avatar) {
            avatarEl.textContent = char.avatar;
        } else {
            avatarEl.textContent = (config.aiNickname || 'AI')[0];
        }

        // 操作区
        if (direction === 'in') {
            // 对方转来的：大收款按钮 + 退回小字
            document.getElementById('td-accept-area').style.display = 'block';
            document.getElementById('td-readonly-area').style.display = 'none';
        } else {
            // 我转出的：只读，等待对方操作
            document.getElementById('td-accept-area').style.display = 'none';
            document.getElementById('td-readonly-area').style.display = 'block';
        }

        showPage('transfer-detail-page');
    }

    function doTransferAccept() {
        const d = window._pendingTransferDetail;
        if (!d) return;
        const amount = parseFloat(d.amount);
        walletSetBalance(walletBalance() + amount);
        walletAddTx('in', amount, d.fromName, d.note || '');
        document.getElementById('td-status').textContent = '已收款';
        document.getElementById('td-status').style.color = '#07c160';
        document.getElementById('td-accept-area').style.display = 'none';

        // 插入收款成功气泡（assistant侧）
        const successText = `[收款成功] ¥${amount.toFixed(2)}`;
        const bid = 'bubble_' + Date.now() + '_accept';
        chatHistory.push({ id: bid, role: 'assistant', content: successText, timestamp: new Date().toISOString() });
        saveChatHistory();
        setTimeout(() => {
            displayMessage(successText, 'assistant', 0, new Date().toISOString(), false, bid, false);
            const c = document.querySelector('#chat-page .content');
            if (c) c.scrollTop = c.scrollHeight;
        }, 300);

        // 插入一条用户侧的"系统触发"气泡让 AI 知道用户收了款，走正常队列
        const ackText = `[已收款 ¥${amount.toFixed(2)}]`;
        const ackId = 'bubble_' + Date.now() + '_ack';
        chatHistory.push({ id: ackId, role: 'user', content: ackText, timestamp: new Date().toISOString(), isSystem: true });
        saveChatHistory();
        pendingUserMessages.push(ackId);
        startBatchTimer();

        window._pendingTransferDetail = null;
        setTimeout(() => showPage('chat-page'), 600);
    }

    function doTransferRefund() {
        const d = window._pendingTransferDetail;
        if (!d) return;
        const amount = parseFloat(d.amount);
        document.getElementById('td-status').textContent = '已退回';
        document.getElementById('td-status').style.color = '#999';
        document.getElementById('td-accept-area').style.display = 'none';

        // 插入退回气泡（用户侧）并加入队列
        const refundText = `[退回] ¥${amount.toFixed(2)} 来自${config.userNickname || '我'}`;
        const bid = 'bubble_' + Date.now() + '_refund';
        chatHistory.push({ id: bid, role: 'user', content: refundText, timestamp: new Date().toISOString() });
        saveChatHistory();
        setTimeout(() => {
            displayMessage(refundText, 'user', 0, new Date().toISOString(), false, bid, false);
            const c = document.querySelector('#chat-page .content');
            if (c) c.scrollTop = c.scrollHeight;
        }, 300);
        pendingUserMessages.push(bid);
        startBatchTimer();

        window._pendingTransferDetail = null;
        setTimeout(() => showPage('chat-page'), 600);
    }

    // ---- 用户发起收款（向角色要钱）----
    function openCollectFromChat() {
        window._collectOriginPage = 'chat-page';
        document.getElementById('plus-menu-panel').style.display = 'none';
        const nameEl   = document.getElementById('collect-name');
        const avatarEl = document.getElementById('collect-avatar');
        if (nameEl)   nameEl.textContent = (window.config && config.aiNickname) ? config.aiNickname : '对方';
        if (avatarEl) {
            const charId = window.currentCharacterId;
            const chars  = JSON.parse(localStorage.getItem('characters') || '{}');
            const char   = chars[charId];
            if (char && char.avatar && char.avatar.startsWith('data:')) {
                avatarEl.innerHTML = `<img src="${char.avatar}" style="width:100%;height:100%;object-fit:cover;">`;
            } else if (char && char.avatar) {
                avatarEl.textContent = char.avatar;
            } else {
                avatarEl.textContent = (config.aiNickname || 'AI')[0];
            }
        }
        document.getElementById('collect-amount-input').value = '';
        document.getElementById('collect-note-input').value   = '';
        showPage('collect-page');
    }

    function confirmCollectFromChar() {
        const amtRaw = parseFloat(document.getElementById('collect-amount-input').value);
        if (isNaN(amtRaw) || amtRaw <= 0) { showToast('请输入有效金额'); return; }
        const amount = Math.round(amtRaw * 100) / 100;
        const note   = (document.getElementById('collect-note-input').value || '').trim();
        const toName = document.getElementById('collect-name').textContent || '对方';

        showPage('chat-page');

        // 插入收款请求气泡（用户侧，角色收到后可以转账）
        const collectMsgText = `[收款请求] ¥${amount.toFixed(2)}${note ? ' · ' + note : ''}`;
        const bubbleId = 'bubble_' + Date.now() + '_collect';
        chatHistory.push({
            id: bubbleId,
            role: 'user',
            content: collectMsgText,
            timestamp: new Date().toISOString(),
        });
        saveChatHistory();

        // 加入待发送队列，走 batchSendTimer 正常流程
        pendingUserMessages.push(bubbleId);

        setTimeout(() => {
            displayMessage(collectMsgText, 'user', 0, new Date().toISOString(), false, bubbleId, false);
            const content = document.querySelector('#chat-page .content');
            if (content) content.scrollTop = content.scrollHeight;
        }, 100);

        // 重启计时器
        startBatchTimer();
    }

    // ---- 渲染收款请求气泡 ----
    function renderCollectBubble(amount, note) {
        const amtStr = parseFloat(amount).toFixed(2);
        const noteHtml = note ? `<div style="font-size:11px;color:rgba(255,255,255,0.8);margin-top:2px;">${note}</div>` : '';
        return `<div style="border-radius:8px;overflow:hidden;min-width:200px;max-width:250px;">
            <div style="background:linear-gradient(135deg,#07c160,#06ad56);padding:14px 16px 14px 14px;display:flex;align-items:center;gap:12px;">
                <div style="width:46px;height:46px;border-radius:50%;border:2px solid rgba(255,255,255,0.9);display:flex;align-items:center;justify-content:center;flex-shrink:0;">
                    <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M12 19V5M5 12l7-7 7 7"/>
                    </svg>
                </div>
                <div>
                    <div style="font-size:15px;color:#fff;font-weight:500;margin-bottom:3px;">向你收款</div>
                    <div style="font-size:22px;font-weight:600;color:#fff;letter-spacing:0.5px;">¥ ${amtStr}</div>
                    ${noteHtml}
                </div>
            </div>
            <div style="background:#fff;padding:8px 14px;display:flex;align-items:center;justify-content:space-between;">
                <span style="font-size:13px;color:#999;">微信转账</span>
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#ccc" stroke-width="2"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/></svg>
            </div>
        </div>`;
    }

    // ---- 渲染退回气泡 ----
    function renderRefundBubble(amount, fromName) {
        const amtStr = parseFloat(amount).toFixed(2);
        return `<div style="border-radius:8px;overflow:hidden;min-width:200px;max-width:250px;">
            <div style="background:linear-gradient(135deg,#e8870a,#d4730a);padding:14px 16px 14px 14px;display:flex;align-items:center;gap:12px;">
                <div style="width:46px;height:46px;border-radius:50%;border:2px solid rgba(255,255,255,0.9);display:flex;align-items:center;justify-content:center;flex-shrink:0;">
                    <svg width="24" height="24" viewBox="0 0 30 30" fill="none">
                        <path d="M24 11H4M24 11l-5-5M24 11l-5 5" stroke="white" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/>
                        <path d="M6 19H26M6 19l5-5M6 19l5 5" stroke="white" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </div>
                <div>
                    <div style="font-size:15px;color:#fff;font-weight:500;margin-bottom:3px;">已退回</div>
                    <div style="font-size:22px;font-weight:600;color:#fff;letter-spacing:0.5px;">¥ ${amtStr}</div>
                </div>
            </div>
            <div style="background:#fff;padding:8px 14px;display:flex;align-items:center;justify-content:space-between;">
                <span style="font-size:13px;color:#999;">微信转账</span>
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#ccc" stroke-width="2"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/></svg>
            </div>
        </div>`;
    }

    // ---- 收款成功气泡（用户点击「收款」后显示）----
    function renderCollectSuccessBubble(amount) {
        const amtStr = parseFloat(amount).toFixed(2);
        return `<div style="border-radius:8px;overflow:hidden;min-width:200px;max-width:250px;">
            <div style="background:linear-gradient(135deg,#f5a11c,#f0920a);padding:14px 16px 14px 14px;display:flex;align-items:center;gap:12px;">
                <div style="width:46px;height:46px;border-radius:50%;border:2px solid rgba(255,255,255,0.9);display:flex;align-items:center;justify-content:center;flex-shrink:0;">
                    <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2.8" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M20 6L9 17l-5-5"/>
                    </svg>
                </div>
                <div>
                    <div style="font-size:15px;color:#fff;font-weight:500;margin-bottom:3px;">已收款</div>
                    <div style="font-size:22px;font-weight:600;color:#fff;letter-spacing:0.5px;">¥ ${amtStr}</div>
                </div>
            </div>
            <div style="background:#fff;padding:8px 14px;display:flex;align-items:center;justify-content:space-between;">
                <span style="font-size:13px;color:#999;">微信收款</span>
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#ccc" stroke-width="2"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/></svg>
            </div>
        </div>`;
    }

    // ---- AI 输出 [收款请求:N] 标签时处理 ----
    // 在 processAndDisplaySegments 里通过 cleanApiResponse 之前已有 [转账:N] 解析
    // 退回气泡由 AI 输出 [退回:N] 标签触发

    // 触发 AI 回复（走正常批量计时器，使用用户设置的等待时间）
    function triggerAIReplyWithDelay() {
        // 取消已有的批量计时器
        if (window.batchSendTimer) {
            clearTimeout(window.batchSendTimer);
            window.batchSendTimer = null;
        }
        // 用版本号作废旧的延迟调用
        if (!window._walletTriggerToken) window._walletTriggerToken = 0;
        const myToken = ++window._walletTriggerToken;

        const waitTime = (parseInt(localStorage.getItem('batchWaitTime')) || 7) * 1000;
        setTimeout(() => {
            // 如果有更新的调用，本次作废
            if (window._walletTriggerToken !== myToken) return;
            if (typeof isWaitingForAI !== 'undefined' && isWaitingForAI) return;
            if (typeof callAPIToGenerate === 'function') {
                window._allowCallAPI = true;
                callAPIToGenerate();
            }
        }, waitTime);
    }

    window._parseSpecialTags = function(text) {
        let processed = text;
        // [退回:N] → 退回气泡
        const refundMatches = [...processed.matchAll(/\[退回[:：](\d+(?:\.\d{1,2})?)\]/g)];
        if (refundMatches.length > 0) {
            refundMatches.forEach(m => {
                const amount = parseFloat(m[1]);
                const fromName = config.aiNickname || '对方';
                walletSetBalance(walletBalance() + amount);
                walletAddTx('in', amount, fromName, '退回转账');
                const bubbleId = 'bubble_' + Date.now() + '_refund';
                const refundText = `[退回] ¥${amount.toFixed(2)} 来自${fromName}`;
                chatHistory.push({ id: bubbleId, role: 'assistant', content: refundText, timestamp: new Date().toISOString() });
                saveChatHistory();
                setTimeout(() => {
                    displayMessage(refundText, 'assistant', 0, new Date().toISOString(), false, bubbleId, false);
                    const c = document.querySelector('#chat-page .content');
                    if (c) c.scrollTop = c.scrollHeight;
                }, 200);
            });
            processed = processed.replace(/\[退回[:：]\d+(?:\.\d{1,2})?\]/g, '').trim();
        }

        // [收款:N] → AI 收下了用户的转账，显示收款成功气泡
        const acceptMatches = [...processed.matchAll(/\[收款[:：](\d+(?:\.\d{1,2})?)\]/g)];
        if (acceptMatches.length > 0) {
            acceptMatches.forEach(m => {
                const amount = parseFloat(m[1]);
                const bubbleId = 'bubble_' + Date.now() + '_aiaccept_' + Math.random().toString(36).slice(2,6);
                const acceptText = `[收款成功] ¥${amount.toFixed(2)}`;
                chatHistory.push({ id: bubbleId, role: 'assistant', content: acceptText, timestamp: new Date().toISOString() });
                saveChatHistory();
                setTimeout(() => {
                    displayMessage(acceptText, 'assistant', 0, new Date().toISOString(), false, bubbleId, false);
                    const c = document.querySelector('#chat-page .content');
                    if (c) c.scrollTop = c.scrollHeight;
                }, 300);
            });
            processed = processed.replace(/\[收款[:：]\d+(?:\.\d{1,2})?\]/g, '').trim();
        }

        return processed;
    };

    // ---- 初始化 ----
    (function initWallet() {
        // 如果从来没存过余额，写入初始值
        if (localStorage.getItem(WALLET_KEY) === null) {
            localStorage.setItem(WALLET_KEY, WALLET_INIT_BAL.toFixed(2));
        }
        // 页面就绪后刷新
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', refreshWalletUI);
        } else {
            refreshWalletUI();
        }
        // 每次打开我的页面也刷新
        const _origShowPage = window.showPage;
        if (_origShowPage) {
            window.showPage = function(pageId, ...args) {
                _origShowPage.call(this, pageId, ...args);
                if (pageId === 'me-page' || pageId === 'wallet-page') refreshWalletUI();
            };
        }
    })();
    </script>
\n</body>
</html>
